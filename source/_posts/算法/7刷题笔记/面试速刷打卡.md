---
title: 面试力扣打卡
tags:
  - 算法
categories:
  - 算法
  - 7刷题笔记
date: 2022-9-02 11:51:56

---

算法

- [双指针](Leetcode%20题解%20-%20双指针.md)
- [排序](Leetcode%20题解%20-%20排序.md)
- [贪心思想](Leetcode%20题解%20-%20贪心思想.md)
- [二分查找](Leetcode%20题解%20-%20二分查找.md)
- [分治](Leetcode%20题解%20-%20分治.md)
- [搜索](Leetcode%20题解%20-%20搜索.md)
- [动态规划](Leetcode%20题解%20-%20动态规划.md)
- [数学](Leetcode%20题解%20-%20数学.md)

数据结构

- [链表](Leetcode%20题解%20-%20链表.md)
- [树](Leetcode%20题解%20-%20树.md)
- [栈和队列](Leetcode%20题解%20-%20栈和队列.md)
- [哈希表](Leetcode%20题解%20-%20哈希表.md)
- [字符串](Leetcode%20题解%20-%20字符串.md)
- [数组与矩阵](Leetcode%20题解%20-%20数组与矩阵.md)
- [图](Leetcode%20题解%20-%20图.md)
- [位运算](Leetcode%20题解%20-%20位运算.md)

## 动态规划 

### 打卡

#### 斐波那契数列

- 70 爬楼梯 √ 22/3/4
- 198 打家劫舍 √
- 213 打家劫舍II √
- 信件错排(没找到测试平台) √
- 母牛生产 https://blog.csdn.net/weixin_43525710/article/details/106759968 √

#### 背包

- 322 零钱兑换 √ 22/3/5
- 416 分割等和子集 √
- **494 目标和**  
- 474 一和零 √
- 518 **硬币组合数**  与顺序无关的方案数 √
- 377 组合总和 跟顺序有关(不玄学)
- 139 字符串按单词列表分割 顺序有关 以及装备包操作方式 

#### 最长递增子序列

- 300 √ #优化
- 最长数对链 连续变大的区间 (# 排序子序列证明:  随便排都行) 贪心则是排右边 √
-  376 摆动序列 √ 比较新奇

#### 最长公共子序列

- 1143 最长公共子序列 √

#### 股票交易

- 309 有一天冷却期的股票买卖 √
- 714 带手续费的股票买卖 √
- 123 只进行两次买卖的股票交易 √
- 188 最多k笔交易 √

#### 字符串编辑

#### 分割整数

- 343 将整数n拆分和为n, 保证拆分的数乘积最大 #是否拆分 
- 279 完全平方数 √
- 91 # 饶了点弯



### 背包

#### 494 目标和 问题转换

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int m) {
        // sum(P) - sum(N) = m
        // sum(p) + sum(n) = sum
        // 2 * sum(p) = m + sum
        m = Math.abs(m);
        int sum = 0;
        for (int num: nums) {
            sum += num;
        }              
        if (sum < m || (m + sum) % 2 == 1) return 0;
        m = (m + sum) / 2;
        int[] f = new int[m+1];
        f[0] = 1;
        for (int num: nums) {
            for(int j = m; j >= num; j--) {
                f[j] += f[j - num];
            }
        }  
        return f[m];
    }
}
```

#### 518 **硬币组合数**

```java
class Solution {
    public int change(int amount, int[] coins) {
        // 组合数
        int[] dp = new int[amount+10]; 
        dp[0] = 1;
        int n = coins.length;
        for (int i = 0; i < n; i++) {
            for (int j = coins[i]; j <= amount; j++) 
                dp[j] += dp[j-coins[i]];
        }
        return dp[amount];
    }
}
```

#### 377 组合总和IV

外层循环是遍历从 1 到 target 的值，内层循环是遍历数组 nums 的值，在计算 dp[i]的值时，nums 中的每个小于等于 i 的元素都可能作为元素之和等于 i 的排列的最后一个元素。例如，1 和 3 都在数组 nums中，计算 dp[4]的时候，排列的最后一个元素可以是 1 也可以是 3，因此 dp[1] 和 dp[3]都会被考虑到，即不同的顺序都会被考虑到。

与之相反的枚举办法:  在计算dp[i]的值时 已经先放了1 在放 3 而不是 有 1,3 和 3, 1

只统计了一种方法

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int n = nums.length;
        int[] f = new int[target+1];
        // 初始化 凑背包为0 什么都不选就是一种方案
        f[0] = 1;
        for (int i = 1; i <= target; i++) {
            for (int j = 1; j <= n; j++) {
                if (i - nums[j-1] >= 0) {
                    f[i] += f[i-nums[j-1]];
                }
            }
        }
        return f[target];

    }
}
```



#### 139 字符串按单词列表分割 

```java
class Solution {
    public boolean wordBreak(String s, List<String> w) {
        //
        int m = s.length();
        boolean[] f = new boolean[m+1];
        f[0] = true;
        for (int i = 1; i <= m; i++) {
            for (String a: w) {
                int len = a.length();
                if (len <= i) {
                    f[i] = f[i] || (f[i-len] && s.substring(i-len,i).equals(a));
                }
            }
        }
        return f[m];

    }
}
```



### 最长上升子序列

#### 优化

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        //f[i] 存储长度为i的最长递增子序列的末尾最小值
        // 优化 贪心 相同长度 保留最大潜力 对 每个数为尾部 之前 维护 长度为1 长度为2的尾部最小
        // 可以证明单调 可以二分
        int n = nums.length;
        int[] f = new int[n+1];
        int res = 0;
        f[0] = -0x3f3f3f3f; // 初始化 保留最大潜力
        for (int i = 1; i <= n; i++) {  
            int idx = b_search(f,0,res,nums[i-1]);
            // 找到当前数可以更新到哪(>=的左边界) 
            f[idx] = nums[i-1];
            // 越界 == r + 1 (已有的没有能更新的位置)
            if (idx == res + 1) {
                res ++;
            }
        }
        return res;
    }
    // 1 2 3 5    4   >= target 的 左边界
    public int b_search(int[] f, int l, int r, int target) {
        if (l > r) return l;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (f[mid] < target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        } 
        return l;
    }
}
```

#### 376 摆动序列

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        // 以[i] 为尾即可 
        int n = nums.length;
        int[] f = new int[n];
        int[] g = new int[n];
        f[0] = 1;
        g[0] = 1;
        int res = 1;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    f[i] = Math.max(f[i], g[j] + 1);
                } else if (nums[j] > nums[i]) {
                    g[i] = Math.max(g[i], f[j] + 1);
                }
            }
            res = Math.max(f[i],res);
            res = Math.max(g[i],res);
        }
        return res;

    }
}
```



### 分割整数

#### 343. 整数拆分

```java
class Solution {
    public int integerBreak(int n) {
        // f[i] 拆分i的最大积
        int[] f = new int[n+1];
        f[0] = -1; // 不合法 
        f[1] = 1;
        f[2] = 1;
        if (n == 2) return f[2];
      

        for (int i = 3; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                int l = Math.max(j,f[j]);
                int r = Math.max(i - j, f[i - j]);
                // System.out.print(l + " " + r + "  --  ");
                f[i] = Math.max(l * r,f[i]);
                
            }
            // System.out.println(f[i]);
        }
        return f[n];
    }
}
```



## 搜索

### 打卡

BFS

- 1091 模板题√ 22/3/5
- 279  完全平方数构成n的最少个数√ 22/3.6
- 127 单词接龙 √

DFS

- 695 查找最大的连通面积√ 
- 200 矩阵中的连通分量数目√
- 547 好友关系的连通分量数目√
- **130 填充封闭区域**   # 写不出来 思路出问题了(对于是否被包围判断太过困难)
- **417 能到达的太平洋和大西洋的区域** 从边缘(终点)思考

回溯

- 17 数字键盘组合 √
- 93 复原IP √
- 79 单词搜索 √   思考方式固定为能进入在搜索
- 257 下次再做
- 46 排列 √
- 47 去重排列 # 剪枝条件: st[i]剪枝不是减根(树层剪枝)而是减重复的树叶(树枝去重)  !st[i] 才是树层剪枝 才是符合我的想象的剪枝
- 77 组合 √ # 用 start 是因为再取前面就是重复 与顺序无关

### 130 填充封闭区域

写在前面
本题给定的矩阵中有三种元素：

字母 X；
被字母 X 包围的字母 O；
没有被字母 X 包围的字母 O。
本题要求将所有被字母 X 包围的字母 O都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。

注意到题目解释中提到：任何边界上的 O 都不会被填充为 X。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上，具体地说：

对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；
最后我们遍历这个矩阵，对于每一个字母：
如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；
如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。

```java
class Solution {
    int n, m;
    int[] dx = {-1,0,1,0}, dy = {0,-1,0,1};
    public void solve(char[][] g) {
        // 三种区域 先从外将不符合的O 区分为T 剩下的X化为O T 化为O
        n = g.length;
        m = g[0].length;
        for (int i = 0; i < n; i++) {
            if (g[i][0] == 'O') {
                dfs(g,i,0,'T');
            }
            if (g[i][m-1] == 'O') {
                dfs(g,i,m-1,'T');
            }
        }
        for (int i = 0; i < m; i++) {
            if (g[0][i] == 'O') {
                dfs(g,0,i,'T');
            }
            if (g[n-1][i] == 'O') {
                dfs(g,n-1,i,'T');
            }
        }
        // for (int i = 1; i < n-1; i++) {
        //     for (int j = 1; j <m -1; j++ ){
        //         if (g[i][j] == 'O') {
        //             dfs(g,i,j,'X');
        //         }   
        //     }
        // } 这一步可以省了
         for (int i = 0; i < n; i++) {
            for (int j = 0; j <m; j++ ){
                if (g[i][j] == 'T') {
                    g[i][j] = 'O';
                } else if (g[i][j] == 'O') {
                    g[i][j] = 'X';
                }  
            }
        }

    }

    public void dfs(char[][] g, int x, int y, char c) {
        g[x][y] = c;
        for (int i = 0; i < 4; i++) {
            int a = x + dx[i], b = y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= m) continue;
            if (g[a][b] == 'O') {
                dfs(g,a,b,c);
            }
        }
    }


}
```

### 417 能到达的太平洋和大西洋的区域



### 79 单词搜索

```java
class Solution {
    int n, m;
    boolean[][] vis;
    int[] dx = {-1,0,1,0}, dy = {0,-1,0,1};
    public boolean exist(char[][] g, String s) {
        n = g.length;
        m = g[0].length;
        vis = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (g[i][j] == s.charAt(0)) {
                    if (dfs(g,s,0,i,j)) return true;
                }
            }
        }
        return false;
    }
    public boolean dfs(char[][] g, String s, int u, int x, int y) {
        vis[x][y] = true;
        if (u == s.length() - 1) return true;
        for (int i = 0; i < 4; i++) {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < n && b >= 0 && b < m && (g[a][b] == s.charAt(u+1)) && vis[a][b] == false) {
                if (dfs(g,s,u+1,a,b)) {
                    return true;
                }
            }
        }
        vis[x][y] = false;
        
        return false;
    }
}
```



## 图论

### 打卡

二分图

- 785 判断二分图

拓扑排序

- 207 环检测
- 210 拓扑排序输出数组

并查集

- 684 多一条边的树 删除一条边 

## 数学

素数

最大公约数最小倍数

相遇问题



## 排序

### 打卡

- 快速选择
  - 215 

## 贪心

### 打卡

- 455 分配饼干 √
- 435 无重叠区间 √
- 452 投飞镖戳气球 ->Integer.compare(a[1],b[1]) 排序 √
- 406 根据身高重建队列 #不会 贪心 保证先插入的不会被后插入的影响  
- 121 一次交易的最大值股票 √
- 122  多笔交易 # 贪心思路? 最大利润就是只要明天能赚钱今天就买  a <= b <= c <= d   d - a = d -c  + (c - b) + b -a

### 406 根据身高重建队列

```java
Arrays.sort(people, (a, b) -> (a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]));
    List<int[]> queue = new ArrayList<>();
    for (int[] p : people) {
        queue.add(p[1], p);
    }
    return queue.toArray(new int[queue.size()][]);
```

### 122 无限交易但只能持有一次股票

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i-1]) {
                ans += prices[i] - prices[i-1];
            }
        }   
        return ans;
    }
}
```



## 字符串

### 打卡

- 28 判断子串: kmp: next数组只与模式串有关是回溯next位置, 相等的前缀与后缀长度 

  - >  aabaaf
    >
    > 010120
    >
    > 滑动窗口: 窗口大小从3开始





## KMP

```java
class Solution {
    int n, m;
    public int strStr(String s, String p) {
        n = s.length();
        m = p.length();
        int[] ne = new int[m];
        initNext(ne,p.toCharArray());
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = ne[j-1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) {
                return i - m + 1;
            }
        }
        return -1;
    }
    public void initNext(int[] ne, char[] p) {
        for (int i = 1, j = 0; i < m; i++) {
            while (j > 0 && p[i] != p[j]) j = ne[j-1];
            if (p[i] == p[j]) j++;
            ne[i] = j;
        }
    }
}
```

## 树

### 打卡

- 104 树的最大深度 √
- 110 平衡二叉树 # 读题小细节 每一个子树都要判断
- 543 同110 不只是左右两个子树需要求深度, 每个子树都要判断
- 226 翻转二叉树 √
- 617 归并二叉树 # 前序遍历会改变子树状态 会使结果不符合预期, 用后序
-  

## 分治

- 241 计算表达式不同组合的结果√
- 95 不同的二叉搜索树 #边界也要同步递归 √



## 链表

#### 打卡

- 160 找链表交点 # 不要想连成环这种复杂的操作 
- 206 链表反转 √ 递推与递归

#### 160 相交链表

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 交替遍历 第一次重叠即是交点
        ListNode p = headA, q = headB;
        while (p != q) {
            p = p == null ? headB: p.next;
            q = q == null ? headA: q.next;
        }
        return p;
    }
}
```



