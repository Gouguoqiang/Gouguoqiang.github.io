---
title: 图论-最小生成树
tags:
  - 图论
  - 最小生成树
categories:
  - 算法
  - 4图论
date: 2022-9-02 11:51:56
---



## 总纲领

给定一个图,求出连通所有点的最小(权值和)生成树

prim算法

	邻接矩阵图
	- 朴素 n方 从一个部落扩展到整个地球 每次选取最短的边 (集合外点到集合内点) 
	- 堆优化

克鲁斯卡尔

> 只需要存储边信息即可 将边大小从小到大排序
>
> 维护并查集 遍历到一条边如果为连接则连接 将结果添加到集合

证明:  如果不选这条边 那么最终生成的树里把这条边加上则会形成一个换 选这条边不会使总结果更差

# Prim

## AcWing 858. Prim算法求最小生成树 

`难度：简单`

### 题目描述

给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。

给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。

由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。

**输入格式**

第一行包含两个整数n和m。

接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。

**输出格式**

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。

**数据范围**

$1≤n≤500,$
$1≤m≤105,$
图中涉及边的边权的绝对值均不超过10000。

```r
输入样例：

4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4

输出样例：

6
```

### Solution

```java
import java.io.*;
import java.util.*;

public class Main{
    static final int INF = 0x3f3f3f3f, N = 510;
    static int[][] g = new int[N][N];
    static boolean[] st = new boolean[N];
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
//        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        String[] s = br.readLine().split(" ");
        int n = Integer.parseInt(s[0]);
        int m = Integer.parseInt(s[1]);

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                g[i][j] = i == j ? 0 : INF;
            }
        }
        while (m-- > 0) {
            s = br.readLine().split(" ");
            int x = Integer.parseInt(s[0]);
            int y = Integer.parseInt(s[1]);
            int z = Integer.parseInt(s[2]);
            g[x][y] = Math.min(g[x][y],z);
        }

        System.out.println(prim(n));
//        bw.close();
        br.close();
    }
    public static int prim(int n) {
        int res = 0;
        for (int i = 1; i <= n; i++) {
            int t = -1;
            for (int j = 1; j <= n; j++) {
                if (!st[j] && (t == -1 || ) )
            }
        }
    }

}
```

