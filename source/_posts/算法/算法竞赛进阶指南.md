---
title: 算法竞赛进阶指南note
tags:
  - note
  - 排序
categories:
  - 算法
date: 2023-5-18 10:40:06
description: 算法进阶

---

## 基本算法

**位运算**

​	语言层面: int 有符号整数 最高位符号位

​	整数: 原码表示

​	负数: 由其整数的补码表示

​	lowbit: 取出最后一个二进制1的数值 n & (~n + 1), -n =  ~n + 1(取反+1 正是补码) (=n & -n)

​	快速幂: 将数的运算分解成按位的运算

进阶: 状态压缩

​	

**递推与递归**

一个实际问题的各种可能情况构成的集合称为状态空间,算法和数据结构用于提高遍历效率,

按照状态空间大小,有如下几种枚举形式和遍历方式

| 枚举形式 | 状态空间规模      | 一般遍历方式 |
| -------- | ----------------- | ------------ |
| 多项式   | pow(n,k), k为常数 | 循环,递推    |
| 指数     | pow(k,n), k为常数 | 递归,位运算  |
| 组合     | Cnm               | 递归+剪枝    |
| 排列     | n!                | 递归         |
|          |                   |              |

指数问题: 从n个数中选任意个数, 时间复杂度可可理解为多个组合问题cn1 + cn2 +.. + cn(n-1) + cnn = pow(2,n), 但搜索方式同组合问题

组合问题: 与顺序无关从n个数中选m个数, 搜索方式同指数问题,对指数问题剪枝



> C(n,m) = A(n,m) / m!
>
> C(n,m)表示从n个不同元素中取出m个元素的组合数，而A(n,m)表示从n个不同元素中取出m个元素的排列数。这两个概念的区别在于，组合只关心元素的选取结果，而不考虑它们的顺序；排列则包括元素的顺序。
>
> 将A(n,m)除以m!，可以将A(n,m)中m个元素的顺序对组合数进行“去重”。因为对于每一种组合，都存在m!种排列方式，使得这些排列方式的元素集合是相同的。例如，从{1,2,3}中取出2个元素的组合有3种：{1,2}、{1,3}和{2,3}；而它们所对应的排列数分别为2!=2、2!=2和2!=2。因此，将A(n,m)除以m!可以得到从n个不同元素中取出m个元素的组合数C(n,m)，即
>
> C(n,m) = A(n,m) / m!
>
> 这个公式的现实意义就是，从n个不同元素中取出m个元素的组合数可以通过从n个元素中取出m个元素的排列数除以m!来计算。

排列问题:  回溯模版

> 每次递归for选择列表,

进阶: 对问题进行抽象

费解的开关: 5*5的开1关0 你可以操作任意位置 使其以及其上下左右置反, 求全部置0的最小步数

奇怪的汉诺塔: n个盘, 4个塔

约数之和: pow(A,B) 的约数之和 mod 9901



**前缀和**





