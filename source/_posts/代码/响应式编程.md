---
title: 响应式编程
tags:
  - code
categories:
  - 实操
keywords: gradle。
description: gradle使用。
date: 2023年10月3日17:52:44


---

> 传统编程各种增强各种用，赋予角色，适配器模式，

## foreword

### 并发并行

 并发实际上还是单核CPU 只不过通过调度像是并行一样，任务调度很重要，并行则是真正的同时进行

> 在进行并行计算时，需要注意以下几个方面：
> 1.资源竞争：并行计算可能导致资源竞争，例如多个线程竞争同一个内存地址或 I/O 设备。资源竞争可能导致系统性能下降，甚至出现死锁。为了避免资源竞争，需要确保在并行计算期间对共享资源进行正确的同步和互斥。
> 2.线程安全：在并行计算中，需要确保线程之间可以安全地访问共享数据。这可以通过使用线程安全的数据结构和同步原语来实现。例如，在 C++ 中，可以使用 std::mutex 或 std::lock_guard 对共享数据进行加锁，以确保线程安全。
> 3.负载均衡：在并行计算中，需要确保各个线程或处理器之间的工作负载均衡。如果某个线程或处理器的工作负载过重，而其他线程或处理器的工作负载较轻，那么系统的整体性能可能会受到影响。可以通过调整任务分配策略或使用动态负载均衡技术来解决这个问题。
> 4.通信和同步：在并行计算中，线程之间需要进行通信和同步，以确保各个线程能够按照预期的顺序执行。可以使用各种同步原语（如信号量、条件变量等）和通信机制（如管道、消息队列等）来实现线程间的通信和同步。
> 5.性能调优：并行计算并不总是能提高性能。在某些情况下，由于线程之间的切换开销、同步和通信的开销等原因，并行计算可能导致性能下降。因此，在进行并行计算时，需要关注性能，并根据实际情况进行性能调优。
> 6.可扩展性：在进行并行计算时，需要确保系统具有良好的可扩展性，以便能够方便地添加或删除处理器或线程。这可以通过使用可扩展的数据结构和算法来实现。
> 7.测试和调试：并行计算可能导致复杂的问题，因此需要进行充分的测试和调试。在测试和调试过程中，需要关注线程安全、资源竞争、性能等方面的问题，确保并行计算能够正确、高效地运行。

线程只是一个对象，CPU时间片会切换执行这些线程

### 背压

一种背压现象：生产者速度大于消费者速度，解决方案称为背压机制

背压机制是两者的衔接者类似大坝，对上游进行承压，下游进行按需请求

### Flux源码设计



```java
@Deprecated
	public final Disposable subscribe(
			@Nullable Consumer<? super T> consumer, 
			@Nullable Consumer<? super Throwable> errorConsumer,
			@Nullable Runnable completeConsumer,
			@Nullable Consumer<? super Subscription> subscriptionConsumer) {
		return subscribeWith(new LambdaSubscriber<>(consumer, errorConsumer,
				completeConsumer,
				subscriptionConsumer,
				null));
	}
```



### java泛型通配符

### 通配符

##### 上界通配符和下界通配符的概念

**上界通配符（Upper Bounded Wildcard）**

上界通配符用于限制泛型类型参数必须是指定类型或指定类型的子类。使用 `extends` 关键字指定上界。

语法：

```java
<? extends Type>
```

例如，假设我们有一个泛型方法 `printList`，它接受一个列表，并打印列表中的元素。但我们希望该方法只能接受 Number 类型或其子类的列表，可以使用上界通配符来实现：

```java
public static void printList(List<? extends Number> list) {
    for (Number element : list) {
        System.out.println(element);
    }
}

// 调用示例
List<Integer> integerList = Arrays.asList(1, 2, 3);
printList(integerList); // 可以正常调用

List<String> stringList = Arrays.asList("Hello", "World");
printList(stringList); // 编译错误，String 不是 Number 的子类
```

在上面的示例中，`printList` 方法使用 `<? extends Number>` 定义了一个上界通配符，表示方法接受一个 Number 类型或其子类的列表。因此，我们可以传递一个 Integer 类型的列表作为参数，但不能传递一个 String 类型的列表。

**下界通配符（Lower Bounded Wildcard）**

下界通配符用于限制泛型类型参数必须是指定类型或指定类型的父类。使用 `super` 关键字指定下界。

语法：

```java
<? super Type>
```

例如，假设我们有一个泛型方法 `addToList`，它接受一个列表和一个要添加到列表中的元素。但我们希望该方法只能接受 Object 类型或其父类的元素，可以使用下界通配符来实现：

```java
public static void addToList(List<? super Object> list, Object element) {
    list.add(element);
}

// 调用示例
List<Object> objectList = new ArrayList<>();
addToList(objectList, "Hello");
addToList(objectList, 42);

List<String> stringList = new ArrayList<>();
addToList(stringList, "World"); // 编译错误，String 不是 Object 的父类
```

在上面的示例中，`addToList` 方法使用 `<? super Object>` 定义了一个下界通配符，表示方法接受一个 Object 类型或其父类的列表，并且可以向列表中添加任意类型的元素。因此，我们可以将字符串和整数添加到 `objectList` 中，但不能将字符串添加到 `stringList` 中。

需要注意的是，上界通配符和下界通配符主要用于灵活地处理泛型类型参数，以便在泛型代码中处理不同类型的数据。它们提供了更大的灵活性和复用性。

##### 在泛型方法和泛型接口中使用通配符的场景

**泛型方法中使用通配符的场景：**

1. 读取操作：当方法只需要从泛型参数中获取值时，可以使用上界通配符 `? extends T`，以表示该方法适用于任何 T 类型或其子类。

   ```java
   public static <T> void printList(List<? extends T> list) {
       for (T element : list) {
           System.out.println(element);
       }
   }
   
   // 调用示例
   List<Integer> integerList = Arrays.asList(1, 2, 3);
   printList(integerList); // 可以正常调用
   
   List<String> stringList = Arrays.asList("Hello", "World");
   printList(stringList); // 可以正常调用
   ```

2. 写入操作：当方法需要向泛型参数中写入值时，可以使用下界通配符 `? super T`，以表示该方法适用于任何 T 类型或其父类。

   ```java
   public static <T> void addToList(List<? super T> list, T element) {
       list.add(element);
   }
   
   // 调用示例
   List<Object> objectList = new ArrayList<>();
   addToList(objectList, "Hello");
   addToList(objectList, 42);
   
   List<Number> numberList = new ArrayList<>();
   addToList(numberList, 3.14);
   addToList(numberList, 123);
   ```

**泛型接口中使用通配符的场景：**

1. 定义灵活的容器：当定义一个容器类时，希望该容器可以存储任意类型的数据，可以使用无限制通配符 `<?>`。

   ```java
   public interface Container<E> {
       void add(E element);
       E get();
   }
   
   // 实现示例
   public class AnyContainer implements Container<?> {
       private Object element;
   
       public void add(Object element) {
           this.element = element;
       }
   
       public Object get() {
           return element;
       }
   }
   ```

2. 限制类型范围：当希望泛型接口只能处理特定范围内的类型时，可以使用上界或下界通配符。

   ```java
   public interface Box<T extends Number> {
       void addItem(T item);
       T getItem();
   }
   
   // 实现示例
   public class NumberBox<T extends Number> implements Box<T> {
       private T item;
   
       public void addItem(T item) {
           this.item = item;
       }
   
       public T getItem() {
           return item;
       }
   }
   
   public class IntegerBox implements Box<Integer> {
       private Integer item;
   
       public void addItem(Integer item) {
           this.item = item;
       }
   
       public Integer getItem() {
           return item;
       }
   }
   ```

上述场景中，使用通配符的目的是提供更大的灵活性和复用性。通配符允许我们在泛型方法和泛型接口中处理多种类型的数据，而不需要与具体类型绑定。这样可以使代码更通用、可扩展，并且适用于更广泛的场景。





## 编程接口

publisher 制片人

> 通过此接口来发布元素序列给有需求的消费者

subscriber 观影者

> 消费者（订阅者）从publisher来获取所需要的元素进行消费

subscription 电影院

> 连接生产者消费者的中间人， 解耦 生产者消费者



processor<T,R>

> 既是又是
>
> CSP思想：通过进程通信来共享内存，而不是反过来
>
> 函数式编程解决并发问题： TODO 消除了可变状态

