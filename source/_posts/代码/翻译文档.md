## Sring 响应式编程

** Common question: what if a publisher cannot slow down?** The purpose of Reactive Streams is only to establish the mechanism and a boundary. If a publisher cannot slow down, it has to decide whether to buffer, drop, or fail.

#### 1.1.2. Reactive API

Reactive Streams plays an important role for interoperability. It is of interest to libraries and infrastructure components but less useful as an application API, because it is too low-level. Applications need a higher-level and richer, functional API to compose async logic — similar to the Java 8 `Stream` API but not only for collections. This is the role that reactive libraries play.

[Reactor](https://github.com/reactor/reactor) is the reactive library of choice for Spring WebFlux. It provides the [`Mono`](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html) and [`Flux`](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html) API types to work on data sequences of 0..1 (`Mono`) and 0..N (`Flux`) through a rich set of operators aligned with the ReactiveX [vocabulary of operators](https://reactivex.io/documentation/operators.html). Reactor is a Reactive Streams library and, therefore, all of its operators support non-blocking back pressure. Reactor has a strong focus on server-side Java. It is developed in close collaboration with Spring.

WebFlux requires Reactor as a core dependency but it is interoperable with other reactive libraries via Reactive Streams. As a general rule, a WebFlux API accepts a plain `Publisher` as input, adapts it to a Reactor type internally, uses that, and returns either a `Flux` or a `Mono` as output. So, you can pass any `Publisher` as input and you can apply operations on the output, but you need to adapt the output for use with another reactive library. Whenever feasible (for example, annotated controllers), WebFlux adapts transparently to the use of RxJava or another reactive library. See [Reactive Libraries](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-reactive-libraries) for more details.

|      | In addition to Reactive APIs, WebFlux can also be used with [Coroutines](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/languages.html#coroutines) APIs in Kotlin which provides a more imperative style of programming. The following Kotlin code samples will be provided with Coroutines APIs. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

#### 1.1.3. Programming Models

The `spring-web` module contains the reactive foundation that underlies Spring WebFlux, including HTTP abstractions, Reactive Streams [adapters](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-httphandler) for supported servers, [codecs](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-codecs), and a core [`WebHandler` API](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api) comparable to the Servlet API but with non-blocking contracts.

On that foundation, Spring WebFlux provides a choice of two programming models:

- [Annotated Controllers](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-controller): Consistent with Spring MVC and based on the same annotations from the `spring-web` module. Both Spring MVC and WebFlux controllers support reactive (Reactor and RxJava) return types, and, as a result, it is not easy to tell them apart. One notable difference is that WebFlux also supports reactive `@RequestBody` arguments.
- [Functional Endpoints](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-fn): Lambda-based, lightweight, and functional programming model. You can think of this as a small library or a set of utilities that an application can use to route and handle requests. The big difference with annotated controllers is that the application is in charge of request handling from start to finish versus declaring intent through annotations and being called back.

#### 1.1.4. Applicability

Spring MVC or WebFlux?

A natural question to ask but one that sets up an unsound dichotomy. Actually, both work together to expand the range of available options. The two are designed for continuity and consistency with each other, they are available side by side, and feedback from each side benefits both sides. The following diagram shows how the two relate, what they have in common, and what each supports uniquely:

![spring mvc and webflux venn](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/images/spring-mvc-and-webflux-venn.png)

We suggest that you consider the following specific points:

- If you have a Spring MVC application that works fine, there is no need to change. Imperative programming is the easiest way to write, understand, and debug code. You have maximum choice of libraries, since, historically, most are blocking.
- If you are already shopping for a non-blocking web stack, Spring WebFlux offers the same execution model benefits as others in this space and also provides a choice of servers (Netty, Tomcat, Jetty, Undertow, and Servlet 3.1+ containers), a choice of programming models (annotated controllers and functional web endpoints), and a choice of reactive libraries (Reactor, RxJava, or other).
- If you are interested in a lightweight, functional web framework for use with Java 8 lambdas or Kotlin, you can use the Spring WebFlux functional web endpoints. That can also be a good choice for smaller applications or microservices with less complex requirements that can benefit from greater transparency and control.
- In a microservice architecture, you can have a mix of applications with either Spring MVC or Spring WebFlux controllers or with Spring WebFlux functional endpoints. Having support for the same annotation-based programming model in both frameworks makes it easier to re-use knowledge while also selecting the right tool for the right job.
- A simple way to evaluate an application is to check its dependencies. If you have blocking persistence APIs (JPA, JDBC) or networking APIs to use, Spring MVC is the best choice for common architectures at least. It is technically feasible with both Reactor and RxJava to perform blocking calls on a separate thread but you would not be making the most of a non-blocking web stack.
- If you have a Spring MVC application with calls to remote services, try the reactive `WebClient`. You can return reactive types (Reactor, RxJava, [or other](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-reactive-libraries)) directly from Spring MVC controller methods. The greater the latency per call or the interdependency among calls, the more dramatic the benefits. Spring MVC controllers can call other reactive components too.
- If you have a large team, keep in mind the steep learning curve in the shift to non-blocking, functional, and declarative programming. A practical way to start without a full switch is to use the reactive `WebClient`. Beyond that, start small and measure the benefits. We expect that, for a wide range of applications, the shift is unnecessary. If you are unsure what benefits to look for, start by learning about how non-blocking I/O works (for example, concurrency on single-threaded Node.js) and its effects.

#### 1.1.5. Servers

Spring WebFlux is supported on Tomcat, Jetty, Servlet 3.1+ containers, as well as on non-Servlet runtimes such as Netty and Undertow. All servers are adapted to a low-level, [common API](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-httphandler) so that higher-level [programming models](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-programming-models) can be supported across servers.

Spring WebFlux does not have built-in support to start or stop a server. However, it is easy to [assemble](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api) an application from Spring configuration and [WebFlux infrastructure](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-config) and [run it](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-httphandler) with a few lines of code.

Spring Boot has a WebFlux starter that automates these steps. By default, the starter uses Netty, but it is easy to switch to Tomcat, Jetty, or Undertow by changing your Maven or Gradle dependencies. Spring Boot defaults to Netty, because it is more widely used in the asynchronous, non-blocking space and lets a client and a server share resources.

Tomcat and Jetty can be used with both Spring MVC and WebFlux. Keep in mind, however, that the way they are used is very different. Spring MVC relies on Servlet blocking I/O and lets applications use the Servlet API directly if they need to. Spring WebFlux relies on Servlet 3.1 non-blocking I/O and uses the Servlet API behind a low-level adapter. It is not exposed for direct use.

For Undertow, Spring WebFlux uses Undertow APIs directly without the Servlet API.

#### 1.1.6. Performance

Performance has many characteristics and meanings. Reactive and non-blocking generally do not make applications run faster. They can, in some cases, (for example, if using the `WebClient` to run remote calls in parallel). On the whole, it requires more work to do things the non-blocking way and that can slightly increase the required processing time.

The key expected benefit of reactive and non-blocking is the ability to scale with a small, fixed number of threads and less memory. That makes applications more resilient under load, because they scale in a more predictable way. In order to observe those benefits, however, you need to have some latency (including a mix of slow and unpredictable network I/O). That is where the reactive stack begins to show its strengths, and the differences can be dramatic.

#### 1.1.7. Concurrency Model

Both Spring MVC and Spring WebFlux support annotated controllers, but there is a key difference in the concurrency model and the default assumptions for blocking and threads.

In Spring MVC (and servlet applications in general), it is assumed that applications can block the current thread, (for example, for remote calls). For this reason, servlet containers use a large thread pool to absorb potential blocking during request handling.

In Spring WebFlux (and non-blocking servers in general), it is assumed that applications do not block. Therefore, non-blocking servers use a small, fixed-size thread pool (event loop workers) to handle requests.

|      | “To scale” and “small number of threads” may sound contradictory but to never block the current thread (and rely on callbacks instead) means that you do not need extra threads, as there are no blocking calls to absorb. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Invoking a Blocking API

What if you do need to use a blocking library? Both Reactor and RxJava provide the `publishOn` operator to continue processing on a different thread. That means there is an easy escape hatch. Keep in mind, however, that blocking APIs are not a good fit for this concurrency model.

Mutable State

In Reactor and RxJava, you declare logic through operators. At runtime, a reactive pipeline is formed where data is processed sequentially, in distinct stages. A key benefit of this is that it frees applications from having to protect mutable state because application code within that pipeline is never invoked concurrently.

Threading Model

What threads should you expect to see on a server running with Spring WebFlux?

- On a “vanilla” Spring WebFlux server (for example, no data access nor other optional dependencies), you can expect one thread for the server and several others for request processing (typically as many as the number of CPU cores). Servlet containers, however, may start with more threads (for example, 10 on Tomcat), in support of both servlet (blocking) I/O and servlet 3.1 (non-blocking) I/O usage.
- The reactive `WebClient` operates in event loop style. So you can see a small, fixed number of processing threads related to that (for example, `reactor-http-nio-` with the Reactor Netty connector). However, if Reactor Netty is used for both client and server, the two share event loop resources by default.
- Reactor and RxJava provide thread pool abstractions, called schedulers, to use with the `publishOn` operator that is used to switch processing to a different thread pool. The schedulers have names that suggest a specific concurrency strategy — for example, “parallel” (for CPU-bound work with a limited number of threads) or “elastic” (for I/O-bound work with a large number of threads). If you see such threads, it means some code is using a specific thread pool `Scheduler` strategy.
- Data access libraries and other third party dependencies can also create and use threads of their own.

Configuring

The Spring Framework does not provide support for starting and stopping [servers](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-server-choice). To configure the threading model for a server, you need to use server-specific configuration APIs, or, if you use Spring Boot, check the Spring Boot configuration options for each server. You can [configure](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-client-builder) the `WebClient` directly. For all other libraries, see their respective documentation.

### 1.2. Reactive Core

The `spring-web` module contains the following foundational support for reactive web applications:

- For server request processing there are two levels of support.
  - [HttpHandler](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-httphandler): Basic contract for HTTP request handling with non-blocking I/O and Reactive Streams back pressure, along with adapters for Reactor Netty, Undertow, Tomcat, Jetty, and any Servlet 3.1+ container.
  - [`WebHandler` API](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api): Slightly higher level, general-purpose web API for request handling, on top of which concrete programming models such as annotated controllers and functional endpoints are built.
- For the client side, there is a basic `ClientHttpConnector` contract to perform HTTP requests with non-blocking I/O and Reactive Streams back pressure, along with adapters for [Reactor Netty](https://github.com/reactor/reactor-netty), reactive [Jetty HttpClient](https://github.com/jetty-project/jetty-reactive-httpclient) and [Apache HttpComponents](https://hc.apache.org/). The higher level [WebClient](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-client) used in applications builds on this basic contract.
- For client and server, [codecs](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-codecs) for serialization and deserialization of HTTP request and response content.

#### 1.2.1. `HttpHandler`

[HttpHandler](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/http/server/reactive/HttpHandler.html) is a simple contract with a single method to handle a request and a response. It is intentionally minimal, and its main and only purpose is to be a minimal abstraction over different HTTP server APIs.

The following table describes the supported server APIs:

| Server name           | Server API used                                              | Reactive Streams support                                     |
| :-------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Netty                 | Netty API                                                    | [Reactor Netty](https://github.com/reactor/reactor-netty)    |
| Undertow              | Undertow API                                                 | spring-web: Undertow to Reactive Streams bridge              |
| Tomcat                | Servlet 3.1 non-blocking I/O; Tomcat API to read and write ByteBuffers vs byte[] | spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge |
| Jetty                 | Servlet 3.1 non-blocking I/O; Jetty API to write ByteBuffers vs byte[] | spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge |
| Servlet 3.1 container | Servlet 3.1 non-blocking I/O                                 | spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge |

The following table describes server dependencies (also see [supported versions](https://github.com/spring-projects/spring-framework/wiki/What's-New-in-the-Spring-Framework)):

| Server name   | Group id                | Artifact name               |
| :------------ | :---------------------- | :-------------------------- |
| Reactor Netty | io.projectreactor.netty | reactor-netty               |
| Undertow      | io.undertow             | undertow-core               |
| Tomcat        | org.apache.tomcat.embed | tomcat-embed-core           |
| Jetty         | org.eclipse.jetty       | jetty-server, jetty-servlet |

The code snippets below show using the `HttpHandler` adapters with each server API:

**Reactor Netty**

Java

Kotlin

```java
HttpHandler handler = ...
ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
HttpServer.create().host(host).port(port).handle(adapter).bind().block();
```

**Undertow**

Java

Kotlin

```java
HttpHandler handler = ...
UndertowHttpHandlerAdapter adapter = new UndertowHttpHandlerAdapter(handler);
Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();
server.start();
```

**Tomcat**

Java

Kotlin

```java
HttpHandler handler = ...
Servlet servlet = new TomcatHttpHandlerAdapter(handler);

Tomcat server = new Tomcat();
File base = new File(System.getProperty("java.io.tmpdir"));
Context rootContext = server.addContext("", base.getAbsolutePath());
Tomcat.addServlet(rootContext, "main", servlet);
rootContext.addServletMappingDecoded("/", "main");
server.setHost(host);
server.setPort(port);
server.start();
```

**Jetty**

Java

Kotlin

```java
HttpHandler handler = ...
Servlet servlet = new JettyHttpHandlerAdapter(handler);

Server server = new Server();
ServletContextHandler contextHandler = new ServletContextHandler(server, "");
contextHandler.addServlet(new ServletHolder(servlet), "/");
contextHandler.start();

ServerConnector connector = new ServerConnector(server);
connector.setHost(host);
connector.setPort(port);
server.addConnector(connector);
server.start();
```

**Servlet 3.1+ Container**

To deploy as a WAR to any Servlet 3.1+ container, you can extend and include [`AbstractReactiveWebInitializer`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html) in the WAR. That class wraps an `HttpHandler` with `ServletHttpHandlerAdapter` and registers that as a `Servlet`.

#### 1.2.2. `WebHandler` API

The `org.springframework.web.server` package builds on the [`HttpHandler`](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-httphandler) contract to provide a general-purpose web API for processing requests through a chain of multiple [`WebExceptionHandler`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/web/server/WebExceptionHandler.html), multiple [`WebFilter`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/web/server/WebFilter.html), and a single [`WebHandler`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/web/server/WebHandler.html) component. The chain can be put together with `WebHttpHandlerBuilder` by simply pointing to a Spring `ApplicationContext` where components are [auto-detected](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api-special-beans), and/or by registering components with the builder.

While `HttpHandler` has a simple goal to abstract the use of different HTTP servers, the `WebHandler` API aims to provide a broader set of features commonly used in web applications such as:

- User session with attributes.
- Request attributes.
- Resolved `Locale` or `Principal` for the request.
- Access to parsed and cached form data.
- Abstractions for multipart data.
- and more..

##### Special bean types

The table below lists the components that `WebHttpHandlerBuilder` can auto-detect in a Spring ApplicationContext, or that can be registered directly with it:

| Bean name                    | Bean type                    | Count | Description                                                  |
| :--------------------------- | :--------------------------- | :---- | :----------------------------------------------------------- |
| <any>                        | `WebExceptionHandler`        | 0..N  | Provide handling for exceptions from the chain of `WebFilter` instances and the target `WebHandler`. For more details, see [Exceptions](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-exception-handler). |
| <any>                        | `WebFilter`                  | 0..N  | Apply interception style logic to before and after the rest of the filter chain and the target `WebHandler`. For more details, see [Filters](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-filters). |
| `webHandler`                 | `WebHandler`                 | 1     | The handler for the request.                                 |
| `webSessionManager`          | `WebSessionManager`          | 0..1  | The manager for `WebSession` instances exposed through a method on `ServerWebExchange`. `DefaultWebSessionManager` by default. |
| `serverCodecConfigurer`      | `ServerCodecConfigurer`      | 0..1  | For access to `HttpMessageReader` instances for parsing form data and multipart data that is then exposed through methods on `ServerWebExchange`. `ServerCodecConfigurer.create()` by default. |
| `localeContextResolver`      | `LocaleContextResolver`      | 0..1  | The resolver for `LocaleContext` exposed through a method on `ServerWebExchange`. `AcceptHeaderLocaleContextResolver` by default. |
| `forwardedHeaderTransformer` | `ForwardedHeaderTransformer` | 0..1  | For processing forwarded type headers, either by extracting and removing them or by removing them only. Not used by default. |

##### Form Data

`ServerWebExchange` exposes the following method for accessing form data:

Java

Kotlin

```java
Mono<MultiValueMap<String, String>> getFormData();
```

The `DefaultServerWebExchange` uses the configured `HttpMessageReader` to parse form data (`application/x-www-form-urlencoded`) into a `MultiValueMap`. By default, `FormHttpMessageReader` is configured for use by the `ServerCodecConfigurer` bean (see the [Web Handler API](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api)).

##### Multipart Data

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-multipart)

`ServerWebExchange` exposes the following method for accessing multipart data:

Java

Kotlin

```java
Mono<MultiValueMap<String, Part>> getMultipartData();
```

The `DefaultServerWebExchange` uses the configured `HttpMessageReader<MultiValueMap<String, Part>>` to parse `multipart/form-data` content into a `MultiValueMap`. By default, this is the `DefaultPartHttpMessageReader`, which does not have any third-party dependencies. Alternatively, the `SynchronossPartHttpMessageReader` can be used, which is based on the [Synchronoss NIO Multipart](https://github.com/synchronoss/nio-multipart) library. Both are configured through the `ServerCodecConfigurer` bean (see the [Web Handler API](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api)).

To parse multipart data in streaming fashion, you can use the `Flux<Part>` returned from an `HttpMessageReader<Part>` instead. For example, in an annotated controller, use of `@RequestPart` implies `Map`-like access to individual parts by name and, hence, requires parsing multipart data in full. By contrast, you can use `@RequestBody` to decode the content to `Flux<Part>` without collecting to a `MultiValueMap`.

##### Forwarded Headers

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#filters-forwarded-headers)

As a request goes through proxies (such as load balancers), the host, port, and scheme may change. That makes it a challenge, from a client perspective, to create links that point to the correct host, port, and scheme.

[RFC 7239](https://tools.ietf.org/html/rfc7239) defines the `Forwarded` HTTP header that proxies can use to provide information about the original request. There are other non-standard headers, too, including `X-Forwarded-Host`, `X-Forwarded-Port`, `X-Forwarded-Proto`, `X-Forwarded-Ssl`, and `X-Forwarded-Prefix`.

`ForwardedHeaderTransformer` is a component that modifies the host, port, and scheme of the request, based on forwarded headers, and then removes those headers. If you declare it as a bean with the name `forwardedHeaderTransformer`, it will be [detected](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api-special-beans) and used.

There are security considerations for forwarded headers, since an application cannot know if the headers were added by a proxy, as intended, or by a malicious client. This is why a proxy at the boundary of trust should be configured to remove untrusted forwarded traffic coming from the outside. You can also configure the `ForwardedHeaderTransformer` with `removeOnly=true`, in which case it removes but does not use the headers.

|      | In 5.1 `ForwardedHeaderFilter` was deprecated and superseded by `ForwardedHeaderTransformer` so forwarded headers can be processed earlier, before the exchange is created. If the filter is configured anyway, it is taken out of the list of filters, and `ForwardedHeaderTransformer` is used instead. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

#### 1.2.3. Filters

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#filters)

In the [`WebHandler` API](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api), you can use a `WebFilter` to apply interception-style logic before and after the rest of the processing chain of filters and the target `WebHandler`. When using the [WebFlux Config](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-config), registering a `WebFilter` is as simple as declaring it as a Spring bean and (optionally) expressing precedence by using `@Order` on the bean declaration or by implementing `Ordered`.

##### CORS

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#filters-cors)

Spring WebFlux provides fine-grained support for CORS configuration through annotations on controllers. However, when you use it with Spring Security, we advise relying on the built-in `CorsFilter`, which must be ordered ahead of Spring Security’s chain of filters.

See the section on [CORS](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-cors) and the [CORS `WebFilter`](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-cors-webfilter) for more details.

#### 1.2.4. Exceptions

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-ann-customer-servlet-container-error-page)

In the [`WebHandler` API](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api), you can use a `WebExceptionHandler` to handle exceptions from the chain of `WebFilter` instances and the target `WebHandler`. When using the [WebFlux Config](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-config), registering a `WebExceptionHandler` is as simple as declaring it as a Spring bean and (optionally) expressing precedence by using `@Order` on the bean declaration or by implementing `Ordered`.

The following table describes the available `WebExceptionHandler` implementations:

| Exception Handler                       | Description                                                  |
| :-------------------------------------- | :----------------------------------------------------------- |
| `ResponseStatusExceptionHandler`        | Provides handling for exceptions of type [`ResponseStatusException`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/web/server/ResponseStatusException.html) by setting the response to the HTTP status code of the exception. |
| `WebFluxResponseStatusExceptionHandler` | Extension of `ResponseStatusExceptionHandler` that can also determine the HTTP status code of a `@ResponseStatus` annotation on any exception.This handler is declared in the [WebFlux Config](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-config). |

#### 1.2.5. Codecs

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/integration.html#rest-message-conversion)

The `spring-web` and `spring-core` modules provide support for serializing and deserializing byte content to and from higher level objects through non-blocking I/O with Reactive Streams back pressure. The following describes this support:

- [`Encoder`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/core/codec/Encoder.html) and [`Decoder`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/core/codec/Decoder.html) are low level contracts to encode and decode content independent of HTTP.
- [`HttpMessageReader`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/http/codec/HttpMessageReader.html) and [`HttpMessageWriter`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/http/codec/HttpMessageWriter.html) are contracts to encode and decode HTTP message content.
- An `Encoder` can be wrapped with `EncoderHttpMessageWriter` to adapt it for use in a web application, while a `Decoder` can be wrapped with `DecoderHttpMessageReader`.
- [`DataBuffer`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/core/io/buffer/DataBuffer.html) abstracts different byte buffer representations (e.g. Netty `ByteBuf`, `java.nio.ByteBuffer`, etc.) and is what all codecs work on. See [Data Buffers and Codecs](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/core.html#databuffers) in the "Spring Core" section for more on this topic.

The `spring-core` module provides `byte[]`, `ByteBuffer`, `DataBuffer`, `Resource`, and `String` encoder and decoder implementations. The `spring-web` module provides Jackson JSON, Jackson Smile, JAXB2, Protocol Buffers and other encoders and decoders along with web-only HTTP message reader and writer implementations for form data, multipart content, server-sent events, and others.

`ClientCodecConfigurer` and `ServerCodecConfigurer` are typically used to configure and customize the codecs to use in an application. See the section on configuring [HTTP message codecs](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-config-message-codecs).

##### Jackson JSON

JSON and binary JSON ([Smile](https://github.com/FasterXML/smile-format-specification)) are both supported when the Jackson library is present.

The `Jackson2Decoder` works as follows:

- Jackson’s asynchronous, non-blocking parser is used to aggregate a stream of byte chunks into `TokenBuffer`'s each representing a JSON object.
- Each `TokenBuffer` is passed to Jackson’s `ObjectMapper` to create a higher level object.
- When decoding to a single-value publisher (e.g. `Mono`), there is one `TokenBuffer`.
- When decoding to a multi-value publisher (e.g. `Flux`), each `TokenBuffer` is passed to the `ObjectMapper` as soon as enough bytes are received for a fully formed object. The input content can be a JSON array, or any [line-delimited JSON](https://en.wikipedia.org/wiki/JSON_streaming) format such as NDJSON, JSON Lines, or JSON Text Sequences.

The `Jackson2Encoder` works as follows:

- For a single value publisher (e.g. `Mono`), simply serialize it through the `ObjectMapper`.
- For a multi-value publisher with `application/json`, by default collect the values with `Flux#collectToList()` and then serialize the resulting collection.
- For a multi-value publisher with a streaming media type such as `application/x-ndjson` or `application/stream+x-jackson-smile`, encode, write, and flush each value individually using a [line-delimited JSON](https://en.wikipedia.org/wiki/JSON_streaming) format. Other streaming media types may be registered with the encoder.
- For SSE the `Jackson2Encoder` is invoked per event and the output is flushed to ensure delivery without delay.

|      | By default both `Jackson2Encoder` and `Jackson2Decoder` do not support elements of type `String`. Instead the default assumption is that a string or a sequence of strings represent serialized JSON content, to be rendered by the `CharSequenceEncoder`. If what you need is to render a JSON array from `Flux<String>`, use `Flux#collectToList()` and encode a `Mono<List<String>>`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Form Data

`FormHttpMessageReader` and `FormHttpMessageWriter` support decoding and encoding `application/x-www-form-urlencoded` content.

On the server side where form content often needs to be accessed from multiple places, `ServerWebExchange` provides a dedicated `getFormData()` method that parses the content through `FormHttpMessageReader` and then caches the result for repeated access. See [Form Data](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-form-data) in the [`WebHandler` API](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api) section.

Once `getFormData()` is used, the original raw content can no longer be read from the request body. For this reason, applications are expected to go through `ServerWebExchange` consistently for access to the cached form data versus reading from the raw request body.

##### Multipart

`MultipartHttpMessageReader` and `MultipartHttpMessageWriter` support decoding and encoding "multipart/form-data" content. In turn `MultipartHttpMessageReader` delegates to another `HttpMessageReader` for the actual parsing to a `Flux<Part>` and then simply collects the parts into a `MultiValueMap`. By default, the `DefaultPartHttpMessageReader` is used, but this can be changed through the `ServerCodecConfigurer`. For more information about the `DefaultPartHttpMessageReader`, refer to to the [javadoc of `DefaultPartHttpMessageReader`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/http/codec/multipart/DefaultPartHttpMessageReader.html).

On the server side where multipart form content may need to be accessed from multiple places, `ServerWebExchange` provides a dedicated `getMultipartData()` method that parses the content through `MultipartHttpMessageReader` and then caches the result for repeated access. See [Multipart Data](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-multipart) in the [`WebHandler` API](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api) section.

Once `getMultipartData()` is used, the original raw content can no longer be read from the request body. For this reason applications have to consistently use `getMultipartData()` for repeated, map-like access to parts, or otherwise rely on the `SynchronossPartHttpMessageReader` for a one-time access to `Flux<Part>`.

##### Limits

`Decoder` and `HttpMessageReader` implementations that buffer some or all of the input stream can be configured with a limit on the maximum number of bytes to buffer in memory. In some cases buffering occurs because input is aggregated and represented as a single object — for example, a controller method with `@RequestBody byte[]`, `x-www-form-urlencoded` data, and so on. Buffering can also occur with streaming, when splitting the input stream — for example, delimited text, a stream of JSON objects, and so on. For those streaming cases, the limit applies to the number of bytes associated with one object in the stream.

To configure buffer sizes, you can check if a given `Decoder` or `HttpMessageReader` exposes a `maxInMemorySize` property and if so the Javadoc will have details about default values. On the server side, `ServerCodecConfigurer` provides a single place from where to set all codecs, see [HTTP message codecs](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-config-message-codecs). On the client side, the limit for all codecs can be changed in [WebClient.Builder](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-client-builder-maxinmemorysize).

For [Multipart parsing](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-codecs-multipart) the `maxInMemorySize` property limits the size of non-file parts. For file parts, it determines the threshold at which the part is written to disk. For file parts written to disk, there is an additional `maxDiskUsagePerPart` property to limit the amount of disk space per part. There is also a `maxParts` property to limit the overall number of parts in a multipart request. To configure all three in WebFlux, you’ll need to supply a pre-configured instance of `MultipartHttpMessageReader` to `ServerCodecConfigurer`.

##### Streaming

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-ann-async-http-streaming)

When streaming to the HTTP response (for example, `text/event-stream`, `application/x-ndjson`), it is important to send data periodically, in order to reliably detect a disconnected client sooner rather than later. Such a send could be a comment-only, empty SSE event or any other "no-op" data that would effectively serve as a heartbeat.

##### `DataBuffer`

`DataBuffer` is the representation for a byte buffer in WebFlux. The Spring Core part of this reference has more on that in the section on [Data Buffers and Codecs](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/core.html#databuffers). The key point to understand is that on some servers like Netty, byte buffers are pooled and reference counted, and must be released when consumed to avoid memory leaks.

WebFlux applications generally do not need to be concerned with such issues, unless they consume or produce data buffers directly, as opposed to relying on codecs to convert to and from higher level objects, or unless they choose to create custom codecs. For such cases please review the information in [Data Buffers and Codecs](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/core.html#databuffers), especially the section on [Using DataBuffer](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/core.html#databuffers-using).

#### 1.2.6. Logging

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-logging)

`DEBUG` level logging in Spring WebFlux is designed to be compact, minimal, and human-friendly. It focuses on high value bits of information that are useful over and over again vs others that are useful only when debugging a specific issue.

`TRACE` level logging generally follows the same principles as `DEBUG` (and for example also should not be a firehose) but can be used for debugging any issue. In addition, some log messages may show a different level of detail at `TRACE` vs `DEBUG`.

Good logging comes from the experience of using the logs. If you spot anything that does not meet the stated goals, please let us know.

##### Log Id

In WebFlux, a single request can be run over multiple threads and the thread ID is not useful for correlating log messages that belong to a specific request. This is why WebFlux log messages are prefixed with a request-specific ID by default.

On the server side, the log ID is stored in the `ServerWebExchange` attribute ([`LOG_ID_ATTRIBUTE`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE)), while a fully formatted prefix based on that ID is available from `ServerWebExchange#getLogPrefix()`. On the `WebClient` side, the log ID is stored in the `ClientRequest` attribute ([`LOG_ID_ATTRIBUTE`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE)) ,while a fully formatted prefix is available from `ClientRequest#logPrefix()`.

##### Sensitive Data

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-logging-sensitive-data)

`DEBUG` and `TRACE` logging can log sensitive information. This is why form parameters and headers are masked by default and you must explicitly enable their logging in full.

The following example shows how to do so for server-side requests:

Java

Kotlin

```java
@Configuration
@EnableWebFlux
class MyConfig implements WebFluxConfigurer {

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().enableLoggingRequestDetails(true);
    }
}
```

The following example shows how to do so for client-side requests:

Java

Kotlin

```java
Consumer<ClientCodecConfigurer> consumer = configurer ->
        configurer.defaultCodecs().enableLoggingRequestDetails(true);

WebClient webClient = WebClient.builder()
        .exchangeStrategies(strategies -> strategies.codecs(consumer))
        .build();
```

##### Appenders

Logging libraries such as SLF4J and Log4J 2 provide asynchronous loggers that avoid blocking. While those have their own drawbacks such as potentially dropping messages that could not be queued for logging, they are the best available options currently for use in a reactive, non-blocking application.

##### Custom codecs

Applications can register custom codecs for supporting additional media types, or specific behaviors that are not supported by the default codecs.

Some configuration options expressed by developers are enforced on default codecs. Custom codecs might want to get a chance to align with those preferences, like [enforcing buffering limits](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-codecs-limits) or [logging sensitive data](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-logging-sensitive-data).

The following example shows how to do so for client-side requests:

Java

Kotlin

```java
WebClient webClient = WebClient.builder()
        .codecs(configurer -> {
                CustomDecoder decoder = new CustomDecoder();
                configurer.customCodecs().registerWithDefaultConfig(decoder);
        })
        .build();
```

### 1.3. `DispatcherHandler`

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-servlet)

Spring WebFlux, similarly to Spring MVC, is designed around the front controller pattern, where a central `WebHandler`, the `DispatcherHandler`, provides a shared algorithm for request processing, while actual work is performed by configurable, delegate components. This model is flexible and supports diverse workflows.

`DispatcherHandler` discovers the delegate components it needs from Spring configuration. It is also designed to be a Spring bean itself and implements `ApplicationContextAware` for access to the context in which it runs. If `DispatcherHandler` is declared with a bean name of `webHandler`, it is, in turn, discovered by [`WebHttpHandlerBuilder`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/web/server/adapter/WebHttpHandlerBuilder.html), which puts together a request-processing chain, as described in [`WebHandler` API](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api).

Spring configuration in a WebFlux application typically contains:

- `DispatcherHandler` with the bean name `webHandler`
- `WebFilter` and `WebExceptionHandler` beans
- [`DispatcherHandler` special beans](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-special-bean-types)
- Others

The configuration is given to `WebHttpHandlerBuilder` to build the processing chain, as the following example shows:

Java

Kotlin

```java
ApplicationContext context = ...
HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context).build();
```

The resulting `HttpHandler` is ready for use with a [server adapter](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-httphandler).

#### 1.3.1. Special Bean Types

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-servlet-special-bean-types)

The `DispatcherHandler` delegates to special beans to process requests and render the appropriate responses. By “special beans,” we mean Spring-managed `Object` instances that implement WebFlux framework contracts. Those usually come with built-in contracts, but you can customize their properties, extend them, or replace them.

The following table lists the special beans detected by the `DispatcherHandler`. Note that there are also some other beans detected at a lower level (see [Special bean types](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api-special-beans) in the Web Handler API).

| Bean type              | Explanation                                                  |
| :--------------------- | :----------------------------------------------------------- |
| `HandlerMapping`       | Map a request to a handler. The mapping is based on some criteria, the details of which vary by `HandlerMapping` implementation — annotated controllers, simple URL pattern mappings, and others.The main `HandlerMapping` implementations are `RequestMappingHandlerMapping` for `@RequestMapping` annotated methods, `RouterFunctionMapping` for functional endpoint routes, and `SimpleUrlHandlerMapping` for explicit registrations of URI path patterns and `WebHandler` instances. |
| `HandlerAdapter`       | Help the `DispatcherHandler` to invoke a handler mapped to a request regardless of how the handler is actually invoked. For example, invoking an annotated controller requires resolving annotations. The main purpose of a `HandlerAdapter` is to shield the `DispatcherHandler` from such details. |
| `HandlerResultHandler` | Process the result from the handler invocation and finalize the response. See [Result Handling](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-resulthandling). |

#### 1.3.2. WebFlux Config

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-servlet-config)

Applications can declare the infrastructure beans (listed under [Web Handler API](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-web-handler-api-special-beans) and [`DispatcherHandler`](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-special-bean-types)) that are required to process requests. However, in most cases, the [WebFlux Config](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-config) is the best starting point. It declares the required beans and provides a higher-level configuration callback API to customize it.

|      | Spring Boot relies on the WebFlux config to configure Spring WebFlux and also provides many extra convenient options. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

#### 1.3.3. Processing

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-servlet-sequence)

`DispatcherHandler` processes requests as follows:

- Each `HandlerMapping` is asked to find a matching handler, and the first match is used.
- If a handler is found, it is run through an appropriate `HandlerAdapter`, which exposes the return value from the execution as `HandlerResult`.
- The `HandlerResult` is given to an appropriate `HandlerResultHandler` to complete processing by writing to the response directly or by using a view to render.

#### 1.3.4. Result Handling

The return value from the invocation of a handler, through a `HandlerAdapter`, is wrapped as a `HandlerResult`, along with some additional context, and passed to the first `HandlerResultHandler` that claims support for it. The following table shows the available `HandlerResultHandler` implementations, all of which are declared in the [WebFlux Config](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-config):

| Result Handler Type           | Return Values                                                | Default Order       |
| :---------------------------- | :----------------------------------------------------------- | :------------------ |
| `ResponseEntityResultHandler` | `ResponseEntity`, typically from `@Controller` instances.    | 0                   |
| `ServerResponseResultHandler` | `ServerResponse`, typically from functional endpoints.       | 0                   |
| `ResponseBodyResultHandler`   | Handle return values from `@ResponseBody` methods or `@RestController` classes. | 100                 |
| `ViewResolutionResultHandler` | `CharSequence`, [`View`](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/web/reactive/result/view/View.html), [Model](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/ui/Model.html), `Map`, [Rendering](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html), or any other `Object` is treated as a model attribute.See also [View Resolution](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-viewresolution). | `Integer.MAX_VALUE` |

#### 1.3.5. Exceptions

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-exceptionhandlers)

The `HandlerResult` returned from a `HandlerAdapter` can expose a function for error handling based on some handler-specific mechanism. This error function is called if:

- The handler (for example, `@Controller`) invocation fails.
- The handling of the handler return value through a `HandlerResultHandler` fails.

The error function can change the response (for example, to an error status), as long as an error signal occurs before the reactive type returned from the handler produces any data items.

This is how `@ExceptionHandler` methods in `@Controller` classes are supported. By contrast, support for the same in Spring MVC is built on a `HandlerExceptionResolver`. This generally should not matter. However, keep in mind that, in WebFlux, you cannot use a `@ControllerAdvice` to handle exceptions that occur before a handler is chosen.

See also [Managing Exceptions](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-ann-controller-exceptions) in the “Annotated Controller” section or [Exceptions](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-exception-handler) in the WebHandler API section.

#### 1.3.6. View Resolution

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-viewresolver)

View resolution enables rendering to a browser with an HTML template and a model without tying you to a specific view technology. In Spring WebFlux, view resolution is supported through a dedicated [HandlerResultHandler](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-resulthandling) that uses `ViewResolver` instances to map a String (representing a logical view name) to a `View` instance. The `View` is then used to render the response.

##### Handling

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-handling)

The `HandlerResult` passed into `ViewResolutionResultHandler` contains the return value from the handler and the model that contains attributes added during request handling. The return value is processed as one of the following:

- `String`, `CharSequence`: A logical view name to be resolved to a `View` through the list of configured `ViewResolver` implementations.
- `void`: Select a default view name based on the request path, minus the leading and trailing slash, and resolve it to a `View`. The same also happens when a view name was not provided (for example, model attribute was returned) or an async return value (for example, `Mono` completed empty).
- [Rendering](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html): API for view resolution scenarios. Explore the options in your IDE with code completion.
- `Model`, `Map`: Extra model attributes to be added to the model for the request.
- Any other: Any other return value (except for simple types, as determined by [BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-)) is treated as a model attribute to be added to the model. The attribute name is derived from the class name by using [conventions](https://docs.spring.io/spring-framework/docs/5.3.30/javadoc-api/org/springframework/core/Conventions.html), unless a handler method `@ModelAttribute` annotation is present.

The model can contain asynchronous, reactive types (for example, from Reactor or RxJava). Prior to rendering, `AbstractView` resolves such model attributes into concrete values and updates the model. Single-value reactive types are resolved to a single value or no value (if empty), while multi-value reactive types (for example, `Flux<T>`) are collected and resolved to `List<T>`.

To configure view resolution is as simple as adding a `ViewResolutionResultHandler` bean to your Spring configuration. [WebFlux Config](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-config-view-resolvers) provides a dedicated configuration API for view resolution.

See [View Technologies](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-view) for more on the view technologies integrated with Spring WebFlux.

##### Redirecting

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-redirecting-redirect-prefix)

The special `redirect:` prefix in a view name lets you perform a redirect. The `UrlBasedViewResolver` (and sub-classes) recognize this as an instruction that a redirect is needed. The rest of the view name is the redirect URL.

The net effect is the same as if the controller had returned a `RedirectView` or `Rendering.redirectTo("abc").build()`, but now the controller itself can operate in terms of logical view names. A view name such as `redirect:/some/resource` is relative to the current application, while a view name such as `redirect:https://example.com/arbitrary/path` redirects to an absolute URL.

##### Content Negotiation

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-multiple-representations)

`ViewResolutionResultHandler` supports content negotiation. It compares the request media types with the media types supported by each selected `View`. The first `View` that supports the requested media type(s) is used.

In order to support media types such as JSON and XML, Spring WebFlux provides `HttpMessageWriterView`, which is a special `View` that renders through an [HttpMessageWriter](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-codecs). Typically, you would configure these as default views through the [WebFlux Configuration](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web-reactive.html#webflux-config-view-resolvers). Default views are always selected and used if they match the requested media type.

### 1.4. Annotated Controllers

[Web MVC](https://docs.spring.io/spring-framework/docs/5.3.30/reference/html/web.html#mvc-controller)

Spring WebFlux provides an annotation-based programming model, where `@Controller` and `@RestController` components use annotations to express request mappings, request input, handle exceptions, and more. Annotated controllers have flexible method signatures and do not have to extend base classes nor implement specific interfaces.

The following listing shows a basic example:

Java

Kotlin

```java
@RestController
public class HelloController {

    @GetMapping("/hello")
    public String handle() {
        return "Hello WebFlux";
    }
}
```

In the preceding example, the method returns a `String` to be written to the response body.



We touched on “non-blocking” and “functional” but what does reactive mean?
The term, “reactive,” refers to programming models that are built around reacting to change — network components reacting to I/O events, UI controllers reacting to mouse events, and others. In that sense, non-blocking is reactive, because, instead of being blocked, we are now in the mode of reacting to notifications as operations complete or data becomes available.
There is also another important mechanism that we on the Spring team associate with “reactive” and that is non-blocking back pressure. In synchronous, imperative code, blocking calls serve as a natural form of back pressure that forces the caller to wait. In non-blocking code, it becomes important to control the rate of events so that a fast producer does not overwhelm its destination.
Reactive Streams is a small spec (also adopted in Java 9) that defines the interaction between asynchronous components with back pressure. For example a data repository (acting as Publisher) can produce data that an HTTP server (acting as Subscriber) can then write to the response. The main purpose of Reactive Streams is to let the subscriber control how quickly or how slowly the publisher produces data.翻译一下

> 我们已经讨论了“非阻塞”和“函数式”，那么“反应式”又意味着什么呢？
> “反应式”这个词指的是围绕着对变化做出反应进行构建的编程模型——网络组件对 I/O 事件做出反应，UI 控制器对鼠标事件做出反应，等等。从这个意义上说，非阻塞是反应式的，因为我们现在处于对操作完成或数据可用的通知做出反应的模式，而不是被阻塞。
> 我们 Spring 团队还把另一个重要的机制与“反应式”联系在一起，那就是非阻塞的背压。在同步、命令式代码中，阻塞调用作为自然的背压形式，迫使调用者等待。在非阻塞代码中，控制事件速率变得很重要，这样快速的生产者就不会压倒其目标。
> 反应式流是一个小规范（也在 Java 9 中采用），它定义了带有背压的异步组件之间的交互。例如，一个数据存储库（作为发布者）可以产生数据，HTTP 服务器（作为订阅者）然后将其写入响应。反应式流的主要目的是让订阅者控制发布者产生数据的速度或慢度。

spring-webflux depends on reactor-core and uses it internally to compose asynchronous logic and to provide Reactive Streams support. Generally, WebFlux APIs return Flux or Mono (since those are used internally) and leniently accept any Reactive Streams Publisher implementation as input. The use of Flux versus Mono is important, because it helps to express cardinality — for example, whether a single or multiple asynchronous values are expected, and that can be essential for making decisions (for example, when encoding or decoding HTTP messages).
For annotated controllers, WebFlux transparently adapts to the reactive library chosen by the application. This is done with the help of the ReactiveAdapterRegistry which provides pluggable support for reactive library and other asynchronous types. The registry has built-in support for RxJava 3, Kotlin coroutines and SmallRye Mutiny, but you can register other third-party adapters as well.

>   Spring WebFlux 依赖于 Reactor-Core 并在内部使用它来组合异步逻辑和提供反应式流支持。通常，WebFlux API 返回 Flux 或 Mono（因为它们是内部使用的），并且宽容地接受任何反应式流发布商实现作为输入。Flux 和 Mono 的使用很重要，因为它有助于表达基数——例如，预期单个或多个异步值，这对于做出决策（例如，在编码或解码 HTTP 消息时）可能是至关重要的。
> 对于注解控制器，WebFlux 透明地适应应用程序选择的反应式库。这是通过 ReactiveAdapterRegistry 来实现的，它为反应式库和其他异步类型提供可插拔的支持。该注册表内置了对 RxJava 3、Kotlin 协程和小瑞 Mutiny 的支持，但你也可以注册其他第三方适配器。

For functional APIs (such as Functional Endpoints, the WebClient, and others), the general rules for WebFlux APIs apply — Flux and Mono as return values and a Reactive Streams Publisher as input. When a Publisher, whether custom or from another reactive library, is provided, it can be treated only as a stream with unknown semantics (0..N). If, however, the semantics are known, you can wrap it with Flux or Mono.from(Publisher) instead of passing the raw Publisher.

For example, given a Publisher that is not a Mono, the Jackson JSON message writer expects multiple values. If the media type implies an infinite stream (for example, application/json+stream), values are written and flushed individually. Otherwise, values are buffered into a list and rendered as a JSON array

> 对于功能性 API（如 Functional Endpoints、WebClient 等），WebFlux API 的一般规则适用——返回 Flux 和 Mono，输入为反应式流发布商。当提供一个发布商（无论是自定义的还是来自其他反应式库）时，它可以被视为具有未知语义的流（0..N）。然而，如果知道语义，你可以使用 Flux 或 Mono.from(Publisher) 而不是传递原始的 Publisher。
>
> 例如，对于一个不是 Mono 的发布商，Jackson JSON 消息编写器期望接收多个值。如果媒体类型暗示是无限流（例如，application/json+stream），则单独写入和刷新值。否则，值会被缓存到一个列表中并作为 JSON 数组呈现。