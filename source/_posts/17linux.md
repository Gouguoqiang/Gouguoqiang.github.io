---
title: Linux
tags:
  - Linux
categories:
  - 实操
keywords: 
description: linux总结(todo)。
date: 2022-9-01 11:51:56
---

## 内核参数调整

**作为Java开发者，必可避免的需要开发或使用一些中间件，对于Java开发的中间件，除了JVM参数必须调整外， 的一些内核参数也必须要调整，这里几个，仅供参考。 **

无非都是跟磁盘文件IO、网络通信、内存管理、线程数量有关系的，因为我们的中间件系统在运行的时候无非就是跟这些打交道。

![介绍几个Java大型中间件系统中须调整的Linux内核参数介绍几个Java大型中间件系统中须调整的Linux内核参数]

这个参数有三个值可以选择，0、1、2。

如果值是0的话，在你的中间件系统申请内存的时候，操作系统内核会检查可用内存是否足够，如果足够的话就分配内存给你，如果感觉剩余内存不是太够了，干脆就拒绝你的申请，导致你申请内存失败，进而导致中间件系统异常出错。因此一般需要将这个参数的值调整为1，意思是把所有可用的物理内存都允许分配给你，只要有内存就给你来用，这样可以避免申请内存失败的问题。

比如我们曾经线上环境部署的Redis就因为这个参数是0，导致在save数据快照到磁盘文件的时候，需要申请大内存的时候被拒绝了，进而导致了异常报错。

可以用如下 修改：

```
echo 'vm.overcommit_memory=1' >> /etc/sysctl.conf
```

**vm.max_map_count**

限制一个进程可以拥有的VMA(虚拟内存区域)的数量

这个参数的值会影响中间件系统可以开启的线程的数量，同样也是非常重要的。

如果这个参数过小，有的时候可能会导致有些中间件无法开启足够的线程，进而导致报错，甚至中间件系统挂掉。

他的默认值是65536，但是这个值有时候是不够的，比如我们大数据团队的生产环境部署的Kafka集群曾经有一次就报出过这个异常，说无法开启足够多的线程，直接导致Kafka宕机了。

可以用如下 修改：

```
echo 'vm.max_map_count=655360' >> /etc/sysctl.conf
```

**vm.swappiness**

这个参数是用来控制进程的swap行为的，这个简单来说就是操作系统会把一部分磁盘空间作为swap区域，然后如果有的进程现在可能不是太活跃，就会被操作系统把进程调整为睡眠状态，把进程中的数据放入磁盘上的swap区域，然后让这个进程把原来占用的内存空间腾出来，交给其他活跃运行的进程来使用。

如果这个参数的值设置为0，意思就是尽量别把任何一个进程放到磁盘swap区域去，尽量大家都用物理内存。

如果这个参数的值是100，那么意思就是尽量把一些进程给放到磁盘swap区域去，内存腾出来给活跃的进程使用。

默认这个参数的值是60，有点偏高了，可能会导致我们的中间件运行不活跃的时候被迫腾出内存空间然后放磁盘swap区域去。因此通常在生产环境建议把这个参数调整小一些，比如设置为10，尽量用物理内存，别放磁盘swap区域去。

可以用如下命令修改：

```
echo 'vm.swappiness=10' >> /etc/sysctl.conf
```

**ulimit**

这个是用来控制linux上的最大文件连接数的，默认值可能是1024，一般肯定是不够的，因为你在大量频繁的读写磁盘文件的时候，或者是进行网络通信的时候，都会跟这个参数有关系

对于一个中间件系统而言肯定是不能使用默认值得，如果你采用默认值，很可能在线上会出现如下错误：

```
error: too many open files
```

因此通常建议用如下命令修改这个值：

```
echo 'ulimit -n 1000000' >> /etc/profile
```

**一点小小的总结**

中间件系统肯定要开启大量的线程（跟vm.max_map_count有关）。

而且要进行大量的网络通信和磁盘IO（跟ulimit有关）。

然后大量的使用内存（跟vm.swappiness和vm.overcommit_memory有关）。

所以对OS内核参数的调整，往往也就是围绕跟中间件系统运行最相关的一些东西。

## linux如何管理内存

采用段页式管理	

Linux 操作系统是采用段页式内存管理方式：

页式存储管理能有效地提高内存利用率（解决内存碎片），而分段存储管理能反映程序的逻辑结构并有利于段的共享。将这两种存储管理方法结合起来，就形成了段页式存储管理方式。

段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，为了实现从逻辑地址到物理地址的转换，系统中需要同时配置段表和页表，利用段表和页表进行从用户地址空间到物理内存空间的映射。

系统为每一个进程建立一张段表，每个分段有一张页表。段表表项中至少包括段号、页表长度和页表始址，页表表项中至少包括页号和块号。在进行地址转换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最终形成物理地址。
![图片说明](https://uploadfiles.nowcoder.com/images/20210915/691666214_1631686115863/6C90A85D39900A44AAFAA50520B82CAE)