<hr>
<p>title: beibao<br>date: 2022-10-17 17:55:43<br>tags: 算法</p>
<hr>
<p><img src="/image-20220926170230065.png" alt="image-20220926170230065"></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><blockquote>
<p>优化空间后 除了 完全背包可从前往后 ,其他都是从后往前</p>
</blockquote>
<pre><code class="java">for 物品
    for 体积
        for 决策
</code></pre>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><pre><code class="java">//不选第i个物品和 选一个最后一个物品
dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-w[i]] + v[i]);
</code></pre>
<h3 id="板子题"><a href="#板子题" class="headerlink" title="板子题"></a>板子题</h3><pre><code class="java">输入 
3 70
71 100
69 1
1 2
    
// 给定背包大小 m,给定 物品个数 n,w[i] v[i] 求背包能装物品的最大值
</code></pre>
<pre><code class="java">import java.util.*;
class Main{
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        int[] dp = new int[m+10];
        for (int i =0; i &lt; n; i++) {
            int w = in.nextInt();
            int v = in.nextInt();
            for (int j = m; j &gt;= w; j--) dp[j] = Math.max(dp[j],dp[j-w]+v);
        }
        System.out.println(dp[m]);
    }
}
</code></pre>
<h3 id="装箱问题"><a href="#装箱问题" class="headerlink" title="装箱问题"></a>装箱问题</h3><pre><code class="java">输入
    24 // 箱子容量
    6  // 物品个数 
    8  // 物品体积
       3
    12
    7
    9
    7
    // 求任取若干 使箱子剩余空间最小
    
    //思路 体积也看成价值
</code></pre>
<h3 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h3><p>有 NN 件物品和一个容量是 VV 的背包，背包能承受的最大重量是 MM。</p>
<p>每件物品只能用一次。体积是 vivi，重量是 mimi，价值是 wiwi。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行三个整数，N,V,MN,V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p>
<p>接下来有 NN 行，每行三个整数 vi,mi,wi, vi,mi,wi，用空格隔开，分别表示第 i 件物品的体积、重量和价值。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N≤10000&lt;N≤1000<br>0&lt;V,M≤1000&lt;V,M≤100<br>0&lt;vi,mi≤1000&lt;vi,mi≤100<br>0&lt;wi≤10000&lt;wi≤1000</p>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 5 6
1 2 3
2 4 4
3 4 5
4 5 6
</code></pre>
<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code class="\">8
</code></pre>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="java">f[i][j][k] = Math.max(dp[i-1][j][k],dp[i][j-w1][k-w2] + v)
</code></pre>
<pre><code class="java">import java.util.*;
class Main{
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int W1 = in.nextInt();
        int W2 = in.nextInt();
        for (int i = 0; i &lt; n; i++) {
            int w1 = in.nextInt();
            int w2 = in.nextInt();
            int v = nextInt();
            for (int j = W1; j &gt;= 0; j--) {
                for (int k = W2; k&gt;= 0; k--) {
                    dp[j][k] = Math.max(dp[i][k],dp[j-w1][k-w2]+v);
                }
            }
        }
        System.out.println(dp[W1][W2]);
    }
}
</code></pre>
<h3 id="数字组合"><a href="#数字组合" class="headerlink" title="数字组合"></a>数字组合</h3><p><img src="/image-20220926193407826.png" alt="image-20220926193407826"></p>
<p>给定 N 个正整数 A1,A2,…,AN ,从中选出若干个数，使它们的和为 M，求有多少种选择方案。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 N 和 M。</p>
<p>第二行包含 N 个整数，表示 A1,A2,…,AN。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>包含一个整数，表示可选方案数。</p>
<h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤1001≤N≤100,<br>1≤M≤100001≤M≤10000,<br>1≤Ai≤10001≤Ai≤1000,<br>答案保证在 int 范围内。</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>4 4
1 1 2 2
</code></pre>
<h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>3
</code></pre>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">import 
</code></pre>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><pre><code class="java">//不选第i个物品和,选一个,选两个,选n个直到不能选
dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-w]+v,dp[i-1][j-2w]+2v...dp[i-1][j-nw] + nv);
dp[i][j-w] = Math.max(         dp[i-1][j-w]  ,dp[i-1][j-2w]+v ...dp[i-1][j-nw] + (n-1)v);

//最终
dp[i][j] = Math.max(dp[i-1][j],dp[i][j-w[i]] + v[i]); 
</code></pre>
<h3 id="零钱兑换I"><a href="#零钱兑换I" class="headerlink" title="零钱兑换I"></a>零钱兑换I</h3><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：</p>
<p>输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3<br>解释：11 &#x3D; 5 + 5 + 1<br>示例 2：</p>
<p>输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1<br>示例 3：</p>
<p>输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0</p>
<p>提示：</p>
<p>1 &lt;&#x3D; coins.length &lt;&#x3D; 12<br>1 &lt;&#x3D; coins[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; amount &lt;&#x3D; 104</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/coin-change">https://leetcode.cn/problems/coin-change</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code class="java">class Solution {
    public final int INF = Integer.MAX_VALUE / 2;
    public int coinChange(int[] coins, int amount) {
        // dp[i]  
        // 刚好装满的最少个数(价值为1) 
        
       int m = amount;
       int n = coins.length;
       int[]dp = new int[amount+10];
       Arrays.fill(dp,INF);
       dp[0] = 0;
       for (int i = 0; i &lt; n; i++) {
           for (int j = coins[i]; j &lt;= m; j++) {
               dp[j] = Math.min(dp[j],dp[j-coins[i]]+1);
           }
       }   
        return dp[amount] == INF ? -1 : dp[amount];
        
        
    }
}
</code></pre>
<h3 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h3><h3 id="买书-x2F-货币系统-x2F-零钱兑换II"><a href="#买书-x2F-货币系统-x2F-零钱兑换II" class="headerlink" title="买书&#x2F;货币系统&#x2F;零钱兑换II"></a>买书&#x2F;货币系统&#x2F;零钱兑换II</h3><h3 id="货币系统II"><a href="#货币系统II" class="headerlink" title="货币系统II"></a>货币系统II</h3><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p><img src="/image-20220926173426956.png" alt="image-20220926173426956"></p>
<p>r &#x3D; j % v;</p>
<p>物品有限s[i]个</p>
<pre><code class="java">//不选第i个物品,选一个第i个物品,选两个,选到不能选(体积之内 || 个数之内)
dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-w]+v,dp[i-1][j-2w]+2v...dp[i-1][j-nw] + nv);
dp[i][j-w] = Math.max(         dp[i-1][j-w]  ,dp[i-1][j-2w]+v ...dp[i-1][j-nw] + (n-1)v,dp[i][j-(n+1)w] + v); //在多重背包里会多一项不能直接替换 (在j-w的体积基础上选s[i](n个),所以要-(n+1)w)

//最简单的
 for(int j = 1; j &lt;= V; j++){
     for(int k = 0; k &lt;= s &amp;&amp; j &gt;= k * v; k++){
         dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * v] + k * w);
     }
 }
</code></pre>
<h3 id="多重背包I"><a href="#多重背包I" class="headerlink" title="多重背包I"></a>多重背包I</h3><p>有 N 种物品和一个容量是 V 的背包。</p>
<p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p>
<h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 NN行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i种物品的体积、价值和数量。</p>
<h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p>
<h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤1000&lt;N,V≤100<br>0&lt;vi,wi,si≤1000&lt;vi,wi,si≤100</p>
<h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code class="java">4 5   // n m
1 2 3 //体积、价值和数量
2 4 1
3 4 3
4 5 2
</code></pre>
<h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>10
</code></pre>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="java">import java.util.*;
class Main{
    public static void main(String[] args) {
        Scanner in = new Scanner.nextInt();
        int n = in.nextInt();
        int m = in.nextInt();
        int[] w = new int[n+10];
        int[] v = new int[n+10];
        int[] s = new int[n+10];
        for (int i = 0; i &lt; n; i++)
            
    }
}
</code></pre>
<h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><h3 id="板子题-1"><a href="#板子题-1" class="headerlink" title="板子题"></a>板子题</h3><h2 id="最优选法-背包问题求方案数"><a href="#最优选法-背包问题求方案数" class="headerlink" title="最优选法 背包问题求方案数"></a>最优选法 背包问题求方案数</h2><p><img src="/image-20220926212506051.png" alt="image-20220926212506051"></p>
<p>有 N件物品和一个容量是 V的背包。每件物品只能使用一次。</p>
<p>第 i 件物品的体积是 v_i，价值是 w_i。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>
<p>输出 <strong>最优选法的方案数</strong>。注意答案可能很大，请输出答案模 10^9 + 7 的结果。</p>
<h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 N 行，每行两个整数 v_i, w_i，用空格隔开，分别表示第 i 件物品的体积和价值。</p>
<h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 <strong>方案数</strong> 模 10^9 + 7 的结果。</p>
<h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0 \lt N, V \le 1000$<br>$0\lt v_i, w_i \le 1000$</p>
<h4 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>4 5
1 2
2 4
3 4
4 6
</code></pre>
<h4 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>2
</code></pre>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">import java.util.*;
class Main{
    static final int mod = (int)1e9 + 7;
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        //恰好装满的最大价值
        int[] f = new int[m+10];
        Arrays.fill(f,-1010);
        // 最优解的方案数
        int[] g = new int[m+10];
        f[0] = 0;
        g[0] = 1;
        
        for (int i = 0; i &lt; n; i++) {
            int w = in.nextInt();
            int v = in.nextInt();
            for (int j = m; j &gt;= w; j--) {
                int maxv = Math.max(f[j],f[j-w] + v);
                int cnt = 0;
                if (maxv == f[j]) cnt += g[j];
                if (maxv == f[j-w] + v) cnt += g[j-w];
                g[j] = cnt % mod;
                f[j] = maxv; 
            }
        }
        int res = 0;
        for (int i = 1; i &lt;= m; i++) {
            res = Math.max(res,f[i]);
        }
        int cnt = 0;
        for (int i = 1; i &lt;= m; i++) {
            if (res == f[i]) cnt = (cnt + g[i]) % mod;
        }
        
        System.out.println(cnt == 0 ? 1 : cnt);
        
    }
    
}
</code></pre>
