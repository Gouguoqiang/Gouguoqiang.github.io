

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ggq">
  <meta name="keywords" content="">
  
    <meta name="description" content="todo this的理解   30道选择评测: 异常都继承自哪个类,Math.arround(-11.5),构造函数不能写void 写了就不是默认构造函数了  &#96;&#96;&#96;javaclass Test {private String name &#x3D; “person”;&#x2F;&#x2F;    void Test() {&#x2F;&#x2F;        S">
<meta property="og:type" content="article">
<meta property="og:title" content="java">
<meta property="og:url" content="https://gouguoqiang.github.io/2022/10/08/all/1java/index.html">
<meta property="og:site_name" content="ggq">
<meta property="og:description" content="todo this的理解   30道选择评测: 异常都继承自哪个类,Math.arround(-11.5),构造函数不能写void 写了就不是默认构造函数了  &#96;&#96;&#96;javaclass Test {private String name &#x3D; “person”;&#x2F;&#x2F;    void Test() {&#x2F;&#x2F;        S">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220129214031555.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220129215338872.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220129215828134.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220129220005077.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220129220054774.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220129220213127.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220129220239687.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220201213124076.png">
<meta property="og:image" content="http://uploadfiles.nowcoder.com/images/20150921/458054_1442766565525_E93E59ACFE1791E0A5503384BEBDC544">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220202033837223.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220129225411862.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220202143350591.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220202152301760.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220221002311468.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20211228165026757.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20211228165036103.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220113075737710.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220113075830893.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220113083050590.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220824094548657.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2020/05/242dd42a2834349bfaa71500c4ea15ce37d3be96.jpeg">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220824100349380.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f33d7ecf29754253b15d6abeda2034aa.png">
<meta property="og:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220920092824156.png">
<meta property="article:published_time" content="2022-10-08T10:49:25.000Z">
<meta property="article:modified_time" content="2022-10-09T13:55:37.189Z">
<meta property="article:author" content="ggq">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:\Users\%E5%86%8D%E9%9A%BE%E4%B9%9F%E4%BC%9A%E8%BF%87\AppData\Roaming\Typora\typora-user-images\image-20220129214031555.png">
  
  
  
  <title>java - ggq</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gouguoqiang.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="java"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-08 18:49" pubdate>
          2022年10月8日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          60k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          499 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">java</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>  todo this的理解</p>
</blockquote>
<ol>
<li><p>30道选择评测: 异常都继承自哪个类,Math.arround(-11.5),构造函数不能写void 写了就不是默认构造函数了</p>
</li>
<li><p>&#96;&#96;&#96;java<br>class Test {<br>private String name &#x3D; “person”;<br>&#x2F;&#x2F;    void Test() {<br>&#x2F;&#x2F;        System.out.println(“Test…”);<br>&#x2F;&#x2F;    }<br>    Test() {<br>        System.out.println(“Test…”);<br>    }<br>}<br>public class Main extends Test{<br>&#x2F;&#x2F;学一下自己建树<br>Main() {<br>    System.out.println(“MAain..”);<br>}<br><br>public static void main(String[] args) {<br>&#x2F;&#x2F;        new Test();<br>    new Main();<br>}<br>}<br>&#x2F;*<br>Test…<br>MAain..<br>  *&#x2F;</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br><br><br><span class="hljs-meta">## </span><br><br>A：静态方法是一个属于类而不属于对象(实例)的方法。（√）<br><br>B：静态方法只能访问静态数据。无法访问非静态数据(实例变量)。（√）<br><br>C：静态方法只能调用其他静态方法，不能从中调用非静态方法。（√）<br><br>![img](http:<span class="hljs-comment">//uploadfiles.nowcoder.com/images/20150921/458054_1442766565525_E93E59ACFE1791E0A5503384BEBDC544)</span><br><br>```java<br><span class="hljs-built_in">byte</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">char</span> c = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">short</span> s = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 三目，一边为byte另一边为char，结果为int</span><br><span class="hljs-comment">// 其它情况结果为两边中范围大的。适用包装类型</span><br>i = <span class="hljs-literal">true</span>? b : c;<span class="hljs-comment">// int</span><br>b = <span class="hljs-literal">true</span>? b : b; <span class="hljs-comment">// byte</span><br>s = <span class="hljs-literal">true</span>? b : s;<span class="hljs-comment">// short</span><br><span class="hljs-comment">// 表达式，两边为byte,short,char，结果为int型</span><br><span class="hljs-comment">// 其它情况结果为两边中范围大的。适用包装类型</span><br>i = b + c; <span class="hljs-comment">// int</span><br>i = b + b; <span class="hljs-comment">// int</span><br>i = b + s; <span class="hljs-comment">// int</span><br><span class="hljs-comment">// 当 a 为基本数据类型时，a += b，相当于 a = (a) (a + b)</span><br><span class="hljs-comment">// 当 a 为包装类型时， a += b 就是 a = a + b</span><br>b += s; <span class="hljs-comment">// 没问题</span><br>c += i; <span class="hljs-comment">// 没问题</span><br><span class="hljs-comment">// 常量任君搞，long以上不能越</span><br>b = (<span class="hljs-type">char</span>) <span class="hljs-number">1</span>+ (<span class="hljs-type">short</span>) <span class="hljs-number">1</span>+ (<span class="hljs-type">int</span>) <span class="hljs-number">1</span>; <span class="hljs-comment">// 没问题</span><br><span class="hljs-comment">// i = (long) 1 // 错误</span><br></code></pre></td></tr></table></figure>



<h1 id="第2章-Java-概述"><a href="#第2章-Java-概述" class="headerlink" title="第2章 Java 概述"></a>第2章 Java 概述</h1><h2 id="2-1-Java核心机制-JVM"><a href="#2-1-Java核心机制-JVM" class="headerlink" title="2.1 Java核心机制-JVM"></a>2.1 Java核心机制-JVM</h2><ol>
<li><p>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在 JDK 中.</p>
</li>
<li><p>对于不同的平台，有不同的虚拟机。</p>
</li>
<li><p>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行</p>
</li>
</ol>
<p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129214031555.png" srcset="/img/loading.gif" lazyload alt="image-20220129214031555"></p>
<h2 id="2-2JDK-JRE"><a href="#2-2JDK-JRE" class="headerlink" title="2.2JDK JRE"></a>2.2JDK JRE</h2><ol>
<li>JDK 的全称(Java Development Kit Java 开发工具包)<br>JDK &#x3D; JRE + java 的开发工具 [java, javac,javadoc,javap 等]</li>
<li>JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独<br>安装 JRE 了。<br>2.7.2JRE 基本介绍</li>
<li>JRE(Java Runtime Environment Java 运行环境)<br>JRE &#x3D; JVM + Java 的核心类库[类]</li>
<li>包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，<br>计算机中只需要安装 JRE 即可。</li>
<li>JDK &#x3D; JRE + 开发工具集（例如 Javac,java 编译工具等)</li>
<li>JRE &#x3D; JVM + Java SE 标准类库（java 核心类库）</li>
<li>如果只想运行开发好的 .class 文件，只需要JRE</li>
</ol>
<h2 id="2-3-java开发注意事项"><a href="#2-3-java开发注意事项" class="headerlink" title="2.3 java开发注意事项"></a>2.3 java开发注意事项</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是 java 的快速入门， 演示 java 的开发步骤</span><br><span class="hljs-comment">//对代码的相关说明</span><br><span class="hljs-comment">//1. public class Hello 表示 Hello 是一个类,是一个 public 公有的类</span><br><span class="hljs-comment">//2. Hello&#123; &#125; 表示一个类的开始和结束</span><br><span class="hljs-comment">//3. public static void main(String[] args) 表示一个主方法,即我们程序的入口</span><br><span class="hljs-comment">//4. main() &#123;&#125; 表示方法的开始和结束</span><br><span class="hljs-comment">//5. System.out.println(&quot;hello,world~&quot;); 表示输出&quot;hello,world~&quot;到屏幕</span><br><span class="hljs-comment">//6. ;表示语句结束</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br><span class="hljs-comment">//编写一个 main 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;韩顺平教育 hello&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//一个源文件中最多只能有一个 public 类。其它类的个数不限。[演示]</span><br><span class="hljs-comment">//Dog 是一个类</span><br><span class="hljs-comment">//编译后，每一个类，都对于一个.class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br><span class="hljs-comment">//一个源文件中最多只能有一个 public 类。其它类的个数不限，也可以将 main 方法写在非 public 类中，</span><br><span class="hljs-comment">//然后指定运行非 public 类，这样入口方法就是非 public 的 main 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;hello, 小狗狗~&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;hello, 小老虎~&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Java的所有都跟class相关 </p>
<h1 id="第3章-变量"><a href="#第3章-变量" class="headerlink" title="第3章 变量"></a>第3章 变量</h1><h2 id="3-1数据类型与API"><a href="#3-1数据类型与API" class="headerlink" title="3.1数据类型与API"></a>3.1数据类型与API</h2><p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129215338872.png" srcset="/img/loading.gif" lazyload alt="image-20220129215338872"></p>
<p>JavaAPI（application program interface 应用程序编程接口）文档</p>
<p>中文 <a target="_blank" rel="noopener" href="http://www.matools.com/">www.matools.com</a></p>
<p>Java 提供了大量的类，API告诉开发者如何使用这些类</p>
<h2 id="3-2Java类的组织形式"><a href="#3-2Java类的组织形式" class="headerlink" title="3.2Java类的组织形式"></a>3.2Java类的组织形式</h2><p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129215828134.png" srcset="/img/loading.gif" lazyload alt="image-20220129215828134"></p>
<h2 id="3-3-char-字符编码"><a href="#3-3-char-字符编码" class="headerlink" title="3.3 char+字符编码"></a>3.3 char+字符编码</h2><p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129220005077.png" srcset="/img/loading.gif" lazyload alt="image-20220129220005077"></p>
<p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129220054774.png" srcset="/img/loading.gif" lazyload alt="image-20220129220054774"></p>
<h2 id="3-4Unicode"><a href="#3-4Unicode" class="headerlink" title="3.4Unicode"></a>3.4Unicode</h2><p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129220213127.png" srcset="/img/loading.gif" lazyload alt="image-20220129220213127"></p>
<h2 id="3-5UTF-8"><a href="#3-5UTF-8" class="headerlink" title="3.5UTF-8"></a>3.5UTF-8</h2><p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129220239687.png" srcset="/img/loading.gif" lazyload alt="image-20220129220239687"></p>
<h2 id="3-6基本数据类型转换"><a href="#3-6基本数据类型转换" class="headerlink" title="3.6基本数据类型转换"></a>3.6基本数据类型转换</h2><p>精度小的类型自动转化为精度大的</p>
<p>有多种类型混合运算，系统首先自动将所有数据转换成容量最大的那种数据类型再计算</p>
<p>当把容量大的赋值给容量小的就会报错，反之自动类型转换</p>
<p>byte short 和char 不会自动转换 ，在计算式首先转换为int类型</p>
<p>boolen不参与转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//ok</span><br><span class="hljs-comment">//float d1 = n1 + 1.1;//错误 n1 + 1.1 =&gt; 结果类型是 double</span><br><span class="hljs-comment">//double d1 = n1 + 1.1;//对 n1 + 1.1 =&gt; 结果类型是 double</span><br><span class="hljs-type">float</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-number">1.1F</span>;<span class="hljs-comment">//对 n1 + 1.1 =&gt; 结果类型是 float</span><br><span class="hljs-comment">//细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时，</span><br><span class="hljs-comment">//就会报错，反之就会进行自动类型转换。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//int n2 = 1.1;//错误 double -&gt; int</span><br><span class="hljs-comment">//细节 3: (byte, short) 和 char 之间不会相互自动转换</span><br><span class="hljs-comment">//当把具体数赋给 byte 时，(1)先判断该数是否在 byte 范围内，如果是就可以</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//对 , -128-127</span><br><span class="hljs-comment">// int n2 = 1; //n2 是 int</span><br><span class="hljs-comment">// byte b2 = n2; //错误，原因： 如果是变量赋值，判断类型</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// char c1 = b1; //错误， 原因 byte 不能自动转成 char</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br>韩顺平循序渐进学 Java 零基础<br>第 <span class="hljs-number">48</span>页<br><span class="hljs-comment">//细节 4: byte，short，char 他们三者可以计算，在计算时首先转换为 int 类型</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">//short s2 = b2 + s1;//错, b2 + s1 =&gt; int</span><br><span class="hljs-type">int</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> b2 + s1;<span class="hljs-comment">//对, b2 + s1 =&gt; int</span><br><span class="hljs-comment">//byte b4 = b2 + b3; //错误: b2 + b3 =&gt; int</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//boolean 不参与转换</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//int num100 = pass;// boolean 不参与类型的自动转换</span><br><span class="hljs-comment">//自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型</span><br><span class="hljs-comment">//看一道题</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b4</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num200</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">num300</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.1F</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">num500</span> <span class="hljs-operator">=</span> b4 + s3 + num200 + num300; <span class="hljs-comment">//float -&gt; double</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-7-强制类型转换"><a href="#3-7-强制类型转换" class="headerlink" title="3.7 强制类型转换"></a>3.7 强制类型转换</h2><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成<br>精度降低或溢出,格外要注意</p>
<h1 id="第4章-运算符"><a href="#第4章-运算符" class="headerlink" title="第4章 运算符"></a>第4章 运算符</h1><h2 id="4-1命名规范"><a href="#4-1命名规范" class="headerlink" title="4.1命名规范"></a>4.1命名规范</h2><p>1.包名：多单词组成时所有字母都小写：aaa.bbb.ccc &#x2F;&#x2F;比如 com.hsp.crm</p>
<ol start="2">
<li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]<br>比如： TankShotGame</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小<br>驼峰， 简称 驼峰法]<br>比如： tankShotGame</li>
<li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ<br>比如 ：定义一个所得税率 TAX_RATE</li>
<li>后面我们学习到 类，包，接口，等时，我们的命名规范要这样遵守,更加详细的看文档.</li>
</ol>
<h2 id="4-2键盘输入语句"><a href="#4-2键盘输入语句" class="headerlink" title="4.2键盘输入语句"></a>4.2键盘输入语句</h2><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java , 需要一个 扫描器(对象), 就是 Scanner</p>
<p>步骤 ： 1) 导入该类的所在包, java.util.* 2) 创建该类对象（声明变量） 3) 调用里面的功能</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>import java.util.Scanner;&#x2F;&#x2F;表示把 java.util 下的 Scanner 类导入<br>public class Input {<br>&#x2F;&#x2F;编写一个 main 方法<br>public static void main(String[] args) {<br>&#x2F;&#x2F;演示接受用户的输入<br>&#x2F;&#x2F;步骤<br>&#x2F;&#x2F;Scanner 类 表示 简单文本扫描器，在 java.util 包<br>&#x2F;&#x2F;1. 引入&#x2F;导入 Scanner 类所在的包<br>&#x2F;&#x2F;2. 创建 Scanner 对象 , new 创建一个对象,体会<br>&#x2F;&#x2F; myScanner 就是 Scanner 类的对象<br>Scanner myScanner &#x3D; new Scanner(System.in);<br>&#x2F;&#x2F;3. 接收用户输入了， 使用 相关的方法<br>System.out.println(“请输入名字”);<br>&#x2F;&#x2F;当程序执行到 next 方法时，会等待用户输入~~~ String name &#x3D; myScanner.next(); &#x2F;&#x2F;接收用户输入字符串<br>System.out.println(“请输入年龄”);<br>int age &#x3D; myScanner.nextInt(); &#x2F;&#x2F;接收用户输入 int<br>System.out.println(“请输入薪水”);<br>double sal &#x3D; myScanner.nextDouble(); &#x2F;&#x2F;接收用户输入 double<br>System.out.println(“人的信息如下:”);<br>韩顺平循序渐进学 Java 零基础<br>第 81页<br>System.out.println(“名字&#x3D;” + name</p>
<ul>
<li>“ 年龄&#x3D;” + age + “ 薪水&#x3D;” + sal);<br>}<br>}<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>  <br><br><span class="hljs-meta"># 第6章 数组</span><br><br><br><br><span class="hljs-meta">## 6.1数组的使用</span><br><br><span class="hljs-meta">### 使用方式1-动态初始化</span><br><br><span class="hljs-comment">//(1) 第一种动态分配方式</span><br><span class="hljs-comment">//double scores[] = new double[5];</span><br><span class="hljs-comment">//(2) 第 2 种动态分配方式， 先声明数组，再 new 分配空间</span><br><span class="hljs-built_in">double</span> scores[] ; <span class="hljs-comment">//声明数组， 这时 scores 是 null</span><br>scores = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 分配内存空间，可以存放数据</span><br><br><span class="hljs-meta">### 使用方式2-动态初始化</span><br><br><br><br><span class="hljs-meta">### 使用方式3-静态初始化</span><br><br><span class="hljs-built_in">int</span>[] a =&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">41</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-meta">## 6.2数组使用细节</span><br><br><span class="hljs-number">1</span>) 数组是多个相同类型数据的组合，实现对这些数据的统一管理<br><span class="hljs-number">2</span>) 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。<br><span class="hljs-number">3</span>) 数组创建后，如果没有赋值，有默认值<br><span class="hljs-built_in">int</span> <span class="hljs-number">0</span>，<span class="hljs-built_in">short</span> <span class="hljs-number">0</span>, <span class="hljs-built_in">byte</span> <span class="hljs-number">0</span>, <span class="hljs-built_in">long</span> <span class="hljs-number">0</span>, <span class="hljs-built_in">float</span> <span class="hljs-number">0.0</span>,<span class="hljs-built_in">double</span> <span class="hljs-number">0.0</span>，<span class="hljs-built_in">char</span> \u0000，boolean <span class="hljs-literal">false</span>，String <span class="hljs-literal">null</span><br><span class="hljs-number">4</span>) 使用数组的步骤 <span class="hljs-number">1.</span> 声明数组并开辟空间 <span class="hljs-number">2</span> 给数组各个元素赋值 <span class="hljs-number">3</span> 使用数组<br><span class="hljs-number">5</span>) 数组的下标是从 <span class="hljs-number">0</span> 开始的。<br><span class="hljs-number">6</span>) 数组下标必须在指定范围内使用，否则报：下标越界异常，比如<br>韩顺平循序渐进学 Java 零基础<br>第 <span class="hljs-number">148</span>页<br><span class="hljs-built_in">int</span> [] arr=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>]; 则有效下标为 <span class="hljs-number">0</span><span class="hljs-number">-4</span><br><span class="hljs-number">7</span>) 数组属引用类型，数组型数据是对象(<span class="hljs-built_in">object</span>)<br><br><br><br><span class="hljs-meta">## 6.3数组赋值机制</span><br><br>[(<span class="hljs-number">141</span>条消息) java堆，栈，常量池最通俗易懂的图文解释_我的博客-CSDN博客_堆栈常量池](https:<span class="hljs-comment">//blog.csdn.net/weixin_41804049/article/details/80393892)</span><br><br><span class="hljs-number">1</span>）基本类型赋值，这个值就是具体的数据，而且互不影响<br><br><span class="hljs-number">2</span>)数组在默认情况下是引用传递，赋的值是地址 <br><br><br><br><br><br>栈存放基本数据类型的变量值 和对象的引用<br><br>堆存放对象的具体实例 <span class="hljs-keyword">new</span>出来的<br><br>字符串常量对象存放在常量池中<br><br><span class="hljs-meta">## 6.4数组拷贝</span><br><br><span class="hljs-comment">//将 int[] arr1 = &#123;10,20,30&#125;; 拷贝到 arr2 数组, //要求数据空间是独立的. int[] arr1 = &#123;10,20,30&#125;;</span><br><span class="hljs-comment">//创建一个新的数组 arr2,开辟新的数据空间</span><br><span class="hljs-comment">//大小 arr1.length;</span><br><span class="hljs-built_in">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[arr1.length];<br><span class="hljs-comment">//遍历 arr1 ，把每个元素拷贝到 arr2 对应的元素位置</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<br>arr2[i] = arr1[i];<br>&#125;<br><span class="hljs-comment">//老师修改 arr2， 不会对 arr1 有影响. arr2[0] = 100;</span><br><span class="hljs-comment">//输出 arr1</span><br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;====arr1 的元素====&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<br>System.<span class="hljs-keyword">out</span>.println(arr1[i]);<span class="hljs-comment">//10,20,30</span><br><br>&#125;<br><br><span class="hljs-meta">## 6.5数组翻转</span><br><br>方式 <span class="hljs-number">1</span>：通过找规律反转 【思路分析】<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ArrayReverse</span> &#123;<br><span class="hljs-comment">//编写一个 main 方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><span class="hljs-comment">//定义数组</span><br><span class="hljs-built_in">int</span>[] arr = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>&#125;;<br><span class="hljs-comment">//老韩思路</span><br><span class="hljs-comment">//规律</span><br><span class="hljs-comment">//1. 把 arr[0] 和 arr[5] 进行交换 &#123;66,22,33,44,55,11&#125;</span><br>韩顺平循序渐进学 Java 零基础<br>第 <span class="hljs-number">155</span>页<br><span class="hljs-comment">//2. 把 arr[1] 和 arr[4] 进行交换 &#123;66,55,33,44,22,11&#125;</span><br><span class="hljs-comment">//3. 把 arr[2] 和 arr[3] 进行交换 &#123;66,55,44,33,22,11&#125;</span><br><span class="hljs-comment">//4. 一共要交换 3 次 = arr.length / 2</span><br><span class="hljs-comment">//5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]</span><br><span class="hljs-comment">//代码</span><br><span class="hljs-comment">//优化</span><br><span class="hljs-built_in">int</span> temp = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> len = arr.length; <span class="hljs-comment">//计算数组的长度</span><br><span class="hljs-keyword">for</span>( <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; len / <span class="hljs-number">2</span>; i++) &#123;<br>temp = arr[len - <span class="hljs-number">1</span> - i];<span class="hljs-comment">//保存</span><br>arr[len - <span class="hljs-number">1</span> - i] = arr[i];<br>arr[i] = temp;<br>&#125;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;===翻转后数组===&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>System.<span class="hljs-keyword">out</span>.print(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<span class="hljs-comment">//66,55,44,33,22,11</span><br>&#125;<br>&#125;<br>&#125;<br><br><br><br>方式 <span class="hljs-number">2</span>：使用逆序赋值方式 【思路分析, 学员自己完成】 ArrayReverse02.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ArrayReverse02</span> &#123;<br><span class="hljs-comment">//编写一个 main 方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><span class="hljs-comment">//定义数组</span><br><span class="hljs-built_in">int</span>[] arr = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>&#125;;<br><span class="hljs-comment">//使用逆序赋值方式</span><br><span class="hljs-comment">//老韩思路</span><br><span class="hljs-comment">//1. 先创建一个新的数组 arr2 ,大小 arr.length</span><br><span class="hljs-comment">//2. 逆序遍历 arr ,将 每个元素拷贝到 arr2 的元素中(顺序拷贝)</span><br><span class="hljs-comment">//3. 建议增加一个循环变量 j -&gt; 0 -&gt; 5</span><br><span class="hljs-built_in">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[arr.length];<br><span class="hljs-comment">//逆序遍历 arr</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = arr.length - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span>; i--, j++) &#123;<br>arr2[j] = arr[i];<br>&#125;<br><span class="hljs-comment">//4. 当 for 循环结束，arr2 就是一个逆序的数组 &#123;66, 55, 44,33, 22, 11&#125;</span><br><span class="hljs-comment">//5. 让 arr 指向 arr2 数据空间, 此时 arr 原来的数据空间就没有变量引用</span><br><span class="hljs-comment">// 会被当做垃圾，销毁</span><br>arr = arr2;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;====arr 的元素情况=====&quot;</span>);<br><span class="hljs-comment">//6. 输出 arr 看看</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>韩顺平循序渐进学 Java 零基础<br>第 <span class="hljs-number">157</span>页<br>System.<span class="hljs-keyword">out</span>.print(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">## 6.6数组添加/扩容</span><br><br>思路分析<br><br><span class="hljs-number">1.</span> 定义初始数组 <span class="hljs-built_in">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<span class="hljs-comment">//下标 0-2</span><br><br><span class="hljs-number">2.</span> 定义一个新的数组 <span class="hljs-built_in">int</span>[] arrNew = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[arr.length+<span class="hljs-number">1</span>];<br><br><span class="hljs-number">3.</span> 遍历 arr 数组，依次将 arr 的元素拷贝到 arrNew 数组<br><br><span class="hljs-number">4.</span> 将 <span class="hljs-number">4</span> 赋给 arrNew[arrNew.length - <span class="hljs-number">1</span>] = <span class="hljs-number">4</span>;把 <span class="hljs-number">4</span> 赋给 arrNew 最后一个元素<br><br><span class="hljs-number">5.</span> 让 arr 指向 arrNew ; arr = arrNew; 那么 原来 arr 数组就被销毁<br><br><span class="hljs-number">6.</span> 创建一个 Scanner 可以接受用户输入<br><br><br><span class="hljs-meta">## 补充1.</span><br><br>&gt; 基本数据类型：<br><br>  四类八种：<br><br><span class="hljs-number">1.</span> 整数型：<span class="hljs-built_in">byte</span>（<span class="hljs-number">1</span>字节）、<span class="hljs-built_in">short</span>（<span class="hljs-number">2</span>字节） 、<span class="hljs-built_in">int</span>（<span class="hljs-number">4</span>字节）、<span class="hljs-built_in">long</span>（<span class="hljs-number">8</span>字节）<span class="hljs-built_in">long</span> 类型要在后面加L，（可以省略，超出<span class="hljs-built_in">int</span> 的范围时需要加L）<br><span class="hljs-number">2.</span> 浮点型：<span class="hljs-built_in">float</span>（<span class="hljs-number">4</span>字节）、<span class="hljs-built_in">double</span>（<span class="hljs-number">8</span>字节）<span class="hljs-built_in">float</span> 类型 要在数字后面加f<br><span class="hljs-number">3.</span> 字符型：<span class="hljs-built_in">char</span>（<span class="hljs-number">2</span>字节）<br><span class="hljs-number">4.</span> 布尔型：boolean（<span class="hljs-number">1</span>位）是非对错<br><br>&gt; 引用数据类型：<br><br>除了基本数据类型之外的、都叫引用类型。<br><br><span class="hljs-number">1.</span> 类<br><span class="hljs-number">2.</span> 接口<br><span class="hljs-number">3.</span> 数组<br><span class="hljs-number">4.</span> 枚举<br><br><span class="hljs-meta">## 4.什么是字节</span><br><br><span class="hljs-number">1.</span> 位（bit）：<br>   是计算机 内部数据 存储的最小单位，<span class="hljs-number">11001100</span>是一个八位二进制数。<br><span class="hljs-number">2.</span> 字节（<span class="hljs-built_in">byte</span>）<br>   是计算机中 数据处理 的基本单位，习惯上用大写B来表示；<span class="hljs-number">1B</span>（<span class="hljs-built_in">byte</span>字节）<span class="hljs-number">1B</span>（<span class="hljs-built_in">byte</span>字节） = <span class="hljs-number">8b</span>it （位）<br><span class="hljs-number">3.</span> 字符：<br>   是指计算机中使用的字母、数字、和符号<br><br>&gt; 常见单位换算<br><br>  <span class="hljs-number">1b</span>it 表示 <span class="hljs-number">1</span>位<br>  <span class="hljs-number">1b</span>yte 表示一个字节 <span class="hljs-number">1B</span>=<span class="hljs-number">8b</span><br>  <span class="hljs-number">1024b</span> = <span class="hljs-number">1</span>kb<br>  <span class="hljs-number">1024</span>kb = <span class="hljs-number">1</span>M<br>  <span class="hljs-number">1024</span>M = <span class="hljs-number">1</span>G<br>  <span class="hljs-number">1024</span>G = <span class="hljs-number">1</span>TB<br><br><span class="hljs-meta">## 5.进制问题</span><br><br>&gt; 进制说明<br><br>二进制：<span class="hljs-number">0b</span><br>十进制：默认<br>八进制：<span class="hljs-number">0</span> 逢八进一<br>十六进制：<span class="hljs-number">0</span>x 逢十六进一<br><br>银行业务用什么表示？用BigDecimal类 数学工具类<br>不能使用浮点数。<br><br>- <span class="hljs-built_in">float</span>：<br><br>  浮点数是有限的 舍入误差，大约，接近但不等于<br><br>- <span class="hljs-built_in">double</span>：<br>  最好完全使用浮点数进行比较<br>  最好完全使用浮点数进行比较<br>  最好完全使用浮点数进行比较<br><br>```<span class="hljs-function">java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><br>    <span class="hljs-built_in">int</span> i1 = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">int</span> i2 = <span class="hljs-number">010</span>;<br>    <span class="hljs-built_in">int</span> i3 = <span class="hljs-number">0x10</span>;<br>    System.<span class="hljs-keyword">out</span>.println(i1);<span class="hljs-comment">//10</span><br>    System.<span class="hljs-keyword">out</span>.println(i2);<span class="hljs-comment">//8</span><br>    System.<span class="hljs-keyword">out</span>.println(i3);<span class="hljs-comment">//16</span><br><br>    <span class="hljs-built_in">float</span> f = <span class="hljs-number">0.1f</span>;<span class="hljs-comment">//0.1</span><br>    <span class="hljs-built_in">double</span> d = <span class="hljs-number">1.0</span>/<span class="hljs-number">10</span>;<span class="hljs-comment">//0.1</span><br>    System.<span class="hljs-keyword">out</span>.println(f == d);<span class="hljs-comment">//false</span><br><br>&#125;<br><span class="hljs-number">1234567891011121314</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>字符扩展？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;中&#x27;</span>;<br>System.out.println(c1);<br>System.out.println((<span class="hljs-type">int</span>)c1);<span class="hljs-comment">//97 强制转换</span><br>System.out.println(c2);<br>System.out.println((<span class="hljs-type">int</span>)c2);<span class="hljs-comment">//20013</span><br><span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure>

<p>所有的字符本质还是数字<br>编码问题 Unicode 表：（97 &#x3D; a，65 &#x3D; A） 编码 占了两个字节</p>
<p>转义字符<br>\t 制表符<br>\n 换行<br>…</p>
<h2 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6.类型转换"></a>6.类型转换</h2><blockquote>
<p>通过查看byte包装类型得到：byte 最大值信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>   <span class="hljs-variable">MIN_VALUE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>   <span class="hljs-variable">MAX_VALUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>

<hr>
<p>  由于java是强类型语言，所以要进行有些运算的时候，需要用到类型转换。</p>
<p>  低 ———————————————-&gt;高<br>  byte，short，char—&gt;，int—&gt;，float—&gt;，long—&gt;，double</p>
<p>  运算中，不同类型的数据先转换为同一类型，然后进行运算。（小数优先级高于整数）</p>
<blockquote>
<p>强制类型转换</p>
</blockquote>
<p>高到低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>) i;<span class="hljs-comment">//内存溢出</span><br>System.out.println(i);<span class="hljs-comment">//128</span><br>System.out.println(b);<span class="hljs-comment">//-128</span><br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>自动类型转换</p>
</blockquote>
<p>低到高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> i;<br>System.out.println(i);<span class="hljs-comment">//128</span><br>System.out.println(d);<span class="hljs-comment">//128.0</span><br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
</blockquote>
<ol>
<li>不能对布尔类型进行转换。（不能把人转成猪，可以把男人转女人）</li>
<li>不能把对象类型转换为不相干的类型。</li>
<li>在把高容量转换为低容量的时候，需要强制转换。</li>
<li>转换的时候可能存在内存溢出，或者精度问题。</li>
</ol>
<h1 id="Java流程控制"><a href="#Java流程控制" class="headerlink" title="Java流程控制"></a>Java流程控制</h1><h2 id="1-Scanner-类"><a href="#1-Scanner-类" class="headerlink" title="1.Scanner 类"></a>1.Scanner 类</h2><p>  通过scanner 类的next() 与nextLine() 方法获取输入的字符串，在读取我们一般需要使用hasNext() 与 hasNextLine() 判断是否还有输入的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in)<br><span class="hljs-number">1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//从键盘接收数据</span><br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.println(<span class="hljs-string">&quot;使用next方式接收：&quot;</span>);<br>    <span class="hljs-comment">//判断是否还有输入</span><br>    <span class="hljs-keyword">if</span> (sc.hasNext())&#123;<br>        <span class="hljs-comment">//next() 只读取第一个字符串</span><br>        <span class="hljs-comment">//String str = sc.next();</span><br>        <span class="hljs-comment">//nextLine() 获取一行数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;用户输入是：&quot;</span>+str);<br>    &#125;<br>    sc.close();<br>&#125;<br><span class="hljs-number">1234567891011121314</span><br></code></pre></td></tr></table></figure>

<h2 id="next-："><a href="#next-：" class="headerlink" title="next()："></a>next()：</h2><ol>
<li>一定要读取到有效字符后才可以结束输入。</li>
<li>对输入有效字符之前遇到的空白，next（）方法会自动将其去掉。</li>
<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li>
<li>next（）方法不能得到有空格的不能得到有空格的字符串</li>
</ol>
<h2 id="nextLine"><a href="#nextLine" class="headerlink" title="nextLine():"></a>nextLine():</h2><ol>
<li>以Enter为结束符，也就是说 nextLine() 方法返回的是输入回车之前的所有字符</li>
<li>可以获得空白。</li>
</ol>
<h2 id="4-switch-多选择语句"><a href="#4-switch-多选择语句" class="headerlink" title="4.switch 多选择语句"></a>4.switch 多选择语句</h2><p>  switch case 语句判断一个变量和与一系列值中某个值相等，每个值称为一个分支。<br>  switch 语句中的变量类型可以是：</p>
<ol>
<li>byte、short、int、或者是char</li>
<li>从 Java SE 7开始</li>
<li>switch 开始支持字符串 String 类型了</li>
<li>同时case 标签必须为字符串常量或字面量</li>
</ol>
<h1 id="第7章面向对象基础部分"><a href="#第7章面向对象基础部分" class="headerlink" title="第7章面向对象基础部分"></a>第7章面向对象基础部分</h1><h2 id="7-1创建对象"><a href="#7-1创建对象" class="headerlink" title="7.1创建对象"></a>7.1创建对象</h2><ol>
<li>先声明再创建<br> Cat cat ; &#x2F;&#x2F;声明对象 cat<br> cat &#x3D; new Cat(); &#x2F;&#x2F;创建</li>
<li>直接创建<br> Cat cat &#x3D; new Cat();</li>
</ol>
<p>创建对象 在方法区加载	</p>
<h2 id="7-2Java-内存的结构分析"><a href="#7-2Java-内存的结构分析" class="headerlink" title="7.2Java 内存的结构分析"></a>7.2Java 内存的结构分析</h2><ol>
<li><p>栈： 一般存放基本数据类型(局部变量)</p>
</li>
<li><p>堆： 存放对象(Cat cat , 数组等)</p>
</li>
<li><p>方法区：常量池(常量，比如字符串)， 类加载信息</p>
</li>
<li><p>示意图 [Cat (name, age, price)]<br> Java 创建对象的流程简单分析<br> Person p &#x3D; new Person();<br> p.name &#x3D; “jack”;<br> p.age &#x3D; 10</p>
</li>
<li><p>先加载 Person 类信息(属性和方法信息, 只会加载一次)</p>
</li>
<li><p>在堆中分配空间, 进行默认初始化(看规则)</p>
</li>
<li><p>把地址赋给 p , p 就指向对象</p>
</li>
<li><p>进行指定初始化， 比如 p.name &#x3D;”jack”</p>
</li>
<li><p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220201213124076.png" srcset="/img/loading.gif" lazyload alt="image-20220201213124076"></p>
</li>
</ol>
<p>方法的调用机制原理</p>
<p>1.当程序执行到方法时，就会开辟一个独立的空间（栈空间）</p>
<p>2.当方法执行完毕，或者执行到return语句时就会返回</p>
<p>3.返回到调用方法的地方</p>
<p>4.返回后继续执行方法后面的代码</p>
<p>5.当main方法（栈）执行完毕，整个程序退出</p>
<p>方法的访问修饰符</p>
<p><img src="http://uploadfiles.nowcoder.com/images/20150921/458054_1442766565525_E93E59ACFE1791E0A5503384BEBDC544" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>方法的返回数据类型</p>
<p>void可无return，或者return;</p>
<h2 id="7-4成员方法传参机制"><a href="#7-4成员方法传参机制" class="headerlink" title="7.4成员方法传参机制"></a>7.4成员方法传参机制</h2><h3 id="7-4-1基本数据类型的传参机制"><a href="#7-4-1基本数据类型的传参机制" class="headerlink" title="7.4.1基本数据类型的传参机制"></a>7.4.1基本数据类型的传参机制</h3><p>基本数据类型，传递的是值 ，形参的任何改变不影响实参</p>
<h3 id="7-4-2引用数据类型的传参机制"><a href="#7-4-2引用数据类型的传参机制" class="headerlink" title="7.4.2引用数据类型的传参机制"></a>7.4.2引用数据类型的传参机制</h3><p>B 类中编写一个方法 test100，可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化？会变化</p>
<p>B 类中编写一个方法 test200，可以接收一个 Person(age,sal)对象，在方法中修改该对象属性，看看原来的对象是否变化？会变化</p>
<p>引用类型传递的是地址（传递也是值，但是值是地址）</p>
<p>方法栈 </p>
<p>如果对方法传入的引入对象 然后对引入对象进行更改，并没有对原指针更改，而是将指针传给另一个值，可以根据这个地址更改原来指向的对象的属性，但不能更改原来的对象的地址</p>
<p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220202033837223.png" srcset="/img/loading.gif" lazyload alt="image-20220202033837223"></p>
<p>&#x2F;&#x2F;编写一个方法 copyPerson，可以复制一个 Person 对象，返回复制的对象。克隆对象，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意要求得到新对象和原来的对象是两个独立的对象，只是他们的属性相同</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//编写方法的思路</span><br><span class="hljs-comment">//1. 方法的返回类型 Person</span><br><span class="hljs-comment">//2. 方法的名字 copyPerson</span><br><span class="hljs-comment">//3. 方法的形参 (Person p)</span><br><span class="hljs-comment">//4. 方法体, 创建一个新对象，并复制属性，返回即可</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">copyPerson</span><span class="hljs-params">(Person p)</span> &#123;<br><span class="hljs-comment">//创建一个新的对象</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p2.name = p.name; <span class="hljs-comment">//把原来对象的名字赋给 p2.name</span><br>p2.age = p.age; <span class="hljs-comment">//把原来对象的年龄赋给 p2.age</span><br><span class="hljs-keyword">return</span> p2;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-4-3方法的递归调用"><a href="#7-4-3方法的递归调用" class="headerlink" title="7.4.3方法的递归调用"></a>7.4.3方法的递归调用</h3><p>每次调用方法 都会形成方法栈 占用主栈的空间</p>
<h2 id="7-5方法重载"><a href="#7-5方法重载" class="headerlink" title="7.5方法重载"></a>7.5方法重载</h2><p>java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！ 比如：System.out.println(); out 是 PrintStream 类</p>
<p>方法名相同</p>
<p>形参列表必须不同 形参类型 或个数 或顺序</p>
<h2 id="7-6可变参数"><a href="#7-6可变参数" class="headerlink" title="7.6可变参数"></a>7.6可变参数</h2><h3 id="7-6-1基本概念"><a href="#7-6-1基本概念" class="headerlink" title="7.6.1基本概念"></a>7.6.1基本概念</h3><p>java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。<br>就可以通过可变参数实现</p>
<h3 id="7-6-2基本语法"><a href="#7-6-2基本语法" class="headerlink" title="7.6.2基本语法"></a>7.6.2基本语法</h3><p>访问修饰符 返回类型 方法名(数据类型… 形参名) {<br>}</p>
<h3 id="7-6-3快速入门案例"><a href="#7-6-3快速入门案例" class="headerlink" title="7.6.3快速入门案例"></a>7.6.3快速入门案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">看一个案例 类 HspMethod，方法 sum 【可以计算 <span class="hljs-number">2</span> 个数的和，<span class="hljs-number">3</span> 个数的和 ， <span class="hljs-number">4.</span> <span class="hljs-number">5</span>， 。。】<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VarParameter01</span> &#123;<br><span class="hljs-comment">//编写一个 main 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">HspMethod</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HspMethod</span>();<br>System.out.println(m.sum(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>)); <span class="hljs-comment">//106</span><br>System.out.println(m.sum(<span class="hljs-number">1</span>,<span class="hljs-number">19</span>)); <span class="hljs-comment">//20</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HspMethod</span> &#123;<br><span class="hljs-comment">//可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。</span><br><span class="hljs-comment">//可以使用方法重载</span><br><span class="hljs-comment">// public int sum(int n1, int n2) &#123;//2 个数的和</span><br><span class="hljs-comment">// return n1 + n2;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// public int sum(int n1, int n2, int n3) &#123;//3 个数的和</span><br><span class="hljs-comment">// return n1 + n2 + n3;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// public int sum(int n1, int n2, int n3, int n4) &#123;//4 个数的和</span><br><span class="hljs-comment">// return n1 + n2 + n3 + n4;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//..... //上面的三个方法名称相同，功能相同, 参数个数不同-&gt; 使用可变参数优化</span><br><span class="hljs-comment">//1. int... 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多)</span><br><span class="hljs-comment">//2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组</span><br><span class="hljs-comment">//3. 遍历 nums 求和即可</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>... nums)</span> &#123;<br><span class="hljs-comment">//System.out.println(&quot;接收的参数个数=&quot; + nums.length);</span><br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>res += nums[i];<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-6-4注意事项和使用细节"><a href="#7-6-4注意事项和使用细节" class="headerlink" title="7.6.4注意事项和使用细节"></a>7.6.4注意事项和使用细节</h3><p>可变参数的实参可以为0或任意多个</p>
<p>可变参数的实参可以维数组</p>
<p>可变参数的本质就是数组</p>
<p>可变参数可以和普通参数一起放在形参列表，但必须保证可变参数在最后</p>
<p>一个形参列表中只能出现一个可变参数</p>
<p>&#x2F;&#x2F;细节: 可变参数的实参可以为数组<br>int[] arr &#x3D; {1, 2, 3};<br>T t1 &#x3D; new T();<br>t1.f1(arr);<br>}<br>}<br>class T {<br>public void f1(int… nums) {<br>System.out.println(“长度&#x3D;” + nums.length);<br>}</p>
<h2 id="7-7作用域（对类来说）"><a href="#7-7作用域（对类来说）" class="headerlink" title="7.7作用域（对类来说）"></a>7.7作用域（对类来说）</h2><p>1.在Java编程中，主要的变量就是属性（成员变量）和局部变量</p>
<p>2.我们说的局部变量一般是指在成员方法中定义的变量</p>
<p>3.Java中作用域的分类</p>
<p>全局变量：也就是属性，作用域为整个类体</p>
<p>局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中</p>
<p>4.属性可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用因为没有默认值</p>
<p>5.注意事项和细节使用</p>
<p>属性和局部变量可以重名，访问时采用就近原则</p>
<p>同作用域不能重名</p>
<p>属性生命周期较长 伴随着对象的创建而创建，伴随着对象的销毁而销毁</p>
<p>局部变量伴随着代码快的执行而创建，伴随着代码的结束而销毁。即在一次方法调用过程中</p>
<p>作用域范围不同 ：属性可以被本类使用，或其他类使用（通过对象调用） 局部变量只能在本类中对应的方法中调用</p>
<p>修饰符不同 属性可以加修饰符，局部变量不可以加修饰符</p>
<h2 id="7-8构造方法-x2F-构造器"><a href="#7-8构造方法-x2F-构造器" class="headerlink" title="7.8构造方法&#x2F;构造器"></a>7.8构造方法&#x2F;构造器</h2><h1 id="第10章面向对象高级部分"><a href="#第10章面向对象高级部分" class="headerlink" title="第10章面向对象高级部分"></a>第10章面向对象高级部分</h1><h2 id="10-5-final-关键字"><a href="#10-5-final-关键字" class="headerlink" title="10.5 final 关键字"></a>10.5 final 关键字</h2><p>可以修饰类，属性，方法和局部变量</p>
<p>第13 章 常用类</p>
<h2 id="13-1包装类"><a href="#13-1包装类" class="headerlink" title="13.1包装类"></a>13.1包装类</h2><p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129225411862.png" srcset="/img/loading.gif" lazyload alt="image-20220129225411862"></p>
<p>有了类的特点，就可以调用类的方法</p>
<h3 id="13-1-1装箱拆箱"><a href="#13-1-1装箱拆箱" class="headerlink" title="13.1.1装箱拆箱"></a>13.1.1装箱拆箱</h3><p>JDK5前 装箱：基本数据类型-&gt;包装类 拆箱相反 手动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//演示 int &lt;--&gt; Integer 的装箱和拆箱</span><br><span class="hljs-comment">//jdk5 前是手动装箱和拆箱</span><br><span class="hljs-comment">//手动装箱 int-&gt;Integer</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(n1);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer1</span> <span class="hljs-operator">=</span> Integer.valueOf(n1);<span class="hljs-comment">//两种方式都可以 都是手动装箱</span><br><span class="hljs-comment">//手动拆箱</span><br><span class="hljs-comment">//Integer -&gt; int</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> integer.intValue();<br><span class="hljs-comment">//jdk5 后，就可以自动装箱和自动拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-comment">//自动装箱 int-&gt;Integer</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer2</span> <span class="hljs-operator">=</span> n2; <span class="hljs-comment">//底层使用的是 Integer.valueOf(n2)</span><br><span class="hljs-comment">//自动拆箱 Integer-&gt;int</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> integer2; <span class="hljs-comment">//底层仍然使用的是 intValue()方法</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="13-1-2包装类之间的转化"><a href="#13-1-2包装类之间的转化" class="headerlink" title="13.1.2包装类之间的转化"></a>13.1.2包装类之间的转化</h3><p>案例演示, 以 Integer 和 String 转换为例，其它类似:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.wrapper;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment">* <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WrapperVSString</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//包装类(Integer)-&gt;String</span><br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<span class="hljs-comment">//自动装箱</span><br>  <span class="hljs-comment">//方式 1</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">//方式 2</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> i.toString();<br>  <span class="hljs-comment">//方式 3</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> String.valueOf(i);<br>  <span class="hljs-comment">//String -&gt; 包装类(Integer)</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345&quot;</span>;<br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> Integer.parseInt(str4);<span class="hljs-comment">//使用到自动装箱</span><br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(str4);<span class="hljs-comment">//构造器</span><br>  System.out.println(<span class="hljs-string">&quot;ok~~&quot;</span>);<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>



<h3 id="13-1-3Integer-类和-Character类的常用方法"><a href="#13-1-3Integer-类和-Character类的常用方法" class="headerlink" title="13.1.3Integer 类和 Character类的常用方法"></a>13.1.3Integer 类和 Character类的常用方法</h3><p>public class WrapperMethod {<br>public static void main(String[] args) {<br>System.out.println(Character.isDigit(‘a’));&#x2F;&#x2F;判断是不是数字<br>System.out.println(Character.isLetter(‘a’));&#x2F;&#x2F;判断是不是字母<br>System.out.println(Character.isUpperCase(‘a’));&#x2F;&#x2F;判断是不是大写<br>System.out.println(Character.isLowerCase(‘a’));&#x2F;&#x2F;判断是不是小写<br>System.out.println(Character.isWhitespace(‘a’));&#x2F;&#x2F;判断是不是空格<br>System.out.println(Character.toUpperCase(‘a’));&#x2F;&#x2F;转成大写<br>System.out.println(Character.toLowerCase(‘A’));&#x2F;&#x2F;转成小写</p>
<h3 id="13-1-4面试题"><a href="#13-1-4面试题" class="headerlink" title="13.1.4面试题"></a>13.1.4面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WrapperExercise02</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br>System.out.println(i == j); <span class="hljs-comment">//False</span><br><span class="hljs-comment">//所以，这里主要是看范围 -128 ~ 127 就是直接返回</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回</span><br><span class="hljs-comment">//2. 如果不在 -128~127,就直接 new Integer(i)</span><br><span class="hljs-comment">public static Integer valueOf(int i) &#123;</span><br><span class="hljs-comment">if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="hljs-comment">return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="hljs-comment">return new Integer(i);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//底层 Integer.valueOf(1); -&gt; 阅读源码</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//底层 Integer.valueOf(1);</span><br>System.out.println(m == n); <span class="hljs-comment">//T</span><br><span class="hljs-comment">//所以，这里主要是看范围 -128 ~ 127 就是直接返回</span><br><span class="hljs-comment">//，否则，就 new Integer(xx);</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<span class="hljs-comment">//底层 Integer.valueOf(1);</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<span class="hljs-comment">//底层 Integer.valueOf(1);</span><br>System.out.println(x == y);<span class="hljs-comment">//False</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="13-2-String-类（双引号括起来）"><a href="#13-2-String-类（双引号括起来）" class="headerlink" title="13.2 String 类（双引号括起来）"></a>13.2 String 类（双引号括起来）</h2><h3 id="13-2-1-String-类的理解和创建对象"><a href="#13-2-1-String-类的理解和创建对象" class="headerlink" title="13.2.1 String 类的理解和创建对象"></a>13.2.1 String 类的理解和创建对象</h3><p>字符串常量用双引号扩起的字符序列 ： “你好”，”12.97”等</p>
<p>使用Unicode编码 一个字符（不区分字母还是汉子)占两个字节</p>
<p>String 类常用构造器（看手册）</p>
<p>&#x2F;&#x2F;1.String 对象用于保存字符串，也就是一组字符序列<br>&#x2F;&#x2F;2. “jack” 字符串常量, 双引号括起的字符序列<br>&#x2F;&#x2F;3. 字符串的字符使用 Unicode 字符编码，一个字符(不区分字母还是汉字)占两个字节<br>&#x2F;&#x2F;4. String 类有很多构造器，构造器的重载<br>&#x2F;&#x2F; 常用的有 String s1 &#x3D; new String(); &#x2F;&#x2F;<br>&#x2F;&#x2F;String s2 &#x3D; new String(String original);<br>&#x2F;&#x2F;String s3 &#x3D; new String(char[] a);<br>&#x2F;&#x2F;String s4 &#x3D; new String(char[] a,int startIndex,int count)<br>&#x2F;&#x2F;String s5 &#x3D; new String(byte[] b)<br>&#x2F;&#x2F;5. String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】<br>&#x2F;&#x2F; 接口 Comparable [String 对象可以比较大小]<br>&#x2F;&#x2F;6. String 是 final 类，不能被其他的类继承<br>&#x2F;&#x2F;7. String 有属性 private final char value[]; 用于存放字符串内容<br>&#x2F;&#x2F;8. 一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向<br>&#x2F;&#x2F; 新的地址，但是单个字符内容是可以变化</p>
<h3 id="13-2-2创建String对象的两种方式"><a href="#13-2-2创建String对象的两种方式" class="headerlink" title="13.2.2创建String对象的两种方式"></a>13.2.2创建String对象的两种方式</h3><p>方式一：直接赋值 String s &#x3D; “ashndkjand”;</p>
<p>方式二: 调用构造器 String s &#x3D; new String( “ashndkjand”);</p>
<h3 id="13-2-3两种方式的区别"><a href="#13-2-3两种方式的区别" class="headerlink" title="13.2.3两种方式的区别"></a>13.2.3两种方式的区别</h3><p>方式一：先从常量池找是否有 “ashndkjand”数据空间，若有则直接指向，若没有则在常量池中创建，然后指向</p>
<p>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的”ashndkjand”空间。如果常量池中没有 “ashndkjand”空间，重新创建，如果有value直接指向常量池， s最终指向的对空间</p>
<h2 id="13-3字符串的特性"><a href="#13-3字符串的特性" class="headerlink" title="13.3字符串的特性"></a>13.3字符串的特性</h2><p>​	<img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220202143350591.png" srcset="/img/loading.gif" lazyload alt="image-20220202143350591"></p>
<h2 id="13-4-String类的常见方法"><a href="#13-4-String类的常见方法" class="headerlink" title="13.4 String类的常见方法"></a>13.4 String类的常见方法</h2><p>​	String类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringMethod01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>**<span class="hljs-comment">//1. equals 前面已经讲过了. 比较内容是否相同，区分大小写**</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>System.out.println(str1.equals(str2));<span class="hljs-comment">//</span><br>**<span class="hljs-comment">// 2.equalsIgnoreCase 忽略大小写的判断内容是否相等**</span><br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;johN&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;john&quot;</span>.equalsIgnoreCase(username)) &#123;<br>System.out.println(<span class="hljs-string">&quot;Success!&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Failure!&quot;</span>);<br>&#125;<br>**<span class="hljs-comment">// 3.length 获取字符的个数，字符串的长度**</span><br>System.out.println(<span class="hljs-string">&quot;韩顺平&quot;</span>.length());<br>**<span class="hljs-comment">// 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1**</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;wer@terwe@g&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> s1.indexOf(<span class="hljs-string">&#x27;@&#x27;</span>);<br>System.out.println(index);<span class="hljs-comment">// 3</span><br>System.out.println(<span class="hljs-string">&quot;weIndex=&quot;</span> + s1.indexOf(<span class="hljs-string">&quot;we&quot;</span>));<span class="hljs-comment">//0</span><br>**<span class="hljs-comment">// 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1**</span><br>s1 = <span class="hljs-string">&quot;wer@terwe@g@&quot;</span>;<br>index = s1.lastIndexOf(<span class="hljs-string">&#x27;@&#x27;</span>);<br>System.out.println(index);<span class="hljs-comment">//11</span><br>System.out.println(<span class="hljs-string">&quot;ter 的位置=&quot;</span> + s1.lastIndexOf(<span class="hljs-string">&quot;ter&quot;</span>));<span class="hljs-comment">//4</span><br>**<span class="hljs-comment">// 6.substring 截取指定范围的子串**</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello,张三&quot;</span>;<br><span class="hljs-comment">//下面 name.substring(6) 从索引 6 开始截取后面所有的内容</span><br>System.out.println(name.substring(<span class="hljs-number">6</span>));<span class="hljs-comment">//截取后面的字符</span><br><span class="hljs-comment">//name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置</span><br>System.out.println(name.substring(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>));<span class="hljs-comment">//llo</span><br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringMethod02</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>**<span class="hljs-comment">// 1.toUpperCase 转换成大写**</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;heLLo&quot;</span>;<br>System.out.println(s.toUpperCase());<span class="hljs-comment">//HELLO</span><br>**<span class="hljs-comment">// 2.toLowerCase**</span><br>System.out.println(s.toLowerCase());<span class="hljs-comment">//hello</span><br>**<span class="hljs-comment">// 3.concat 拼接字符串**</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;宝玉&quot;</span>;<br>s1 = s1.concat(<span class="hljs-string">&quot;林黛玉&quot;</span>).concat(<span class="hljs-string">&quot;薛宝钗&quot;</span>).concat(<span class="hljs-string">&quot;together&quot;</span>);<br>System.out.println(s1);<span class="hljs-comment">//宝玉林黛玉薛宝钗 together</span><br>**<span class="hljs-comment">// 4.replace 替换字符串中的字符**</span><br>s1 = <span class="hljs-string">&quot;宝玉 and 林黛玉 林黛玉 林黛玉&quot;</span>;<br><span class="hljs-comment">//在 s1 中，将 所有的 林黛玉 替换成薛宝钗</span><br><span class="hljs-comment">// 老韩解读: s1.replace() 方法执行后，返回的结果才是替换过的. // 注意对 s1 没有任何影响</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s11</span> <span class="hljs-operator">=</span> s1.replace(<span class="hljs-string">&quot;宝玉&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>);<br>System.out.println(s1);<span class="hljs-comment">//宝玉 and 林黛玉 林黛玉 林黛玉</span><br>System.out.println(s11);<span class="hljs-comment">//jack and 林黛玉 林黛玉 林黛玉</span><br>**<span class="hljs-comment">// 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\等**</span><br><span class="hljs-type">String</span> <span class="hljs-variable">poem</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;</span>;<br><span class="hljs-comment">//老韩解读：</span><br><span class="hljs-comment">// 1. 以 , 为标准对 poem 进行分割 , 返回一个数组</span><br><span class="hljs-comment">// 2. 在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \</span><br>String[] split = poem.split(<span class="hljs-string">&quot;,&quot;</span>);<br>poem = <span class="hljs-string">&quot;E:\\aaa\\bbb&quot;</span>;<br>split = poem.split(<span class="hljs-string">&quot;\\\\&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;==分割后内容===&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; split.length; i++) &#123;<br>System.out.println(split[i]);<br>&#125;<br>**<span class="hljs-comment">// 6.toCharArray 转换成字符数组**</span><br>s = <span class="hljs-string">&quot;happy&quot;</span>;<br><span class="hljs-type">char</span>[] chs = s.toCharArray();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>System.out.println(chs[i]);<br>&#125;<br>**<span class="hljs-comment">// 7.compareTo 比较两个字符串的大小，如果前者大，**</span><br>**<span class="hljs-comment">// 则返回正数，后者大，则返回负数，如果相等，返回 0**</span><br><span class="hljs-comment">// 老韩解读</span><br><span class="hljs-comment">// (1) 如果长度相同，并且每个字符也相同，就返回 0</span><br><span class="hljs-comment">// (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小</span><br><span class="hljs-comment">// 就返回 if (c1 != c2) &#123;</span><br><span class="hljs-comment">// return c1 - c2;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// (3) 如果前面的部分都相同，就返回 str1.len - str2.len</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jcck&quot;</span>;<span class="hljs-comment">// len = 3</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jack&quot;</span>;<span class="hljs-comment">// len = 4</span><br>System.out.println(a.compareTo(b)); <span class="hljs-comment">// 返回值是 &#x27;c&#x27; - &#x27;a&#x27; = 2 的值</span><br>**<span class="hljs-comment">// 8.format 格式字符串**</span><br><span class="hljs-comment">/* 占位符有:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">%s 字符串 %c 字符 %d 整型 %.2f 浮点型</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;john&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">56.857</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br><br><span class="hljs-comment">//将所有的信息都拼接在一个字符串. String info =</span><br><span class="hljs-string">&quot;我的姓名是&quot;</span> + name + <span class="hljs-string">&quot;年龄是&quot;</span> + age + <span class="hljs-string">&quot;,成绩是&quot;</span> + score + <span class="hljs-string">&quot;性别是&quot;</span> + gender + <span class="hljs-string">&quot;。希望大家喜欢我！</span><br><span class="hljs-string">&quot;</span>;<br>System.out.println(info);<br><span class="hljs-comment">//老韩解读</span><br><span class="hljs-comment">//1. %s , %d , %.2f %c 称为占位符</span><br><span class="hljs-comment">//2. 这些占位符由后面变量来替换</span><br><span class="hljs-comment">//3. %s 表示后面由 字符串来替换</span><br><span class="hljs-comment">//4. %d 是整数来替换</span><br><span class="hljs-comment">//5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理</span><br><span class="hljs-comment">//6. %c 使用 char 类型来替换</span><br><span class="hljs-type">String</span> <span class="hljs-variable">formatStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">info2</span> <span class="hljs-operator">=</span> String.format(formatStr, name, age, score, gender);<br>System.out.println(<span class="hljs-string">&quot;info2=&quot;</span> + info2);<br>    <br>   <span class="hljs-comment">//7 split()（分裂）根据匹配给定的正则表达式来拆分字符串</span><br>   <span class="hljs-comment">//注意、.、$、|、等转义字符，必须加\\ 注意：多个分隔符可以用|作为连字符 </span><br>    <span class="hljs-keyword">public</span> String[] split(String regex, <span class="hljs-type">int</span> limit)<br>        <span class="hljs-comment">//regex 正则表达式分隔符 limit 分割的份数</span><br>        <span class="hljs-comment">//return 字符串</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="13-5-StringBuffer类"><a href="#13-5-StringBuffer类" class="headerlink" title="13.5 StringBuffer类"></a>13.5 StringBuffer类</h2><h3 id="13-5-1基本介绍"><a href="#13-5-1基本介绍" class="headerlink" title="13.5.1基本介绍"></a>13.5.1基本介绍</h3><p>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删。</p>
<p>很多方法与String相同 ，但StringBuilder是可变长度的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuffer01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//老韩解读</span><br><span class="hljs-comment">//1. StringBuffer 的直接父类 是 AbstractStringBuilder</span><br><span class="hljs-comment">//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化</span><br><span class="hljs-comment">//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final</span><br><span class="hljs-comment">// 该 value 数组存放 字符串内容，引出存放在堆中的</span><br><span class="hljs-comment">//4. StringBuffer 是一个 final 类，不能被继承</span><br><span class="hljs-comment">//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)</span><br><span class="hljs-comment">// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="13-5-2-String-vs-StringBuffer"><a href="#13-5-2-String-vs-StringBuffer" class="headerlink" title="13.5.2 String vs StringBuffer"></a>13.5.2 String vs StringBuffer</h3><p>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低</p>
<p>StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更改内容，不用每次都更新地址效率较高</p>
<h3 id="13-5-3-两者的互相转换"><a href="#13-5-3-两者的互相转换" class="headerlink" title="13.5.3 两者的互相转换"></a>13.5.3 两者的互相转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringAndStringBuffer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//看 String——&gt;StringBuffer</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello tom&quot;</span>;<br><span class="hljs-comment">//方式 1 使用构造器</span><br><span class="hljs-comment">//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(str);<br><span class="hljs-comment">//方式 2 使用的是 append 方法</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>stringBuffer1 = stringBuffer1.append(str);<br><span class="hljs-comment">//看看 StringBuffer -&gt;String</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;韩顺平教育&quot;</span>);<br><span class="hljs-comment">//方式 1 使用 StringBuffer 提供的 toString 方法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> stringBuffer3.toString();<br><span class="hljs-comment">//方式 2: 使用构造器来搞定</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(stringBuffer3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="13-5-4-StringBuffer-类常见方法"><a href="#13-5-4-StringBuffer-类常见方法" class="headerlink" title="13.5.4 StringBuffer 类常见方法"></a>13.5.4 StringBuffer 类常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBufferMethod</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">//增</span><br>s.append(<span class="hljs-string">&#x27;,&#x27;</span>);<span class="hljs-comment">// &quot;hello,&quot;</span><br>s.append(<span class="hljs-string">&quot;张三丰&quot;</span>);<span class="hljs-comment">//&quot;hello,张三丰&quot;</span><br>s.append(<span class="hljs-string">&quot;赵敏&quot;</span>).append(<span class="hljs-number">100</span>).append(<span class="hljs-literal">true</span>).append(<span class="hljs-number">10.5</span>);<span class="hljs-comment">//&quot;hello,张三丰赵敏 100true10.5&quot;</span><br>    System.out.println(s);<span class="hljs-comment">//&quot;hello,张三丰赵敏 100true10.5&quot;</span><br><span class="hljs-comment">//删</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</span><br><span class="hljs-comment">* 解读: 删除 11~14 的字符 [11, 14)</span><br><span class="hljs-comment">*/</span><br>s.delete(<span class="hljs-number">11</span>, <span class="hljs-number">14</span>);<br>System.out.println(s);<span class="hljs-comment">//&quot;hello,张三丰赵敏 true10.5&quot;</span><br><span class="hljs-comment">//改</span><br><span class="hljs-comment">//老韩解读，使用 周芷若 替换 索引 9-11 的字符 [9,11)</span><br>s.replace(<span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-string">&quot;周芷若&quot;</span>);<br>System.out.println(s);<span class="hljs-comment">//&quot;hello,张三丰周芷若 true10.5&quot;</span><br><span class="hljs-comment">//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">indexOf</span> <span class="hljs-operator">=</span> s.indexOf(<span class="hljs-string">&quot;张三丰&quot;</span>);<br>System.out.println(indexOf);<span class="hljs-comment">//6</span><br><span class="hljs-comment">//插</span><br><br><span class="hljs-comment">//老韩解读，在索引为 9 的位置插入 &quot;赵敏&quot;,原来索引为 9 的内容自动后移</span><br>s.insert(<span class="hljs-number">9</span>, <span class="hljs-string">&quot;赵敏&quot;</span>);<br>System.out.println(s);<span class="hljs-comment">//&quot;hello,张三丰赵敏周芷若 true10.5&quot;</span><br><span class="hljs-comment">//长度</span><br>System.out.println(s.length());<span class="hljs-comment">//22</span><br>System.out.println(s);<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h2 id="13-6-StringBuilder-线程不安全的StringBuffer"><a href="#13-6-StringBuilder-线程不安全的StringBuffer" class="headerlink" title="13.6 StringBuilder 线程不安全的StringBuffer"></a>13.6 StringBuilder 线程不安全的StringBuffer</h2><h2 id="13-7-Math-类"><a href="#13-7-Math-类" class="headerlink" title="13.7 Math 类"></a>13.7 Math 类</h2><p>Math类包含用于执行基本数学运算的方法，如初等函数、对数、平方根和三角函数。</p>
<p>均为静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathMethod</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//看看 Math 常用的方法(静态方法)</span><br><span class="hljs-comment">//1.abs 绝对值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">abs</span> <span class="hljs-operator">=</span> Math.abs(-<span class="hljs-number">9</span>);<br>System.out.println(abs);<span class="hljs-comment">//9</span><br><span class="hljs-comment">//2.pow 求幂</span><br><span class="hljs-type">double</span> <span class="hljs-variable">pow</span> <span class="hljs-operator">=</span> Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<span class="hljs-comment">//2 的 4 次方</span><br>System.out.println(pow);<span class="hljs-comment">//16</span><br><span class="hljs-comment">//3.ceil 向上取整,返回&gt;=该参数的最小整数(转成 double);</span><br><span class="hljs-type">double</span> <span class="hljs-variable">ceil</span> <span class="hljs-operator">=</span> Math.ceil(<span class="hljs-number">3.9</span>);<br>System.out.println(ceil);<span class="hljs-comment">//4.0</span><br><span class="hljs-comment">//4.floor 向下取整，返回&lt;=该参数的最大整数(转成 double)</span><br><span class="hljs-type">double</span> <span class="hljs-variable">floor</span> <span class="hljs-operator">=</span> Math.floor(<span class="hljs-number">4.001</span>);<br>System.out.println(floor);<span class="hljs-comment">//4.0</span><br><span class="hljs-comment">//5.round 四舍五入 Math.floor(该参数+0.5)</span><br><span class="hljs-type">long</span> <span class="hljs-variable">round</span> <span class="hljs-operator">=</span> Math.round(<span class="hljs-number">5.51</span>);<br>System.out.println(round);<span class="hljs-comment">//6</span><br><span class="hljs-comment">//6.sqrt 求开方</span><br><span class="hljs-type">double</span> <span class="hljs-variable">sqrt</span> <span class="hljs-operator">=</span> Math.sqrt(<span class="hljs-number">9.0</span>);<br>System.out.println(sqrt);<span class="hljs-comment">//3.0</span><br><span class="hljs-comment">//7.random 求随机数</span><br><span class="hljs-comment">// random 返回的是 0 &lt;= x &lt; 1 之间的一个随机小数</span><br><span class="hljs-comment">// 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7</span><br><span class="hljs-comment">// 即返回一个数 x 2 &lt;= x &lt;= 7</span><br><span class="hljs-comment">// 解读 Math.random() * (b-a) 返回的就是 0 &lt;= 数 &lt;= b-a</span><br><span class="hljs-comment">// (1) (int)(a) &lt;= x &lt;= (int)(a + Math.random() * (b-a +1) )</span><br><span class="hljs-comment">// (2) 使用具体的数给小伙伴介绍 a = 2 b = 7</span><br><span class="hljs-comment">// (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)</span><br><span class="hljs-comment">// Math.random()*6 返回的是 0 &lt;= x &lt; 6 小数</span><br><span class="hljs-comment">// 2 + Math.random()*6 返回的就是 2&lt;= x &lt; 8 小数</span><br><span class="hljs-comment">// (int)(2 + Math.random()*6) = 2 &lt;= x &lt;= 7</span><br><span class="hljs-comment">// (3) 公式就是 (int)(a + Math.random() * (b-a +1) )</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>System.out.println((<span class="hljs-type">int</span>)(<span class="hljs-number">2</span> + Math.random() * (<span class="hljs-number">7</span> - <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)));<br>&#125;<br><span class="hljs-comment">//max , min 返回最大值和最小值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">45</span>, <span class="hljs-number">90</span>);<br>System.out.println(<span class="hljs-string">&quot;min=&quot;</span> + min);<br>System.out.println(<span class="hljs-string">&quot;max=&quot;</span> + max);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="13-8-Arrays类"><a href="#13-8-Arrays类" class="headerlink" title="13.8 Arrays类"></a>13.8 Arrays类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraysMethod01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Integer[] integers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">90</span>&#125;;<br><span class="hljs-comment">//遍历数组</span><br><span class="hljs-comment">// for(int i = 0; i &lt; integers.length; i++) &#123;</span><br><span class="hljs-comment">// System.out.println(integers[i]);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//直接使用 Arrays.toString 方法，显示数组</span><br><span class="hljs-comment">// System.out.println(Arrays.toString(integers));//</span><br><span class="hljs-comment">//演示 sort 方法的使用</span><br>Integer arr[] = &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">89</span>&#125;;<br><span class="hljs-comment">//进行排序</span><br><span class="hljs-comment">//老韩解读</span><br><span class="hljs-comment">//1. 可以直接使用冒泡排序 , 也可以直接使用 Arrays 提供的 sort 方法排序</span><br><span class="hljs-comment">//2. 因为数组是引用类型，所以通过 sort 排序后，会直接影响到 实参 arr</span><br><span class="hljs-comment">//3. sort 重载的，也可以通过传入一个接口 Comparator 实现定制排序</span><br><span class="hljs-comment">//4. 调用 定制排序 时，传入两个参数 (1) 排序的数组 arr</span><br><span class="hljs-comment">// (2) 实现了 Comparator 接口的匿名内部类 , 要求实现 compare 方法</span><br><span class="hljs-comment">//5. 先演示效果，再解释</span><br><span class="hljs-comment">//6. 这里体现了接口编程的方式 , 看看源码，就明白</span><br><span class="hljs-comment">// 源码分析</span><br><span class="hljs-comment">//(1) Arrays.sort(arr, new Comparator()</span><br><span class="hljs-comment">//(2) 最终到 TimSort 类的 private static &lt;T&gt; void binarySort(T[] a, int lo, int hi, int start, // Comparator&lt;? super T&gt; c)()</span><br><span class="hljs-comment">//(3) 执行到 binarySort 方法的代码, 会根据动态绑定机制 c.compare()执行我们传入的</span><br><span class="hljs-comment">// 匿名内部类的 compare ()</span><br><span class="hljs-comment">// while (left &lt; right) &#123;</span><br><span class="hljs-comment">// int mid = (left + right) &gt;&gt;&gt; 1;</span><br><span class="hljs-comment">// if (c.compare(pivot, a[mid]) &lt; 0)</span><br><span class="hljs-comment">// right = mid;</span><br><span class="hljs-comment">// else</span><br><span class="hljs-comment">// left = mid + 1;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//(4) new Comparator() &#123;</span><br><span class="hljs-comment">// @Override</span><br><span class="hljs-comment">// public int compare(Object o1, Object o2) &#123;</span><br><span class="hljs-comment">// Integer i1 = (Integer) o1;</span><br><span class="hljs-comment">// Integer i2 = (Integer) o2;</span><br><span class="hljs-comment">// return i2 - i1;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//(5) public int compare(Object o1, Object o2) 返回的值&gt;0 还是 &lt;0</span><br><span class="hljs-comment">// 会影响整个排序结果, 这就充分体现了 接口编程+动态绑定+匿名内部类的综合使用</span><br><span class="hljs-comment">// 将来的底层框架和源码的使用方式，会非常常见</span><br><span class="hljs-comment">//Arrays.sort(arr); // 默认排序方法</span><br><span class="hljs-comment">//定制排序</span><br>Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> (Integer) o1;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> (Integer) o2;<br><span class="hljs-keyword">return</span> i2 - i1;<br>&#125;<br>&#125;);<br>System.out.println(<span class="hljs-string">&quot;===排序后===&quot;</span>);<br>System.out.println(Arrays.toString(arr));<span class="hljs-comment">//</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">package</span> com.hspedu.arrays_;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment">* <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraysSortCustom</span> &#123;<br>韩顺平循序渐进学 Java 零基础<br>第 <span class="hljs-number">575</span>页<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>&#125;;<br><span class="hljs-comment">//bubble01(arr);</span><br>bubble02(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> (Integer) o1;<br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> (Integer) o2;<br><span class="hljs-keyword">return</span> i2 - i1;<span class="hljs-comment">// return i2 - i1;</span><br>&#125;<br>&#125;);<br>System.out.println(<span class="hljs-string">&quot;==定制排序后的情况==&quot;</span>);<br>System.out.println(Arrays.toString(arr));<br>&#125;<br><span class="hljs-comment">//使用冒泡完成排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble01</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br><span class="hljs-comment">//从小到大</span><br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>韩顺平循序渐进学 Java 零基础<br>第 <span class="hljs-number">576</span>页<br>temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//结合冒泡 + 定制</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble02</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, Comparator c)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br><span class="hljs-comment">//数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定</span><br><span class="hljs-keyword">if</span> (c.compare(arr[j], arr[j + <span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>) &#123;<br>temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.hspedu.arrays_;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment">* <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraysMethod02</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">90</span>, <span class="hljs-number">123</span>, <span class="hljs-number">567</span>&#125;;<br><span class="hljs-comment">// binarySearch 通过二分搜索法进行查找，要求必须排好</span><br><span class="hljs-comment">// 老韩解读</span><br><span class="hljs-comment">//1. 使用 binarySearch 二叉查找</span><br><span class="hljs-comment">//2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch</span><br><span class="hljs-comment">//3. 如果数组中不存在该元素，就返回 return -(low + 1); // key not found. int index = Arrays.binarySearch(arr, 567);</span><br>System.out.println(<span class="hljs-string">&quot;index=&quot;</span> + index);<br><span class="hljs-comment">//copyOf 数组元素的复制</span><br><span class="hljs-comment">// 老韩解读</span><br><span class="hljs-comment">//1. 从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中</span><br><span class="hljs-comment">//2. 如果拷贝的长度 &gt; arr.length 就在新数组的后面 增加 null</span><br><span class="hljs-comment">//3. 如果拷贝长度 &lt; 0 就抛出异常 NegativeArraySizeException</span><br><span class="hljs-comment">//4. 该方法的底层使用的是 System.arraycopy()</span><br>Integer[] newArr = Arrays.copyOf(arr, arr.length);<br>System.out.println(<span class="hljs-string">&quot;==拷贝执行完毕后==&quot;</span>);<br>韩顺平循序渐进学 Java 零基础<br>第 <span class="hljs-number">578</span>页<br>System.out.println(Arrays.toString(newArr));<br><span class="hljs-comment">//ill 数组元素的填充</span><br>Integer[] num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">//老韩解读</span><br><span class="hljs-comment">//1. 使用 99 去填充 num 数组，可以理解成是替换原理的元素</span><br>Arrays.fill(num, <span class="hljs-number">99</span>);<br>System.out.println(<span class="hljs-string">&quot;==num 数组填充后==&quot;</span>);<br>System.out.println(Arrays.toString(num));<br><span class="hljs-comment">//equals 比较两个数组元素内容是否完全一致</span><br>Integer[] arr2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">90</span>, <span class="hljs-number">123</span>&#125;;<br><span class="hljs-comment">//老韩解读</span><br><span class="hljs-comment">//1. 如果 arr 和 arr2 数组的元素一样，则方法 true;</span><br><span class="hljs-comment">//2. 如果不是完全一样，就返回 false</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">equals</span> <span class="hljs-operator">=</span> Arrays.equals(arr, arr2);<br>System.out.println(<span class="hljs-string">&quot;equals=&quot;</span> + equals);<br><span class="hljs-comment">//asList 将一组值，转换成 list</span><br><span class="hljs-comment">//老韩解读</span><br><span class="hljs-comment">//1. asList 方法，会将 (2,3,4,5,6,1)数据转成一个 List 集合</span><br><span class="hljs-comment">//2. 返回的 asList 编译类型 List(接口)</span><br><span class="hljs-comment">//3. asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的</span><br><span class="hljs-comment">// 静态内部类 private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="hljs-comment">// implements RandomAccess, java.io.Serializable</span><br><span class="hljs-type">List</span> <span class="hljs-variable">asList</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>);<br>System.out.println(<span class="hljs-string">&quot;asList=&quot;</span> + asList);<br>System.out.println(<span class="hljs-string">&quot;asList 的运行类型&quot;</span> + asList.getClass());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="13-9-System类"><a href="#13-9-System类" class="headerlink" title="13.9 System类"></a>13.9 System类</h2><p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220202152301760.png" srcset="/img/loading.gif" lazyload alt="image-20220202152301760"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hspedu.system_;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> 韩顺平</span><br><span class="hljs-comment">* <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">System_</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//exit 退出当前程序</span><br><span class="hljs-comment">// System.out.println(&quot;ok1&quot;);</span><br><span class="hljs-comment">// //老韩解读</span><br><span class="hljs-comment">// //1. exit(0) 表示程序退出</span><br><span class="hljs-comment">// //2. 0 表示一个状态 , 正常的状态</span><br><span class="hljs-comment">// System.exit(0);//</span><br><span class="hljs-comment">// System.out.println(&quot;ok2&quot;);</span><br><span class="hljs-comment">//arraycopy ：复制数组元素，比较适合底层调用，</span><br><span class="hljs-comment">// 一般使用 Arrays.copyOf 完成复制数组</span><br><span class="hljs-type">int</span>[] src=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] dest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">// dest 当前是 &#123;0,0,0&#125;</span><br><span class="hljs-comment">//老韩解读</span><br><span class="hljs-comment">//1. 主要是搞清楚这五个参数的含义</span><br><span class="hljs-comment">//2. // 源数组</span><br>韩顺平循序渐进学 Java 零基础<br>第 <span class="hljs-number">586</span>页<br><span class="hljs-comment">// * @param src the source array. // srcPos： 从源数组的哪个索引位置开始拷贝</span><br><span class="hljs-comment">// * @param srcPos starting position in the source array. // dest : 目标数组，即把源数组的数据拷贝到哪个数组</span><br><span class="hljs-comment">// * @param dest the destination array. // destPos: 把源数组的数据拷贝到 目标数组的哪个索引</span><br><span class="hljs-comment">// * @param destPos starting position in the destination data. // length: 从源数组拷贝多少个数据到目标数组</span><br><span class="hljs-comment">// * @param length the number of array elements to be copied. System.arraycopy(src, 0, dest, 0, src.length);</span><br><span class="hljs-comment">// int[] src=&#123;1,2,3&#125;;</span><br>System.out.println(<span class="hljs-string">&quot;dest=&quot;</span> + Arrays.toString(dest));<span class="hljs-comment">//[1, 2, 3]</span><br><span class="hljs-comment">//currentTimeMillens:返回当前时间距离 1970-1-1 的毫秒数</span><br><span class="hljs-comment">// 老韩解读:</span><br>System.out.println(System.currentTimeMillis());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="13-10-BigInteger和BigDecimal类"><a href="#13-10-BigInteger和BigDecimal类" class="headerlink" title="13.10 BigInteger和BigDecimal类"></a>13.10 BigInteger和BigDecimal类</h2><p>应用场景：</p>
<p> BigInteger适合保存较大的整形</p>
<p>BigDecimal适合保存精度更高的浮点型</p>
<p>两者的常见方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BigInteger_</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//当我们编程中，需要处理很大的整数，long 不够用</span><br><span class="hljs-comment">//可以使用 BigInteger 的类来搞定</span><br><span class="hljs-comment">// long l = 23788888899999999999999999999l;</span><br><span class="hljs-comment">// System.out.println(&quot;l=&quot; + l);</span><br><span class="hljs-type">BigInteger</span> <span class="hljs-variable">bigInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(<span class="hljs-string">&quot;23788888899999999999999999999&quot;</span>);<br><span class="hljs-type">BigInteger</span> <span class="hljs-variable">bigInteger2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br><span class="hljs-title class_">BigInteger</span>(<span class="hljs-string">&quot;10099999999999999999999999999999999999999999999999999999999999999999999999999999999&quot;</span>);<br>System.out.println(bigInteger);<br><span class="hljs-comment">//解读</span><br><span class="hljs-comment">//1. 在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /</span><br><span class="hljs-comment">//2. 可以创建一个 要操作的 BigInteger 然后进行相应操作</span><br><span class="hljs-type">BigInteger</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> bigInteger.add(bigInteger2);<br>System.out.println(add);<span class="hljs-comment">//</span><br><span class="hljs-type">BigInteger</span> <span class="hljs-variable">subtract</span> <span class="hljs-operator">=</span> bigInteger.subtract(bigInteger2);<br>System.out.println(subtract);<span class="hljs-comment">//减</span><br><span class="hljs-type">BigInteger</span> <span class="hljs-variable">multiply</span> <span class="hljs-operator">=</span> bigInteger.multiply(bigInteger2);<br>System.out.println(multiply);<span class="hljs-comment">//乘</span><br><span class="hljs-type">BigInteger</span> <span class="hljs-variable">divide</span> <span class="hljs-operator">=</span> bigInteger.divide(bigInteger2);<br>System.out.println(divide);<span class="hljs-comment">//除</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BigDecimal_</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//当我们需要保存一个精度很高的数时，double 不够用</span><br><span class="hljs-comment">//可以是 BigDecimal</span><br><span class="hljs-comment">// double d = 1999.11111111111999999999999977788d;</span><br><span class="hljs-comment">// System.out.println(d);</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1999.11&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bigDecimal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>System.out.println(bigDecimal);<br><span class="hljs-comment">//老韩解读</span><br><span class="hljs-comment">//1. 如果对 BigDecimal 进行运算，比如加减乘除，需要使用对应的方法</span><br><span class="hljs-comment">//2. 创建一个需要操作的 BigDecimal 然后调用相应的方法即可</span><br>System.out.println(bigDecimal.add(bigDecimal2));<br>System.out.println(bigDecimal.subtract(bigDecimal2));<br>System.out.println(bigDecimal.multiply(bigDecimal2));<br><span class="hljs-comment">//System.out.println(bigDecimal.divide(bigDecimal2));//可能抛出异常 ArithmeticException</span><br><span class="hljs-comment">//在调用 divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING</span><br><span class="hljs-comment">//如果有无限循环小数，就会保留 分子 的精度</span><br>System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="第14章-集合"><a href="#第14章-集合" class="headerlink" title="第14章 集合"></a>第14章 集合</h1><p>Deque是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。</p>
<p>关于Queue的介绍可以看上一篇文章：Java队列Queue使用详解</p>
<p>Deque有三种用途：<br>普通队列(一端进另一端出):<br>Queue queue &#x3D; new LinkedList()或Deque deque &#x3D; new LinkedList()<br>双端队列(两端都可进出)<br>Deque deque &#x3D; new LinkedList()<br>堆栈<br>Deque deque &#x3D; new LinkedList()<br>注意：Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。Deque堆栈操作方法：push()、pop()、peek()。</p>
<p>Deque是一个线性collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。</p>
<p>此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 Deque 实现设计的；在大多数实现中，插入操作不能失败。</p>
<p>下表总结了上述 12 种方法：</p>
<p>第一个元素 (头部)	最后一个元素 (尾部)<br>抛出异常	特殊值	抛出异常	特殊值<br>插入	addFirst(e)	offerFirst(e)	addLast(e)	offerLast(e)<br>删除	removeFirst()	pollFirst()	removeLast()	pollLast()<br>检查	getFirst()	peekFirst()	getLast()	peekLast()<br>Deque接口扩展(继承)了 Queue 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示：</p>
<p>Queue方法	等效Deque方法<br>add(e)	addLast(e)<br>offer(e)	offerLast(e)<br>remove()	removeFirst()<br>poll()	pollFirst()<br>element()	getFirst()<br>peek()	peekFirst()  增加一个方法，可以返回当前栈顶的值, 但是不是真正的 pop</p>
<p>双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 Stack 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示：</p>
<p>堆栈方法	等效Deque方法<br>push(e)	addFirst(e)<br>pop()	removeFirst()<br>peek()	peekFirst(<br>————————————————<br>版权声明：本文为CSDN博主「devnn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/devnn/article/details/82716447">https://blog.csdn.net/devnn/article/details/82716447</a></p>
<p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220221002311468.png" srcset="/img/loading.gif" lazyload alt="image-20220221002311468"></p>
<h2 id="14-1集合的理解与好处"><a href="#14-1集合的理解与好处" class="headerlink" title="14.1集合的理解与好处"></a>14.1集合的理解与好处</h2><p>数组长度固定不能更改 CRUD（增加 (Create)、读取(Retrieve) (重新得到数据)、更新 (Update)和删除 (Delete)增删改查）不方便</p>
<p>集合可以动态保存任意多个对象（底层源码运用扩容机制），提供了一系列方便的方法，add、remove、set、get等</p>
<h2 id="14-2集合的框架体系"><a href="#14-2集合的框架体系" class="headerlink" title="14.2集合的框架体系"></a>14.2集合的框架体系</h2><p>单列集合</p>
<p>add（“tom”）</p>
<p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20211228165026757.png" srcset="/img/loading.gif" lazyload alt="image-20211228165026757"></p>
<p>接口定义方法类会自己具体实现各种方法</p>
<p>双列集合 put（“NO1”,“北京”）</p>
<p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20211228165036103.png" srcset="/img/loading.gif" lazyload alt="image-20211228165036103"></p>
<h2 id="14-3-Collection接口和常用方法"><a href="#14-3-Collection接口和常用方法" class="headerlink" title="14.3 Collection接口和常用方法"></a>14.3 Collection接口和常用方法</h2><p>Collection的实现类 有可以存放重复的元素 有些不可以</p>
<p>​					有些是有序的（list）有些是无序的（set）</p>
<p>Collection接口没有直接的实现子类，是通过子接口set和list来实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection 接口常用方法,以实现子类 ArrayList 来演示. CollectionMethod.java<br><br><span class="hljs-keyword">package</span> com.hspedu.collection_;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionMethod</span> &#123;<br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-comment">// add:添加单个元素</span><br>list.add(<span class="hljs-string">&quot;jack&quot;</span>);<br>list.add(<span class="hljs-number">10</span>);<span class="hljs-comment">//list.add(new Integer(10))</span><br>list.add(<span class="hljs-literal">true</span>);<br>System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">// remove:删除指定元素</span><br><span class="hljs-comment">//list.remove(0);//删除第一个元素</span><br>list.remove(<span class="hljs-literal">true</span>);<span class="hljs-comment">//指定删除某个元素</span><br>System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">// contains:查找元素是否存在</span><br>System.out.println(list.contains(<span class="hljs-string">&quot;jack&quot;</span>));<span class="hljs-comment">//T</span><br><span class="hljs-comment">// size:获取元素个数</span><br>System.out.println(list.size());<span class="hljs-comment">//2</span><br><span class="hljs-comment">// isEmpty:判断是否为空</span><br>System.out.println(list.isEmpty());<span class="hljs-comment">//F</span><br><span class="hljs-comment">// clear:清空</span><br>list.clear();<br>System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">// addAll:添加多个元素</span><br><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>list2.add(<span class="hljs-string">&quot;红楼梦&quot;</span>);<br>list2.add(<span class="hljs-string">&quot;三国演义&quot;</span>);<br>list.addAll(list2);<br>System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<br><span class="hljs-comment">// containsAll:查找多个元素是否都存在</span><br>System.out.println(list.containsAll(list2));<span class="hljs-comment">//T</span><br><span class="hljs-comment">// removeAll：删除多个元素</span><br>list.add(<span class="hljs-string">&quot;聊斋&quot;</span>);<br>list.removeAll(list2);<br>System.out.println(<span class="hljs-string">&quot;list=&quot;</span> + list);<span class="hljs-comment">//[聊斋]</span><br><span class="hljs-comment">// 说明：以 ArrayList 实现类来演示. &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="第21章-网络编程"><a href="#第21章-网络编程" class="headerlink" title="第21章 网络编程"></a>第21章 网络编程</h1><p>查询 API 的一般流程是：找包→找类或接口→查看类或接口→找方法或变量</p>
<h3 id="21-1网络的相关概念"><a href="#21-1网络的相关概念" class="headerlink" title="21.1网络的相关概念"></a>21.1网络的相关概念</h3><p>计算机网络</p>
<h3 id="21-2InetAddress类"><a href="#21-2InetAddress类" class="headerlink" title="21.2InetAddress类"></a>21.2InetAddress类</h3><h4 id="21-2-1相关方法"><a href="#21-2-1相关方法" class="headerlink" title="21.2.1相关方法"></a>21.2.1相关方法</h4><p>1.获取本机InetAddress对象  InetAddress.getLocalHost 静态方法 ，return LAPTOP-PH64GORS&#x2F;192.168.137.1</p>
<p>2.根据指定主机名&#x2F;域名获取ip地址对象InetAddress.getByName（主机名）</p>
<p>3.获取InetAddress对象的主机名 getHostName</p>
<p>4.获取InetAddress对象的地址 getHostAddress</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 获取本机的InetAddress 对象</span><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">localHost</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost();<br>System.out.println(localHost);<span class="hljs-comment">//DESKTOP-S4MP84S/192.168.12.1</span><br><br><span class="hljs-comment">//2. 根据指定主机名 获取 InetAddress对象</span><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">host1</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;LAPTOP-PH64GORS&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;host1=&quot;</span> + host1);<span class="hljs-comment">//DESKTOP-S4MP84S/192.168.12.1</span><br><br><span class="hljs-comment">//3. 根据域名返回 InetAddress对象, 比如 www.baidu.com 对应</span><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">host2</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;host2=&quot;</span> + host2);<span class="hljs-comment">//www.baidu.com / 110.242.68.4</span><br><br><span class="hljs-comment">//4. 通过 InetAddress 对象，获取对应的地址</span><br><span class="hljs-type">String</span> <span class="hljs-variable">hostAddress</span> <span class="hljs-operator">=</span> host2.getHostAddress();<span class="hljs-comment">//IP 110.242.68.4</span><br>System.out.println(<span class="hljs-string">&quot;host2 对应的ip = &quot;</span> + hostAddress);<span class="hljs-comment">//110.242.68.4</span><br><br><span class="hljs-comment">//5. 通过 InetAddress 对象，获取对应的主机名/或者的域名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">hostName</span> <span class="hljs-operator">=</span> host2.getHostName();<br>System.out.println(<span class="hljs-string">&quot;host2对应的主机名/域名=&quot;</span> + hostName); <span class="hljs-comment">// www.baidu.com</span><br></code></pre></td></tr></table></figure>

<h3 id="21-3-Socket"><a href="#21-3-Socket" class="headerlink" title="21.3 Socket"></a>21.3 Socket</h3><h4 id="21-3-1基本介绍"><a href="#21-3-1基本介绍" class="headerlink" title="21.3.1基本介绍"></a>21.3.1基本介绍</h4><p>1.套接字（Socket）开发网络应用程序被广泛采用，以至成为事实上的标准</p>
<p>2.通信两端都要是Socket，是两台机器间通信的端点</p>
<p>3.网络通信其实就是Socket的通信</p>
<p>4.Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</p>
<p>5.一般主动发起通信的应用程序属于客户端，等待的为服务端</p>
<p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220113075737710.png" srcset="/img/loading.gif" lazyload alt="image-20220113075737710"></p>
<h3 id="21-4-TCP网络通信编程"><a href="#21-4-TCP网络通信编程" class="headerlink" title="21.4  TCP网络通信编程"></a>21.4  TCP网络通信编程</h3><p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220113075830893.png" srcset="/img/loading.gif" lazyload alt="image-20220113075830893"></p>
<h4 id="21-4-1使用字节流"><a href="#21-4-1使用字节流" class="headerlink" title="21.4.1使用字节流"></a>21.4.1使用字节流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketTCP01Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//思路</span><br>        <span class="hljs-comment">//1. 连接服务端 (ip , 端口）</span><br>        <span class="hljs-comment">//解读: 连接本机的 9999端口, 如果连接成功，返回Socket对象</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(InetAddress.getLocalHost(), <span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;客户端 socket返回=&quot;</span> + socket.getClass());<br>        <span class="hljs-comment">//2. 连接上后，生成Socket, 通过socket.getOutputStream()</span><br>        <span class="hljs-comment">//   得到 和 socket对象关联的输出流对象</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        <span class="hljs-comment">//3. 通过输出流，写入数据到 数据通道</span><br>        outputStream.write(<span class="hljs-string">&quot;hello, server&quot;</span>.getBytes());<br>        <span class="hljs-comment">//4. 关闭流对象和socket, 必须关闭</span><br>        outputStream.close();<br>        socket.close();<br>        System.out.println(<span class="hljs-string">&quot;客户端退出.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketTCP01Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//思路</span><br>        <span class="hljs-comment">//1. 在本机 的9999端口监听, 等待连接</span><br>        <span class="hljs-comment">//   细节: 要求在本机没有其它服务在监听9999</span><br>        <span class="hljs-comment">//   细节：这个 ServerSocket 可以通过 accept() 返回多个Socket[多个客户端连接服务器的并发]</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务端，在9999端口监听，等待连接..&quot;</span>);<br>        <span class="hljs-comment">//2. 当没有客户端连接9999端口时，程序会 阻塞, 等待连接</span><br>        <span class="hljs-comment">//   如果有客户端连接，则会返回Socket对象，程序继续</span><br><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br>        System.out.println(<span class="hljs-string">&quot;服务端 socket =&quot;</span> + socket.getClass());<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>        <span class="hljs-comment">//4. IO读取</span><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ((readLen = inputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, readLen));<span class="hljs-comment">//根据读取到的实际长度，显示内容.</span><br>        &#125;<br>        <span class="hljs-comment">//5.关闭流和socket</span><br>        inputStream.close();<br>        socket.close();<br>        serverSocket.close();<span class="hljs-comment">//关闭</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="21-4-2使用字符流"><a href="#21-4-2使用字符流" class="headerlink" title="21.4.2使用字符流"></a>21.4.2使用字符流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//思路</span><br>        <span class="hljs-comment">//1. 连接服务端 (ip , 端口）</span><br>        <span class="hljs-comment">//解读: 连接本机的 9999端口, 如果连接成功，返回Socket对象</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(InetAddress.getLocalHost(), <span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;客户端 socket返回=&quot;</span> + socket.getClass());<br>        <span class="hljs-comment">//2. 连接上后，生成Socket, 通过socket.getOutputStream()</span><br>        <span class="hljs-comment">//   得到 和 socket对象关联的输出流对象</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        <span class="hljs-comment">//3. 通过输出流，写入数据到 数据通道, 使用字符流</span><br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(outputStream));<br>        bufferedWriter.write(<span class="hljs-string">&quot;hello, server 字符流&quot;</span>);<br>        bufferedWriter.newLine();<span class="hljs-comment">//插入一个换行符，表示写入的内容结束, 注意，要求对方使用readLine()!!!!</span><br>        bufferedWriter.flush();<span class="hljs-comment">// 如果使用的字符流，需要手动刷新，否则数据不会写入数据通道</span><br><br><br>        <span class="hljs-comment">//4. 获取和socket关联的输入流. 读取数据(字符)，并显示</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> bufferedReader.readLine();<br>        System.out.println(s);<br><br>        <span class="hljs-comment">//5. 关闭流对象和socket, 必须关闭</span><br>        bufferedReader.close();<span class="hljs-comment">//关闭外层流</span><br>        bufferedWriter.close();<br>        socket.close();<br>        System.out.println(<span class="hljs-string">&quot;客户端退出.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketTCP03Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//思路</span><br>        <span class="hljs-comment">//1. 在本机 的9999端口监听, 等待连接</span><br>        <span class="hljs-comment">//   细节: 要求在本机没有其它服务在监听9999</span><br>        <span class="hljs-comment">//   细节：这个 ServerSocket 可以通过 accept() 返回多个Socket[多个客户端连接服务器的并发]</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9999</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务端，在9999端口监听，等待连接..&quot;</span>);<br>        <span class="hljs-comment">//2. 当没有客户端连接9999端口时，程序会 阻塞, 等待连接</span><br>        <span class="hljs-comment">//   如果有客户端连接，则会返回Socket对象，程序继续</span><br><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br>        System.out.println(<span class="hljs-string">&quot;服务端 socket =&quot;</span> + socket.getClass());<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>        <span class="hljs-comment">//4. IO读取, 使用字符流, 老师使用 InputStreamReader 将 inputStream 转成字符流</span><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> bufferedReader.readLine();<br>        System.out.println(s);<span class="hljs-comment">//输出</span><br><br>        <span class="hljs-comment">//5. 获取socket相关联的输出流</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>       <span class="hljs-comment">//    使用字符输出流的方式回复信息</span><br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(outputStream));<br>        bufferedWriter.write(<span class="hljs-string">&quot;hello client 字符流&quot;</span>);<br>        bufferedWriter.newLine();<span class="hljs-comment">// 插入一个换行符，表示回复内容的结束</span><br>        bufferedWriter.flush();<span class="hljs-comment">//注意需要手动的flush</span><br><br><br>        <span class="hljs-comment">//6.关闭流和socket</span><br>        bufferedWriter.close();<br>        bufferedReader.close();<br>        socket.close();<br>        serverSocket.close();<span class="hljs-comment">//关闭</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="21-4-3文件发送"><a href="#21-4-3文件发送" class="headerlink" title="21.4.3文件发送"></a>21.4.3文件发送</h4><h4 id="21-4-4-netstat-指令"><a href="#21-4-4-netstat-指令" class="headerlink" title="21.4.4 netstat 指令"></a>21.4.4 netstat 指令</h4><p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220113083050590.png" srcset="/img/loading.gif" lazyload alt="image-20220113083050590"></p>
<p>telnet ip 端口号 连接服务器</p>
<p>crtl+】 显示字符</p>
<p>用Java连接服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;time-a.nist.gov&quot;</span>, <span class="hljs-number">13</span>); <span class="hljs-comment">//打开一个关键字，负责启动该程序内部和外部的通信 若连接失败 它将抛出</span><br>     <span class="hljs-comment">// 一个UnknownHostException,</span><br>     <span class="hljs-comment">// 如果存在其他问题将抛出一个IOException 因为UnknownException是IOException的一个子类 这仅是示例程序仅捕获超类的异常</span><br>      <span class="hljs-type">var</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(s.getInputStream(), StandardCharsets.UTF_8))<br><span class="hljs-comment">//一旦套接字打开 Socket 类中的getInputStream 类就会返回一个InputSteam对象，该对象可以像任何其他流对象使用，该程序一旦获得了</span><br>        <span class="hljs-comment">//这个流 该程序会将直接把每一行打印到标准输出 该程序只适用非常简单的服务器</span><br>        <span class="hljs-comment">//在比较复杂的网络程序中 客户端发送请求而服务器可能在响应结束是并不立刻断开连接</span><br>        <span class="hljs-comment">//java库隐藏了建立网络连接和通过连接发送数据的复杂过程</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This program demonstrates the InetAddress class. Supply a host name as command-line</span><br><span class="hljs-comment"> * argument, or run without command-line arguments to see the address of the local host.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.02 2012-06-05</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Cay Horstmann</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InetAddressTest</span><br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException<br>   &#123;<br>      <span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">0</span>)<br>      &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>];<br>         InetAddress[] addresses = InetAddress.getAllByName(host);<span class="hljs-comment">//为给定的主机名创建一个InetAddress对象</span><br>         <span class="hljs-comment">//</span><br>         <span class="hljs-keyword">for</span> (InetAddress a : addresses)<br>            System.out.println(a);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>         <span class="hljs-type">InetAddress</span> <span class="hljs-variable">localHostAddress</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost(); <span class="hljs-comment">//为本机主机创建一个InetAddress对象</span><br>         System.out.println(localHostAddress);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>InetAddress</p>
<p>Socket</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>byte是字节类型</p>
<p>char 是unicode 是万国码 16位 兼容assic</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>自动向上类型转换</p>
<p>强制向下转换(对表达式强转)</p>
<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>&amp;gt 则返回 1</p>
<p>&amp;lt 则返回 -1</p>
<p>sort 默认从小到大,比较器不关注sort,只关注传递大小信息</p>
<p>lamda随便写写  基本类型不支持比较器</p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220824094548657.png" srcset="/img/loading.gif" lazyload alt="image-20220824094548657"></p>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><blockquote>
<p>创建文件对象,对对象进行操作 文件夹或文件皆可抽象为file,但文件夹不能被输入输出</p>
</blockquote>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>字节与字符的区别</p>
<p>字节(Byte)是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位。</p>
<p>字符(Character)计算机中使用的字母、数字、字和符号，比如’A’、’B’、’$’、’&amp;’等。</p>
<p>一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/05/242dd42a2834349bfaa71500c4ea15ce37d3be96.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>字节与字符：</strong></p>
<ul>
<li>ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。</li>
<li>UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。</li>
<li>Unicode 编码中，一个英文为一个字节，一个中文为两个字节。</li>
<li>符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 <strong>.</strong> 占1个字节的大小，中文句号 <strong>。</strong>占2个字节的大小。</li>
<li>UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode 扩展区的一些汉字存储需要 4 个字节）。</li>
<li>UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。</li>
</ul>
<p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220824100349380.png" srcset="/img/loading.gif" lazyload alt="image-20220824100349380"></p>
<p><strong>输出流默认覆盖写,文件不存在则创建文件</strong></p>
<h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>1、外部类前可以修饰：public、default、abstract、final</p>
<ul>
<li><p>对于顶级类(外部类)来说，只有两种修饰符：public和默认(default)。因为外部类的上一单元是包，所以外部类只有两个作用域：同包，任何位置。因此，只需要两种控制权限：包控制权限和公开访问权限，也就对应两种控制修饰符：public和默认(default)。可以满足所有的情况了。</p>
<p>如果类使用了private修饰符，说明是个内部类。内部类的上一级是外部类，那么对应的有四种访问控制修饰符：本类(private)，同包(default)，父子类(protected)，任何位置(public)。当一个内部类使用了private修饰后，只能在该类的外部类内部使用。</p>
<p>上面这些都是平时使用司空见惯的，但是为什么是这种情况呢？</p>
<p>可以想一下，一个java项目是不可能在一个class里面完成的。mvc模式中，是把类分为三层，一层层调用类。如果定义为私有的和受保护的就无法调用。换句话说，对于一个java文件，要么就是自己单独运行，要么就是被其他程序作为库调用，如果一个java文件的类被private修饰，那么是不是其他的程序或是类是无法使用它的，那么他作为一个单独的文件就没啥用了。如果它作为单个文件运行，类加载怎么找到它呢，因为它对外不可见。同时，也失去了类的存在意义。</p>
</li>
</ul>
<p>2、内部类前可以修饰：public、protected、default、private、abstract、final、static</p>
<p>3、局部(指方法 代码块等)内部类前可以修饰：abstract、final</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>1、 public ：对 所有用户 开放，所有用户都可直接调用<br>2、 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a> ：私有。 除了class自己之外，任何人都不可直接使用 ，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可使用。</p>
<p>default 类内部 与 同包 ,即对于外包的类和子类朋友类相当于为私有不能访问</p>
<p>3、 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=protected&spm=1001.2101.3001.7020">protected</a> ：对于子女、朋友来说，就是public的，可自由使用，无任何限制；而对于其他的外部class，protected就变成private。（ 同一个包中的类，若不在同一个包中，必须为其子孙类才可使用 ）</p>
<h2 id="接口抽象类"><a href="#接口抽象类" class="headerlink" title="接口抽象类"></a>接口抽象类</h2><p>接口里的静态方法，即static修饰的有方法体的方法不会被继承或者实现，但是静态变量会被继承</p>
<p>接口中的static方法不能被继承，也不能被实现类调用，只能被自身调用</p>
<h1 id="Guava入门"><a href="#Guava入门" class="headerlink" title="Guava入门"></a>Guava入门</h1><p>guava就是类库，是java api的增强与扩展，里面有大量的方法供我们使用，使用之前需要引入包</p>
<dependencies>

<pre><code class="hljs">    &lt;!--guava依赖--&gt;

    &lt;dependency&gt;

        &lt;groupId&gt;com.google.guava&lt;/groupId&gt;

        &lt;artifactId&gt;guava&lt;/artifactId&gt;

        &lt;version&gt;27.0.1&lt;/version&gt;

    &lt;/dependency&gt;
</code></pre>
</dependencies>

<p>guava有哪些方法呢？我们先从以下几方面开始学习：</p>
<p>字符串处理：分割，连接，填充<br>新增的集合类型<br>原生类型<br>1.原生类型</p>
<p> 定义list，map</p>
<p>public void test() {<br>        &#x2F;&#x2F;JDK<br>        List<String> list &#x3D; new ArrayList<String>();<br>        list.add(“a”);<br>        list.add(“b”);<br>        list.add(“c”);<br>        list.add(“d”);<br>        &#x2F;&#x2F;guava<br>        List<String> lists &#x3D; Lists.newArrayList(“a”, “b”, “g”, null, “8”, “9”);<br>        List<String> lists1 &#x3D; Lists.newArrayList();<br>        Map&lt;Integer, String&gt; maps &#x3D; Maps.newHashMap();<br>}<br>guava就是类库，是java api的增强与扩展，里面有大量的方法供我们使用，使用之前需要引入包</p>
<dependencies>

<pre><code class="hljs">    &lt;!--guava依赖--&gt;

    &lt;dependency&gt;

        &lt;groupId&gt;com.google.guava&lt;/groupId&gt;

        &lt;artifactId&gt;guava&lt;/artifactId&gt;

        &lt;version&gt;27.0.1&lt;/version&gt;

    &lt;/dependency&gt;
</code></pre>
</dependencies>

<p>guava有哪些方法呢？我们先从以下几方面开始学习：</p>
<p>字符串处理：分割，连接，填充<br>新增的集合类型<br>原生类型<br>1.原生类型</p>
<p> 定义list，map</p>
<p>public void test() {<br>        &#x2F;&#x2F;JDK<br>        List<String> list &#x3D; new ArrayList<String>();<br>        list.add(“a”);<br>        list.add(“b”);<br>        list.add(“c”);<br>        list.add(“d”);<br>        &#x2F;&#x2F;guava<br>        List<String> lists &#x3D; Lists.newArrayList(“a”, “b”, “g”, null, “8”, “9”);<br>        List<String> lists1 &#x3D; Lists.newArrayList();<br>        Map&lt;Integer, String&gt; maps &#x3D; Maps.newHashMap();<br>}<br>2.新增集合（这里我只讲一下Mulitmap,平时用这个会使代码很方便，这里我就多讲一下）</p>
<p>a Multimap的使用</p>
<p>   Multimap就是将相同key的value值放在一个list里面，这样子取相同key下面的所有value值就非常简单了，不然还得for循环去匹配，把相同key值的value值找出来，在进行处理。map&lt;key,value&gt;键值key不能重复，所以当遇到这样子场景的时候map就非常不适合了，guava提供了Multimap适用于该场景。</p>
<p>当我们需要一个map中包含key为String类型，value为List类型的时候，以前我们是这样写的</p>
<p>&#x2F;&#x2F; jdk方式<br>Map&lt;String,List<Integer>&gt; map &#x3D; new HashMap&lt;String,List<Integer>&gt;();<br>List<Integer> list &#x3D; new ArrayList<Integer>();<br>list.add(1);<br>list.add(2);<br>map.put(“aa”, list);<br>System.out.println(map.get(“aa”));&#x2F;&#x2F;[1, 2]</p>
<p>&#x2F;&#x2F; guava方式<br>Multimap&lt;String,Integer&gt; map &#x3D; ArrayListMultimap.create();<br>map.put(“aa”, 1);<br>map.put(“aa”, 2);<br>System.out.println(map.get(“aa”));  &#x2F;&#x2F;[1, 2]<br> Multimap.get(key)即使没有key值，会返回空的list。</p>
<p> Multimap.keySet()返回的用set<T>表示的不重复key;</p>
<p> Multimap.keys()返回的是用Multiset表示的key,key数量跟value值数量一致；</p>
<p> Multimap.containKeys()是表示是否包含这个key;</p>
<p> Multimap.size()返回所有值的个数，而非不同键的个数。要得到不同键的个数，要用Multimap.keySet().size()</p>
<p>想要更多了解Multimap可以参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e0537d878b6c">https://www.jianshu.com/p/e0537d878b6c</a></p>
<p>3.字符串的处理：分割，连接，填充</p>
<p>   a. joiner 连接器</p>
<p>joiner on就是将list用，连接转成字符串</p>
<p>@Test<br>    public void joinerListTest() {<br>        List<String> lists &#x3D; Lists.newArrayList(“a”,”b”,”g”,”8”,”9”);<br>        String result &#x3D; Joiner.on(“,”).join(lists);<br>        System.out.println(result);<br>    }</p>
<p>结果：a,b,g,8,9<br>joiner skipNulls()连接跳过null元素(第一个test为了跟第二个进行比对一下)</p>
<p>@Test<br>    public void joinerListTest1() {<br>        List<String> lists &#x3D; Lists.newArrayList(“a”,”b”,”g”,null,”8”,”9”);<br>        String result &#x3D; Joiner.on(“,”).join(lists);<br>        System.out.println(result);<br>    }</p>
<p>结果：a,b,g,null,8,9</p>
<p>@Test<br>public void joinerListTest2() {<br>    List<String> lists &#x3D; Lists.newArrayList(“a”,”b,”g”,null,”8”,”9”);<br>    String result &#x3D; Joiner.on(“,”).skipNulls().join(lists);<br>    System.out.println(result);<br>}<br>结果：a,b,g,8,9<br>  如果连接的时候list里面含有null值，会报空指针，因为join实现如下：</p>
<ol>
<li><p>public final String join(Iterable&lt;?&gt; parts) {<br>  return this.join(parts.iterator());<br>  }</p>
</li>
<li><p>public final String join(Iterator&lt;?&gt; parts) {<br>  return this.appendTo(new StringBuilder(), parts).toString();<br>  }</p>
</li>
<li><p>@CanIgnoreReturnValue<br>  public final StringBuilder appendTo(StringBuilder builder, Iterator&lt;?&gt; parts) {<br>  try {<br>      this.appendTo((Appendable)builder, (Iterator)parts);<br>      return builder;<br>  } catch (IOException var4) {<br>      throw new AssertionError(var4);<br>  }<br>  }</p>
</li>
<li><p>@CanIgnoreReturnValue<br>  public <A extends Appendable> A appendTo(A appendable, Iterator&lt;?&gt; parts) throws IOException {<br>  Preconditions.checkNotNull(appendable);<br>  if (parts.hasNext()) {<br>      appendable.append(this.toString(parts.next()));<br><br>      while(parts.hasNext()) {<br>          appendable.append(this.separator);<br>          appendable.append(this.toString(parts.next()));<br>      }<br>  }<br>  return appendable;<br>  }</p>
</li>
<li><p>@CanIgnoreReturnValue<br>  public static <T> T checkNotNull(T reference) {<br>  if (reference &#x3D;&#x3D; null) {<br>      throw new NullPointerException();<br>  } else {<br>      return reference;<br>  }<br>  }<br> joiner useForNull(final String value)用value替换null元素值</p>
</li>
</ol>
<p>@Test<br>    public void useNullListTest() {<br>        List<String> lists &#x3D; Lists.newArrayList(“a”, “b”, “g”, null, “8”, “9”);<br>        String result &#x3D; Joiner.on(“,”).useForNull(“哈哈”).join(lists);<br>        System.out.println(result);<br>    }</p>
<p>结果：a,b,g,哈哈,8,9<br> joiner withKeyValueSeparator(String value)   map连接器，keyValueSeparator为key和value之间的分隔符</p>
<p>@Test<br>    public void withMapTest() {<br>        Map&lt;Integer, String&gt; maps &#x3D; Maps.newHashMap();<br>        maps.put(1, “哈哈”);<br>        maps.put(2, “压压”);<br>        String result &#x3D; Joiner.on(“,”).withKeyValueSeparator(“:”).join(maps);<br>        System.out.println(result);<br>        System.out.println(maps);<br>    }</p>
<p>结果：<br>1:哈哈,2:压压<br>{1&#x3D;哈哈, 2&#x3D;压压}<br>  b. splitter 拆分器</p>
<p> splitter on 拆分</p>
<p>@Test<br>    public void splitterListTest() {<br>        String test &#x3D; “34344,34,34,哈哈”;<br>        List<String> lists &#x3D; Splitter.on(“,”).splitToList(test);<br>        System.out.println(lists);<br>    }</p>
<p>结果：[34344, 34, 34, 哈哈]<br> splitter trimResults 拆分去除前后空格</p>
<p>@Test<br>    public void trimResultListTest() {<br>        String test &#x3D; “  34344,34,34,哈哈 “;<br>        List<String> lists &#x3D; Splitter.on(“,”).trimResults().splitToList(test);<br>        System.out.println(lists);<br>    }</p>
<p>结果：[34344, 34, 34, 哈哈]<br>splitter omitEmptyStrings 去除拆分出来空的字符串</p>
<p>@Test<br>    public void omitEmptyStringsTest() {<br>        String test &#x3D; “  3434,434,34,,哈哈 “;<br>        List<String> lists &#x3D; Splitter.on(“,”).omitEmptyStrings().splitToList(test);<br>        System.out.println(lists);<br>    }</p>
<p>结果：[  3434, 434, 34, 哈哈 ]<br>splitter fixedLength(int lenght) 把字符串按固定长度分割</p>
<p>@Test<br>    public void fixedLengthTest() {<br>        String test &#x3D; “343443434哈哈”;<br>        List<String> lists &#x3D; Splitter.fixedLength(3).splitToList(test);<br>        System.out.println(lists);<br>    }</p>
<p>结果：[343, 443, 434, 哈哈]<br>  b. charMatcher 匹配器</p>
<p>charMatcher is(Char char)  给单一字符匹配</p>
<p>@Test<br>    public void isTest() {<br>        String str &#x3D; “12312,agg”;<br>        CharMatcher charMatcher1 &#x3D; CharMatcher.is(‘g’);<br>        System.out.println(charMatcher1.retainFrom(str));<br>    }</p>
<p>结果：gg<br>charMatcher  retainFrom(String s)  在字符序列中保留匹配字符，移除其他字符</p>
<p>@Test<br>    public void charMatcherTest() {<br>        String str &#x3D; “12312,agg  “;<br>        &#x2F;&#x2F;两个匹配符,先匹配再操作<br>        CharMatcher charMatcher1 &#x3D; CharMatcher.is(‘1’);<br>        CharMatcher charMatcher2 &#x3D; CharMatcher.is(‘2’);<br>        &#x2F;&#x2F;两个CharMatcher或操作<br>        CharMatcher charMatcher3 &#x3D; charMatcher1.or(charMatcher2);<br>        System.out.println(charMatcher3.retainFrom(str));<br>    }</p>
<p>结果：1212<br>charMatcher matchersAllOf(Char char) 测试是否字符序列所有字符都匹配</p>
<p>@Test<br>    public void matchesAllOfTest() {<br>        String str &#x3D; “12312,agg”;<br>        CharMatcher charMatcher1 &#x3D; CharMatcher.is(‘g’);<br>        System.out.println(charMatcher1.matchesAllOf(str));<br>    }</p>
<p>结果：false<br>@Test<br>    public void matchesAllOfTest() {<br>        String str &#x3D; “ggggg”;<br>        CharMatcher charMatcher1 &#x3D; CharMatcher.is(‘g’);<br>        System.out.println(charMatcher1.matchesAllOf(str));<br>    }</p>
<p>结果：true</p>
<h1 id="arr与list转换"><a href="#arr与list转换" class="headerlink" title="arr与list转换"></a>arr与list转换</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">34</span>, <span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>&#125;;<br>        <span class="hljs-type">long</span>[] longs = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">double</span>[] doubles = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        Arrays.stream(ints).boxed().collect(Collectors.toList());<br>        Arrays.stream(longs).boxed().collect(Collectors.toList());<br>        Arrays.stream(doubles).boxed().collect(Collectors.toList());<br></code></pre></td></tr></table></figure>

<p><strong>直接for,add就完事了反之同理</strong></p>
<p><strong>java数组转list误区</strong><br><strong>一、不能把基本数据类型转化为列表</strong><br>仔细观察可以发现asList接受的参数是一个泛型的变长参数，而基本数据类型是无法泛型化的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">App</span> &#123;<br>   <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span> [] intarray = &#123; <span class="hljs-number">1</span> ,  <span class="hljs-number">2</span> ,  <span class="hljs-number">3</span> ,  <span class="hljs-number">4</span> ,  <span class="hljs-number">5</span> &#125;;<br>     <span class="hljs-comment">//List&lt;Integer&gt; list = Arrays.asList(intarray); 编译通不过</span><br>     List&lt; <span class="hljs-type">int</span> []&gt; list = Arrays.asList(intarray);<br>     System.out.println(list);<br>   &#125;<br>&#125;<br><br>output：<br>[[I @66d3c617 ]<br><span class="hljs-number">1234567891011</span><br></code></pre></td></tr></table></figure>

<p>这是因为把int类型的数组当参数了，所以转换后的列表就只包含一个int[]元素。<br>解决方案：<br>要想把基本数据类型的数组转化为其包装类型的list，可以使用guava类库的工具方法，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] intArray = &#123; <span class="hljs-number">1</span> ,  <span class="hljs-number">2</span> ,  <span class="hljs-number">3</span> ,  <span class="hljs-number">4</span> &#125;;<br>List&lt;Integer&gt; list = Ints.asList(intArray);<br></code></pre></td></tr></table></figure>

<h2 id="第一种方式-未必最佳-使用ArrayList-asList-strArray"><a href="#第一种方式-未必最佳-使用ArrayList-asList-strArray" class="headerlink" title="第一种方式(未必最佳):使用ArrayList.asList(strArray)"></a>第一种方式(未必最佳):使用ArrayList.asList(strArray)</h2><p>使用Arrays工具类Arrays.asList(strArray)方式,转换完成后,只能对List<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>进行查改,不能增删,增删就会抛出UnsupportedOperationException 异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Demo1</span><span class="hljs-params">()</span> &#123;<br>        String[] str = &#123;<span class="hljs-string">&quot;fgx&quot;</span>, <span class="hljs-string">&quot;lzy&quot;</span>&#125;;<br>        <span class="hljs-comment">//注意这个List不是Collections包内的List,而是util包里面的List接口</span><br>        List&lt;String&gt; ints = Arrays.asList(str);<br>    	<span class="hljs-comment">//这里会报错</span><br>        ints.add(<span class="hljs-string">&quot;laopo&quot;</span>);<br>    &#125;<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure>

<p>添加数据报错:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.UnsupportedOperationException<br>at java.util.AbstractList.add(AbstractList.java:<span class="hljs-number">148</span>)<br>at java.util.AbstractList.add(AbstractList.java:<span class="hljs-number">108</span>)<br>at JAVA基础.JDK8新特性.Java数组转List.Demo1(Java数组转List.java:<span class="hljs-number">20</span>)<br>at JAVA基础.JDK8新特性.Java数组转List.main(Java数组转List.java:<span class="hljs-number">13</span>)<br><br>报错原因:Arrays.asList(str)返回值是java.util.Arrays类中一个私有静态内部类 <br>java.utiil.Arrays.Arraylist,并不是我们平时用的java.util.ArrayList();<br><br>使用场景:Arrays.asList(strArray)方式仅能用在将数组转换为List后，不需要增删其中的值，仅作为数据源读取使用。<br><span class="hljs-number">12345678910</span><br></code></pre></td></tr></table></figure>

<h2 id="第二种方法-支持增删查改"><a href="#第二种方法-支持增删查改" class="headerlink" title="第二种方法(支持增删查改):"></a>第二种方法(支持增删查改):</h2><p>通过ArrayList的构造器,将Arrays.asList(strArray)的返回值由java.utilArrays.ArrayList转为java.util.ArrayList.<br>关键代码：ArrayList list &#x3D; new ArrayList(Arrays.asList(strArray)) ;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  String[] str = &#123;<span class="hljs-string">&quot;fgx&quot;</span>, <span class="hljs-string">&quot;lzy&quot;</span>&#125;;<br>        <span class="hljs-comment">//注意这个List不是Collections包内的List,而是util包里面的List接口</span><br>        java.util.ArrayList&lt;String&gt; strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(str));<br>        strings.add(<span class="hljs-string">&quot;aop&quot;</span>);<br>        strings.stream().forEach(System.out::println);<br><br><span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/f33d7ecf29754253b15d6abeda2034aa.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>使用场景:需要在将数组转换为List后，对List进行增删改查操作，在List的数据量不大的情况下，可以使用。</p>
<h2 id="第三种方式-通过集合工具类Collections-addAll-方法-最高效"><a href="#第三种方式-通过集合工具类Collections-addAll-方法-最高效" class="headerlink" title="第三种方式(通过集合工具类Collections.addAll()方法(最高效))"></a>第三种方式(通过集合工具类Collections.addAll()方法(最高效))</h2><p>通过Collections.addAll(arrayList, strArray)方式转换，根据数组的长度创建一个长度相同的List，然后通过Collections.addAll()方法，将数组中的元素转为二进制，然后添加到List中，这是最高效的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Demo3</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//注意这个List不是Collections包内的List,而是util包里面的List接口</span><br>       String[] str = &#123;<span class="hljs-string">&quot;fgx&quot;</span>, <span class="hljs-string">&quot;lzy&quot;</span>&#125;;<br>       java.util.ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(str.length);<br>       Collections.addAll(stringList,str);<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="第四种方式通过JDK8的Stream流将3总基本类型数组转为List"><a href="#第四种方式通过JDK8的Stream流将3总基本类型数组转为List" class="headerlink" title="第四种方式通过JDK8的Stream流将3总基本类型数组转为List"></a>第四种方式通过JDK8的Stream流将3总基本类型数组转为List</h2><p>如果JDK版本在1.8以上,使用流stream来将下列3种数组快速转为List,分别是int[],long[],double[],不支持short[ ],byte[ ],char[]在JDK1.8中暂不支持.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">34</span>, <span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>&#125;;<br>        <span class="hljs-type">long</span>[] longs = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">double</span>[] doubles = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        Arrays.stream(ints).boxed().collect(Collectors.toList());<br>        Arrays.stream(longs).boxed().collect(Collectors.toList());<br>        Arrays.stream(doubles).boxed().collect(Collectors.toList());<br><span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure>

<p>TIPs:为什么int[]不能直接转为List,而Integer[]可以转为List,而Integer[]就可以转为List了,因为List中的泛型必须是引用类型。</p>
<p><strong>java数组转list误区</strong><br><strong>一、不能把基本数据类型转化为列表</strong><br>仔细观察可以发现asList接受的参数是一个泛型的变长参数，而基本数据类型是无法泛型化的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">App</span> &#123;<br>   <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span> [] intarray = &#123; <span class="hljs-number">1</span> ,  <span class="hljs-number">2</span> ,  <span class="hljs-number">3</span> ,  <span class="hljs-number">4</span> ,  <span class="hljs-number">5</span> &#125;;<br>     <span class="hljs-comment">//List&lt;Integer&gt; list = Arrays.asList(intarray); 编译通不过</span><br>     List&lt; <span class="hljs-type">int</span> []&gt; list = Arrays.asList(intarray);<br>     System.out.println(list);<br>   &#125;<br>&#125;<br><br>output：<br>[[I @66d3c617 ]<br><span class="hljs-number">1234567891011</span><br></code></pre></td></tr></table></figure>

<p>这是因为把int类型的数组当参数了，所以转换后的列表就只包含一个int[]元素。<br>解决方案：<br>要想把基本数据类型的数组转化为其包装类型的list，可以使用guava类库的工具方法，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] intArray = &#123; <span class="hljs-number">1</span> ,  <span class="hljs-number">2</span> ,  <span class="hljs-number">3</span> ,  <span class="hljs-number">4</span> &#125;;<br>List&lt;Integer&gt; list = Ints.asList(intArray);<br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure>

<p><strong>二、asList方法返回的是数组的一个视图</strong><br>视图意味着，对这个list的操作都会反映在原数组上，而且这个list是定长的，不支持add、remove等改变长度的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">App</span> &#123;<br>   <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">int</span> [] intArray = &#123; <span class="hljs-number">1</span> ,  <span class="hljs-number">2</span> ,  <span class="hljs-number">3</span> ,  <span class="hljs-number">4</span> &#125;;<br>     List&lt;Integer&gt; list = Ints.asList(intArray);<br>     list.set( <span class="hljs-number">0</span> ,  <span class="hljs-number">100</span> );<br>     System.out.println(Arrays.toString(intArray));<br>     list.add( <span class="hljs-number">5</span> );<br>     list.remove( <span class="hljs-number">0</span> );<br>   &#125;<br>&#125;<br><br><br>output：<br>[ <span class="hljs-number">100</span> ,  <span class="hljs-number">2</span> ,  <span class="hljs-number">3</span> ,  <span class="hljs-number">4</span> ]<br>UnsupportedOperationException<br>UnsupportedOperationException<br></code></pre></td></tr></table></figure>



<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><ul>
<li><p>依赖 use-a</p>
</li>
<li><p>聚合 has-a</p>
</li>
<li><p>继承 is-a</p>
</li>
</ul>
<h2 id="1-域变量与局部变量"><a href="#1-域变量与局部变量" class="headerlink" title="1.域变量与局部变量"></a>1.域变量与局部变量</h2><p>域变量会初始化为自动默认值,如果不明确初始化会影响代码的可读性</p>
<p>局部变量不会自动初始化为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    ...<br>&#125;<br>Emplpyee[] staff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>[<span class="hljs-number">3</span>];<br><span class="hljs-comment">// 省略不同的名字初始化</span><br><span class="hljs-comment">// 如果需要返回一个可变数据域的拷贝,应该使用clone</span><br><span class="hljs-type">Employee</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<br>System.out.println(boss.name); <span class="hljs-comment">// null</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Employee other)</span> &#123;<br>        <span class="hljs-comment">//访问</span><br>        <span class="hljs-type">int</span> a;<br>        System.out.println(a);<span class="hljs-comment">//报错 在使用时a未被初始化 当然如果不使用a就不会报错</span><br>    &#125;<br></code></pre></td></tr></table></figure>





<p>首先方法可以访问所调用对象的私有数据(平常使用显而易见).</p>
<p>然后让人奇怪的是一个<strong>方法可以访问所属类的所有对象的私有数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><span class="hljs-comment">//    ...</span><br>    Employee (String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Employee other)</span> &#123;<br>        <span class="hljs-comment">//访问</span><br>        <span class="hljs-keyword">return</span> name.equals(other.name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;boss&quot;</span>);<br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">harry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;harry&quot;</span>);<br><span class="hljs-comment">//        System.out.println(boss.name); // 编译器报错</span><br>        <span class="hljs-keyword">if</span> (boss.equals(harry)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Employee的方法可以访问Employee类任何一个对象的私有域&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>private 方法</strong>内部使用,想删就删(不会被外部使用)</p>
<p><strong>final实例域</strong> 必须确保在每个构造器执行后这个域的值被设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<span class="hljs-comment">//编译器报错</span><br>    <span class="hljs-comment">//如果去掉无参构造器则不报错</span><br>    Employee () &#123;<br><br>    &#125;<br>   <br>    Employee (String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;不能改&quot;</span>;<span class="hljs-comment">// 报错: name&#x27; might already have been assigned(分配) to,因为涉及更改引用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>final关键字只是表示不会在指向别的地方,对象本身可以更改</p>
<p>静态方法不需要构建对象就可以调用</p>
<p>静态代码(只有在装载类的时候被执行) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    A() &#123;<br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br>    B() &#123;<br>        System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();   <br>        <span class="hljs-comment">// 12aba</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>每一个类都可以有一个main方法</p>
<p>方法可以改变一个对象参数的状态,但不能整体改变(用x指向别的)因为是局部变量只是改变局部变量的值 真正的引用未被改变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//伪代码</span><br>A <span class="hljs-title function_">a</span><span class="hljs-params">(a)</span>,b(b)<br>swap(a,b);<br>swap(x,y) &#123;<br>    <span class="hljs-type">A</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> x;<br>    x = y;<br>    y = x;   <br>&#125;<span class="hljs-comment">// 如果是传应用</span><br>sout(a,b) 输出 b,a<br>但是并没有奏效输出还是a,b<br></code></pre></td></tr></table></figure>

<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>方法同名不同参数</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>子类覆盖父类:方法签名覆盖 方法名与参数列表完全一致</p>
<p>区分重载:</p>
<p>super不是一个对象的引用,不能将super赋给另一个对象变量,它只是一个指示编译器调用超类方法的特殊关键字</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法名+参数列表称为方法签名</p>
<p><strong>动态绑定</strong></p>
<blockquote>
<p>C x &#x3D; new B();</p>
<p>x.f(args)</p>
</blockquote>
<ol>
<li>获取父类public且对应名称的方法和声明类的对应名称方法</li>
<li>找一个参数类型完全匹配的方法(这个过程称为重载解析) 有可能类型转换 没找到就会报错</li>
<li>实际调用会调用x的真正类型的方法,虚拟机预先为每个类有一个方法表</li>
</ol>
<p>作用: 无需对现存代码修改,就可以对程序扩展</p>
<p><strong>静态绑定</strong>: private,static,final或者构造器等编译器可以准确的知道应该调用哪个方法,所以称为静态绑定</p>
<h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p><strong>final类</strong> 为不允许扩展的的类,所有方法自动成为final,不包括域,确保它们不会在子类改变语义</p>
<p>如果一个方法没有被覆盖并且很短就可被优化为<strong>内联</strong> 例如: e.getNname 将被替换为访问e.name域 详见:Java核心卷10</p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>允许子类引用赋值给父类<strong>反之必须类型转换</strong>才能通过<strong>运行时</strong>检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-comment">//    ...</span><br>    Employee () &#123;<br><br>    &#125;<br>    Employee (String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Employee other)</span> &#123;<br>        <span class="hljs-comment">//访问</span><br>        <span class="hljs-keyword">return</span> name.equals(other.name);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;员工共有之work&quot;</span>+name);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span>&#123;<br>    Manager (String name) &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">manage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;经理独有之manage&quot;</span>+name);<br>    &#125;<br>    <span class="hljs-comment">//每个经理是一个员工</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.405</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) x;<br>        <span class="hljs-type">Manager</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>        Employee[] staff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>[<span class="hljs-number">3</span>];<br><span class="hljs-comment">//        Employee b = new Employee(&quot;b&quot;);</span><br><span class="hljs-comment">//        Manager c = (Manager)b;</span><br><span class="hljs-comment">//        c.manage(); 这三行会报 ClassCastException</span><br>       <span class="hljs-comment">//改进:</span><br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        Manager c; <span class="hljs-comment">// 局部变量未使用不会报错</span><br>        <span class="hljs-keyword">if</span> (b <span class="hljs-keyword">instanceof</span> Manager) &#123;<br>            c = (Manager) b;<br>        &#125;<br><br><br>        staff[<span class="hljs-number">0</span>] = a;<span class="hljs-comment">// 转化为E 实际为M</span><br><span class="hljs-comment">//        staff[0].manage();//报错</span><br>        a = (Manager)staff[<span class="hljs-number">0</span>];<span class="hljs-comment">// 将父类强转为子类 唯一原因是:暂时忽视对象的?后,使用对象的全部功能</span><br>        a.manage(); <span class="hljs-comment">// 正常调用</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总结:父类转换为子类之前要使用instanceof,并且只能在继承层次内进行类型转换</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h2><ol>
<li>含有抽象方法(不需要实现的方法)的必须是抽象类</li>
<li>不含有抽象方法也可以声明为抽象类,只是不能被实例化</li>
<li>可以包含具体数据与方法</li>
</ol>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>**hashCode()**每个对象都有,其值为对象的存储地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s);<br>        System.out.println(s.hashCode() + <span class="hljs-string">&quot; &quot;</span>+sb.hashCode());<br>       <br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ok&quot;</span>);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(t);<br>        System.out.println(t.hashCode() + <span class="hljs-string">&quot; &quot;</span>+tb.hashCode());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>3548 460141958<br>3548 1163157884</p>
<p>String 的hashcode()是内容导向的 如果equals为true那么hashcode也要一致</p>
</blockquote>
<h3 id="为什么重写equals方法就必须重写hashCode方法？"><a href="#为什么重写equals方法就必须重写hashCode方法？" class="headerlink" title="为什么重写equals方法就必须重写hashCode方法？"></a>为什么重写equals方法就必须重写hashCode方法？</h3><ul>
<li><p>在散列表中，<br>1、如果两个对象相等，那么它们的hashCode()值一定要相同； 这里的相等是指，通过equals()比较两个对象 时返回true</p>
<p>2、如果两个对象hashCode()相等，它们并不一定相等。(不相等时就是哈希冲突)</p>
<p> 注意：这是在散列表中的情况。在非散列表中一定如此！</p>
</li>
<li><p>考虑只重写equals而不重写 hashcode 时，虽然两个属性值完全相同的对象通过equals方法判断为true，但是当把这两个对象加入到 HashSet 时。会发现HashSet中有重复元素，这就是因为HashSet 使用 hashcode 判断对象是否已存在时造成了歧义，结果会导 致HashSet 的不正常运行。所以重写 equals 方法必须重写 hashcode 方法。</p>
</li>
</ul>
<p>map的put 拿到hashcode()进行散列定槽 如果槽为空直接加入</p>
<p>如果槽不为空(判断key是否相等(key不能重复),)如果key相同直接覆盖  value ,否则解决哈希冲突</p>
<p>还是从set角度说重写hashCode</p>
<h2 id="enum关键字"><a href="#enum关键字" class="headerlink" title="enum关键字"></a>enum关键字</h2><h1 id="接口、lambda表达式与内部类"><a href="#接口、lambda表达式与内部类" class="headerlink" title="接口、lambda表达式与内部类"></a>接口、lambda表达式与内部类</h1><ul>
<li>接口,lambda</li>
<li>内部类机制,内部类中的方法可以访问外部的域</li>
<li>代理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    A a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>        <br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iinterface</span> &#123; <span class="hljs-comment">// 内部接口默认为static的</span><br>         <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iinterface</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;内部接口可被private,protectd static(默认static) public,  修饰&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;外部类(接口)权限修饰符只能是public 或者不写&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;外部类可被final修饰(接口不行),不能被继承,不能static修饰&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T other)</span>;<br>&#125;<br><span class="hljs-comment">// 接口方法自动的是public,实现类必须写好</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>类泛型 写在类名之后&lt;&gt; 可以用在类内部域,方法参数,方法返回值,方法参数,局部变量等所有能声明的: 从结果来说可以理解为限定了一个限定符 等指定之后在进行替换不指定则为null,当第一次被确定时就被确定了比如set,在使用时都进行泛型指定<br>在实现Comparable<Employee>接口的类中必须提供下列方法<br>int compareTo(Employee other )<br>可用instanceof 检查对象是否实现了某个特定的接口,instancof限定上限	</p>
</blockquote>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>可以为接口提供默认实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Tother)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;;<span class="hljs-comment">// 可以不用实现但既然</span><br>    <span class="hljs-comment">//用处并不大,每一个实际实现都要覆盖这个方法(逻辑覆盖并不是一定要实现),不过有些情况默认方法可能很有用</span><br>    <span class="hljs-comment">// 重要用法: 接口演化</span><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">DeInterface</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">default</span>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size() == <span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeInterface</span>&#123;<br>	<span class="hljs-comment">//不用实现默认方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="异常、断言和日志"><a href="#异常、断言和日志" class="headerlink" title="异常、断言和日志"></a>异常、断言和日志</h1><p><strong>简述:</strong> </p>
<p>程序运行过程发生错误就会”抛出异常”,抛出异常比终止程序灵活,因为可以提供一个”捕获”异常的处理器(handler)对异常情况进行处理,如果没有提供处理器程序就会终止,并在控制台打印信息</p>
<p>异常有两种类型,未检查异常和已检查异常</p>
<ul>
<li>对于已检查异常,编译器会检查是否提供处理器,(提示要添加异常处理的都是已检查异常)</li>
<li>常见的如空指针都属于未检查异常,编译器不会查看,因为应该精心编写代码来避免这些错误</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    handler action<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>异常层次</strong></p>
<p><img src="C:\Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220920092824156.png" srcset="/img/loading.gif" lazyload alt="image-20220920092824156"></p>
<h3 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h3><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
<p>此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>
<p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p>
<h3 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>
<ul>
<li><strong>运行时异常</strong> 	未检查异常</li>
</ul>
<p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<ul>
<li><strong>非运行时异常</strong> （编译异常必须从语法角度进行处理）  已检查异常</li>
</ul>
<p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li><p><strong>应该寻找更加适当的子类或创建自己的异常类</strong></p>
</li>
<li></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/java/" class="category-chain-item">java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/">#java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>java</div>
      <div>https://gouguoqiang.github.io/2022/10/08/all/1java/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ggq</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/09/all/9MicroService/" title="微服务">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">微服务</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/08/mysql/mysql/" title="mysql">
                        <span class="hidden-mobile">mysql</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
