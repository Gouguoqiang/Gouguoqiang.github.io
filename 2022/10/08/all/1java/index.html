<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java | ggq</title><meta name="keywords" content="java"><meta name="author" content="ggq"><meta name="copyright" content="ggq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="todo this的理解   30道选择评测: 异常都继承自哪个类,Math.arround(-11.5),构造函数不能写void 写了就不是默认构造函数了  &#96;&#96;&#96;javaclass Test {private String name &#x3D; “person”;&#x2F;&#x2F;    void Test() {&#x2F;&#x2F;        S">
<meta property="og:type" content="article">
<meta property="og:title" content="java">
<meta property="og:url" content="https://gouguoqiang.github.io/2022/10/08/all/1java/index.html">
<meta property="og:site_name" content="ggq">
<meta property="og:description" content="todo this的理解   30道选择评测: 异常都继承自哪个类,Math.arround(-11.5),构造函数不能写void 写了就不是默认构造函数了  &#96;&#96;&#96;javaclass Test {private String name &#x3D; “person”;&#x2F;&#x2F;    void Test() {&#x2F;&#x2F;        S">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-08T10:49:25.000Z">
<meta property="article:modified_time" content="2022-10-09T13:55:37.189Z">
<meta property="article:author" content="ggq">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://gouguoqiang.github.io/2022/10/08/all/1java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-09 21:55:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ggq</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-08T10:49:25.000Z" title="发表于 2022-10-08 18:49:25">2022-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-09T13:55:37.189Z" title="更新于 2022-10-09 21:55:37">2022-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>  todo this的理解</p>
</blockquote>
<ol>
<li><p>30道选择评测: 异常都继承自哪个类,Math.arround(-11.5),构造函数不能写void 写了就不是默认构造函数了</p>
</li>
<li><p>&#96;&#96;&#96;java<br>class Test {<br>private String name &#x3D; “person”;<br>&#x2F;&#x2F;    void Test() {<br>&#x2F;&#x2F;        System.out.println(“Test…”);<br>&#x2F;&#x2F;    }<br>    Test() {<br>        System.out.println(“Test…”);<br>    }<br>}<br>public class Main extends Test{<br>&#x2F;&#x2F;学一下自己建树<br>Main() {<br>    System.out.println(“MAain..”);<br>}<br><br>public static void main(String[] args) {<br>&#x2F;&#x2F;        new Test();<br>    new Main();<br>}<br>}<br>&#x2F;*<br>Test…<br>MAain..<br>  *&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## </span><br><span class="line"></span><br><span class="line">A：静态方法是一个属于类而不属于对象(实例)的方法。（√）</span><br><span class="line"></span><br><span class="line">B：静态方法只能访问静态数据。无法访问非静态数据(实例变量)。（√）</span><br><span class="line"></span><br><span class="line">C：静态方法只能调用其他静态方法，不能从中调用非静态方法。（√）</span><br><span class="line"></span><br><span class="line">![img](http://uploadfiles.nowcoder.com/images/20150921/458054_1442766565525_E93E59ACFE1791E0A5503384BEBDC544)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">byte b = 1;</span><br><span class="line">char c = 1;</span><br><span class="line">short s = 1;</span><br><span class="line">int i = 1;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 三目，一边为byte另一边为char，结果为int</span></span><br><span class="line"><span class="comment">// 其它情况结果为两边中范围大的。适用包装类型</span></span><br><span class="line">i = <span class="literal">true</span>? b : c;<span class="comment">// int</span></span><br><span class="line">b = <span class="literal">true</span>? b : b; <span class="comment">// byte</span></span><br><span class="line">s = <span class="literal">true</span>? b : s;<span class="comment">// short</span></span><br><span class="line"><span class="comment">// 表达式，两边为byte,short,char，结果为int型</span></span><br><span class="line"><span class="comment">// 其它情况结果为两边中范围大的。适用包装类型</span></span><br><span class="line">i = b + c; <span class="comment">// int</span></span><br><span class="line">i = b + b; <span class="comment">// int</span></span><br><span class="line">i = b + s; <span class="comment">// int</span></span><br><span class="line"><span class="comment">// 当 a 为基本数据类型时，a += b，相当于 a = (a) (a + b)</span></span><br><span class="line"><span class="comment">// 当 a 为包装类型时， a += b 就是 a = a + b</span></span><br><span class="line">b += s; <span class="comment">// 没问题</span></span><br><span class="line">c += i; <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">// 常量任君搞，long以上不能越</span></span><br><span class="line">b = (<span class="type">char</span>) <span class="number">1</span>+ (<span class="type">short</span>) <span class="number">1</span>+ (<span class="type">int</span>) <span class="number">1</span>; <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">// i = (long) 1 // 错误</span></span><br></pre></td></tr></table></figure>



<h1 id="第2章-Java-概述"><a href="#第2章-Java-概述" class="headerlink" title="第2章 Java 概述"></a>第2章 Java 概述</h1><h2 id="2-1-Java核心机制-JVM"><a href="#2-1-Java核心机制-JVM" class="headerlink" title="2.1 Java核心机制-JVM"></a>2.1 Java核心机制-JVM</h2><ol>
<li><p>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在 JDK 中.</p>
</li>
<li><p>对于不同的平台，有不同的虚拟机。</p>
</li>
<li><p>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行</p>
</li>
</ol>
<p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129214031555.png" alt="image-20220129214031555"></p>
<h2 id="2-2JDK-JRE"><a href="#2-2JDK-JRE" class="headerlink" title="2.2JDK JRE"></a>2.2JDK JRE</h2><ol>
<li>JDK 的全称(Java Development Kit Java 开发工具包)<br>JDK &#x3D; JRE + java 的开发工具 [java, javac,javadoc,javap 等]</li>
<li>JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独<br>安装 JRE 了。<br>2.7.2JRE 基本介绍</li>
<li>JRE(Java Runtime Environment Java 运行环境)<br>JRE &#x3D; JVM + Java 的核心类库[类]</li>
<li>包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，<br>计算机中只需要安装 JRE 即可。</li>
<li>JDK &#x3D; JRE + 开发工具集（例如 Javac,java 编译工具等)</li>
<li>JRE &#x3D; JVM + Java SE 标准类库（java 核心类库）</li>
<li>如果只想运行开发好的 .class 文件，只需要JRE</li>
</ol>
<h2 id="2-3-java开发注意事项"><a href="#2-3-java开发注意事项" class="headerlink" title="2.3 java开发注意事项"></a>2.3 java开发注意事项</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是 java 的快速入门， 演示 java 的开发步骤</span></span><br><span class="line"><span class="comment">//对代码的相关说明</span></span><br><span class="line"><span class="comment">//1. public class Hello 表示 Hello 是一个类,是一个 public 公有的类</span></span><br><span class="line"><span class="comment">//2. Hello&#123; &#125; 表示一个类的开始和结束</span></span><br><span class="line"><span class="comment">//3. public static void main(String[] args) 表示一个主方法,即我们程序的入口</span></span><br><span class="line"><span class="comment">//4. main() &#123;&#125; 表示方法的开始和结束</span></span><br><span class="line"><span class="comment">//5. System.out.println(&quot;hello,world~&quot;); 表示输出&quot;hello,world~&quot;到屏幕</span></span><br><span class="line"><span class="comment">//6. ;表示语句结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"><span class="comment">//编写一个 main 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;韩顺平教育 hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个源文件中最多只能有一个 public 类。其它类的个数不限。[演示]</span></span><br><span class="line"><span class="comment">//Dog 是一个类</span></span><br><span class="line"><span class="comment">//编译后，每一个类，都对于一个.class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"><span class="comment">//一个源文件中最多只能有一个 public 类。其它类的个数不限，也可以将 main 方法写在非 public 类中，</span></span><br><span class="line"><span class="comment">//然后指定运行非 public 类，这样入口方法就是非 public 的 main 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello, 小狗狗~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello, 小老虎~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的所有都跟class相关 </p>
<h1 id="第3章-变量"><a href="#第3章-变量" class="headerlink" title="第3章 变量"></a>第3章 变量</h1><h2 id="3-1数据类型与API"><a href="#3-1数据类型与API" class="headerlink" title="3.1数据类型与API"></a>3.1数据类型与API</h2><p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129215338872.png" alt="image-20220129215338872"></p>
<p>JavaAPI（application program interface 应用程序编程接口）文档</p>
<p>中文 <a target="_blank" rel="noopener" href="http://www.matools.com/">www.matools.com</a></p>
<p>Java 提供了大量的类，API告诉开发者如何使用这些类</p>
<h2 id="3-2Java类的组织形式"><a href="#3-2Java类的组织形式" class="headerlink" title="3.2Java类的组织形式"></a>3.2Java类的组织形式</h2><p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129215828134.png" alt="image-20220129215828134"></p>
<h2 id="3-3-char-字符编码"><a href="#3-3-char-字符编码" class="headerlink" title="3.3 char+字符编码"></a>3.3 char+字符编码</h2><p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129220005077.png" alt="image-20220129220005077"></p>
<p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129220054774.png" alt="image-20220129220054774"></p>
<h2 id="3-4Unicode"><a href="#3-4Unicode" class="headerlink" title="3.4Unicode"></a>3.4Unicode</h2><p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129220213127.png" alt="image-20220129220213127"></p>
<h2 id="3-5UTF-8"><a href="#3-5UTF-8" class="headerlink" title="3.5UTF-8"></a>3.5UTF-8</h2><p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129220239687.png" alt="image-20220129220239687"></p>
<h2 id="3-6基本数据类型转换"><a href="#3-6基本数据类型转换" class="headerlink" title="3.6基本数据类型转换"></a>3.6基本数据类型转换</h2><p>精度小的类型自动转化为精度大的</p>
<p>有多种类型混合运算，系统首先自动将所有数据转换成容量最大的那种数据类型再计算</p>
<p>当把容量大的赋值给容量小的就会报错，反之自动类型转换</p>
<p>byte short 和char 不会自动转换 ，在计算式首先转换为int类型</p>
<p>boolen不参与转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="comment">//float d1 = n1 + 1.1;//错误 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class="line"><span class="comment">//double d1 = n1 + 1.1;//对 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class="line"><span class="type">float</span> <span class="variable">d1</span> <span class="operator">=</span> n1 + <span class="number">1.1F</span>;<span class="comment">//对 n1 + 1.1 =&gt; 结果类型是 float</span></span><br><span class="line"><span class="comment">//细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时，</span></span><br><span class="line"><span class="comment">//就会报错，反之就会进行自动类型转换。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int n2 = 1.1;//错误 double -&gt; int</span></span><br><span class="line"><span class="comment">//细节 3: (byte, short) 和 char 之间不会相互自动转换</span></span><br><span class="line"><span class="comment">//当把具体数赋给 byte 时，(1)先判断该数是否在 byte 范围内，如果是就可以</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//对 , -128-127</span></span><br><span class="line"><span class="comment">// int n2 = 1; //n2 是 int</span></span><br><span class="line"><span class="comment">// byte b2 = n2; //错误，原因： 如果是变量赋值，判断类型</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// char c1 = b1; //错误， 原因 byte 不能自动转成 char</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">韩顺平循序渐进学 Java 零基础</span><br><span class="line">第 <span class="number">48</span>页</span><br><span class="line"><span class="comment">//细节 4: byte，short，char 他们三者可以计算，在计算时首先转换为 int 类型</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//short s2 = b2 + s1;//错, b2 + s1 =&gt; int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> b2 + s1;<span class="comment">//对, b2 + s1 =&gt; int</span></span><br><span class="line"><span class="comment">//byte b4 = b2 + b3; //错误: b2 + b3 =&gt; int</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//boolean 不参与转换</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">pass</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//int num100 = pass;// boolean 不参与类型的自动转换</span></span><br><span class="line"><span class="comment">//自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型</span></span><br><span class="line"><span class="comment">//看一道题</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b4</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num200</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">num300</span> <span class="operator">=</span> <span class="number">1.1F</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">num500</span> <span class="operator">=</span> b4 + s3 + num200 + num300; <span class="comment">//float -&gt; double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-7-强制类型转换"><a href="#3-7-强制类型转换" class="headerlink" title="3.7 强制类型转换"></a>3.7 强制类型转换</h2><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成<br>精度降低或溢出,格外要注意</p>
<h1 id="第4章-运算符"><a href="#第4章-运算符" class="headerlink" title="第4章 运算符"></a>第4章 运算符</h1><h2 id="4-1命名规范"><a href="#4-1命名规范" class="headerlink" title="4.1命名规范"></a>4.1命名规范</h2><p>1.包名：多单词组成时所有字母都小写：aaa.bbb.ccc &#x2F;&#x2F;比如 com.hsp.crm</p>
<ol start="2">
<li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]<br>比如： TankShotGame</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小<br>驼峰， 简称 驼峰法]<br>比如： tankShotGame</li>
<li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ<br>比如 ：定义一个所得税率 TAX_RATE</li>
<li>后面我们学习到 类，包，接口，等时，我们的命名规范要这样遵守,更加详细的看文档.</li>
</ol>
<h2 id="4-2键盘输入语句"><a href="#4-2键盘输入语句" class="headerlink" title="4.2键盘输入语句"></a>4.2键盘输入语句</h2><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java , 需要一个 扫描器(对象), 就是 Scanner</p>
<p>步骤 ： 1) 导入该类的所在包, java.util.* 2) 创建该类对象（声明变量） 3) 调用里面的功能</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>import java.util.Scanner;&#x2F;&#x2F;表示把 java.util 下的 Scanner 类导入<br>public class Input {<br>&#x2F;&#x2F;编写一个 main 方法<br>public static void main(String[] args) {<br>&#x2F;&#x2F;演示接受用户的输入<br>&#x2F;&#x2F;步骤<br>&#x2F;&#x2F;Scanner 类 表示 简单文本扫描器，在 java.util 包<br>&#x2F;&#x2F;1. 引入&#x2F;导入 Scanner 类所在的包<br>&#x2F;&#x2F;2. 创建 Scanner 对象 , new 创建一个对象,体会<br>&#x2F;&#x2F; myScanner 就是 Scanner 类的对象<br>Scanner myScanner &#x3D; new Scanner(System.in);<br>&#x2F;&#x2F;3. 接收用户输入了， 使用 相关的方法<br>System.out.println(“请输入名字”);<br>&#x2F;&#x2F;当程序执行到 next 方法时，会等待用户输入~~~ String name &#x3D; myScanner.next(); &#x2F;&#x2F;接收用户输入字符串<br>System.out.println(“请输入年龄”);<br>int age &#x3D; myScanner.nextInt(); &#x2F;&#x2F;接收用户输入 int<br>System.out.println(“请输入薪水”);<br>double sal &#x3D; myScanner.nextDouble(); &#x2F;&#x2F;接收用户输入 double<br>System.out.println(“人的信息如下:”);<br>韩顺平循序渐进学 Java 零基础<br>第 81页<br>System.out.println(“名字&#x3D;” + name</p>
<ul>
<li>“ 年龄&#x3D;” + age + “ 薪水&#x3D;” + sal);<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 第6章 数组</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 6.1数组的使用</span><br><span class="line"></span><br><span class="line">### 使用方式1-动态初始化</span><br><span class="line"></span><br><span class="line">//(1) 第一种动态分配方式</span><br><span class="line">//double scores[] = new double[5];</span><br><span class="line">//(2) 第 2 种动态分配方式， 先声明数组，再 new 分配空间</span><br><span class="line">double scores[] ; //声明数组， 这时 scores 是 null</span><br><span class="line">scores = new double[5]; // 分配内存空间，可以存放数据</span><br><span class="line"></span><br><span class="line">### 使用方式2-动态初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 使用方式3-静态初始化</span><br><span class="line"></span><br><span class="line">int[] a =&#123;2,3,5,6,9,41,2,1&#125;;</span><br><span class="line"></span><br><span class="line">## 6.2数组使用细节</span><br><span class="line"></span><br><span class="line">1) 数组是多个相同类型数据的组合，实现对这些数据的统一管理</span><br><span class="line">2) 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。</span><br><span class="line">3) 数组创建后，如果没有赋值，有默认值</span><br><span class="line">int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null</span><br><span class="line">4) 使用数组的步骤 1. 声明数组并开辟空间 2 给数组各个元素赋值 3 使用数组</span><br><span class="line">5) 数组的下标是从 0 开始的。</span><br><span class="line">6) 数组下标必须在指定范围内使用，否则报：下标越界异常，比如</span><br><span class="line">韩顺平循序渐进学 Java 零基础</span><br><span class="line">第 148页</span><br><span class="line">int [] arr=new int[5]; 则有效下标为 0-4</span><br><span class="line">7) 数组属引用类型，数组型数据是对象(object)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 6.3数组赋值机制</span><br><span class="line"></span><br><span class="line">[(141条消息) java堆，栈，常量池最通俗易懂的图文解释_我的博客-CSDN博客_堆栈常量池](https://blog.csdn.net/weixin_41804049/article/details/80393892)</span><br><span class="line"></span><br><span class="line">1）基本类型赋值，这个值就是具体的数据，而且互不影响</span><br><span class="line"></span><br><span class="line">2)数组在默认情况下是引用传递，赋的值是地址 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">栈存放基本数据类型的变量值 和对象的引用</span><br><span class="line"></span><br><span class="line">堆存放对象的具体实例 new出来的</span><br><span class="line"></span><br><span class="line">字符串常量对象存放在常量池中</span><br><span class="line"></span><br><span class="line">## 6.4数组拷贝</span><br><span class="line"></span><br><span class="line">//将 int[] arr1 = &#123;10,20,30&#125;; 拷贝到 arr2 数组, //要求数据空间是独立的. int[] arr1 = &#123;10,20,30&#125;;</span><br><span class="line">//创建一个新的数组 arr2,开辟新的数据空间</span><br><span class="line">//大小 arr1.length;</span><br><span class="line">int[] arr2 = new int[arr1.length];</span><br><span class="line">//遍历 arr1 ，把每个元素拷贝到 arr2 对应的元素位置</span><br><span class="line">for(int i = 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br><span class="line">//老师修改 arr2， 不会对 arr1 有影响. arr2[0] = 100;</span><br><span class="line">//输出 arr1</span><br><span class="line">System.out.println(&quot;====arr1 的元素====&quot;);</span><br><span class="line">for(int i = 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">System.out.println(arr1[i]);//10,20,30</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 6.5数组翻转</span><br><span class="line"></span><br><span class="line">方式 1：通过找规律反转 【思路分析】</span><br><span class="line"></span><br><span class="line">public class ArrayReverse &#123;</span><br><span class="line">//编写一个 main 方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//定义数组</span><br><span class="line">int[] arr = &#123;11, 22, 33, 44, 55, 66&#125;;</span><br><span class="line">//老韩思路</span><br><span class="line">//规律</span><br><span class="line">//1. 把 arr[0] 和 arr[5] 进行交换 &#123;66,22,33,44,55,11&#125;</span><br><span class="line">韩顺平循序渐进学 Java 零基础</span><br><span class="line">第 155页</span><br><span class="line">//2. 把 arr[1] 和 arr[4] 进行交换 &#123;66,55,33,44,22,11&#125;</span><br><span class="line">//3. 把 arr[2] 和 arr[3] 进行交换 &#123;66,55,44,33,22,11&#125;</span><br><span class="line">//4. 一共要交换 3 次 = arr.length / 2</span><br><span class="line">//5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]</span><br><span class="line">//代码</span><br><span class="line">//优化</span><br><span class="line">int temp = 0;</span><br><span class="line">int len = arr.length; //计算数组的长度</span><br><span class="line">for( int i = 0; i &lt; len / 2; i++) &#123;</span><br><span class="line">temp = arr[len - 1 - i];//保存</span><br><span class="line">arr[len - 1 - i] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;===翻转后数组===&quot;);</span><br><span class="line">for(int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.print(arr[i] + &quot;\t&quot;);//66,55,44,33,22,11</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式 2：使用逆序赋值方式 【思路分析, 学员自己完成】 ArrayReverse02.java</span><br><span class="line">public class ArrayReverse02 &#123;</span><br><span class="line">//编写一个 main 方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//定义数组</span><br><span class="line">int[] arr = &#123;11, 22, 33, 44, 55, 66&#125;;</span><br><span class="line">//使用逆序赋值方式</span><br><span class="line">//老韩思路</span><br><span class="line">//1. 先创建一个新的数组 arr2 ,大小 arr.length</span><br><span class="line">//2. 逆序遍历 arr ,将 每个元素拷贝到 arr2 的元素中(顺序拷贝)</span><br><span class="line">//3. 建议增加一个循环变量 j -&gt; 0 -&gt; 5</span><br><span class="line">int[] arr2 = new int[arr.length];</span><br><span class="line">//逆序遍历 arr</span><br><span class="line">for(int i = arr.length - 1, j = 0; i &gt;= 0; i--, j++) &#123;</span><br><span class="line">arr2[j] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">//4. 当 for 循环结束，arr2 就是一个逆序的数组 &#123;66, 55, 44,33, 22, 11&#125;</span><br><span class="line">//5. 让 arr 指向 arr2 数据空间, 此时 arr 原来的数据空间就没有变量引用</span><br><span class="line">// 会被当做垃圾，销毁</span><br><span class="line">arr = arr2;</span><br><span class="line">System.out.println(&quot;====arr 的元素情况=====&quot;);</span><br><span class="line">//6. 输出 arr 看看</span><br><span class="line">for(int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">韩顺平循序渐进学 Java 零基础</span><br><span class="line">第 157页</span><br><span class="line">System.out.print(arr[i] + &quot;\t&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 6.6数组添加/扩容</span><br><span class="line"></span><br><span class="line">思路分析</span><br><span class="line"></span><br><span class="line">1. 定义初始数组 int[] arr = &#123;1,2,3&#125;//下标 0-2</span><br><span class="line"></span><br><span class="line">2. 定义一个新的数组 int[] arrNew = new int[arr.length+1];</span><br><span class="line"></span><br><span class="line">3. 遍历 arr 数组，依次将 arr 的元素拷贝到 arrNew 数组</span><br><span class="line"></span><br><span class="line">4. 将 4 赋给 arrNew[arrNew.length - 1] = 4;把 4 赋给 arrNew 最后一个元素</span><br><span class="line"></span><br><span class="line">5. 让 arr 指向 arrNew ; arr = arrNew; 那么 原来 arr 数组就被销毁</span><br><span class="line"></span><br><span class="line">6. 创建一个 Scanner 可以接受用户输入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 补充1.</span><br><span class="line"></span><br><span class="line">&gt; 基本数据类型：</span><br><span class="line"></span><br><span class="line">  四类八种：</span><br><span class="line"></span><br><span class="line">1. 整数型：byte（1字节）、short（2字节） 、int（4字节）、long（8字节）long 类型要在后面加L，（可以省略，超出int 的范围时需要加L）</span><br><span class="line">2. 浮点型：float（4字节）、double（8字节）float 类型 要在数字后面加f</span><br><span class="line">3. 字符型：char（2字节）</span><br><span class="line">4. 布尔型：boolean（1位）是非对错</span><br><span class="line"></span><br><span class="line">&gt; 引用数据类型：</span><br><span class="line"></span><br><span class="line">除了基本数据类型之外的、都叫引用类型。</span><br><span class="line"></span><br><span class="line">1. 类</span><br><span class="line">2. 接口</span><br><span class="line">3. 数组</span><br><span class="line">4. 枚举</span><br><span class="line"></span><br><span class="line">## 4.什么是字节</span><br><span class="line"></span><br><span class="line">1. 位（bit）：</span><br><span class="line">   是计算机 内部数据 存储的最小单位，11001100是一个八位二进制数。</span><br><span class="line">2. 字节（byte）</span><br><span class="line">   是计算机中 数据处理 的基本单位，习惯上用大写B来表示；1B（byte字节）1B（byte字节） = 8bit （位）</span><br><span class="line">3. 字符：</span><br><span class="line">   是指计算机中使用的字母、数字、和符号</span><br><span class="line"></span><br><span class="line">&gt; 常见单位换算</span><br><span class="line"></span><br><span class="line">  1bit 表示 1位</span><br><span class="line">  1byte 表示一个字节 1B=8b</span><br><span class="line">  1024b = 1kb</span><br><span class="line">  1024kb = 1M</span><br><span class="line">  1024M = 1G</span><br><span class="line">  1024G = 1TB</span><br><span class="line"></span><br><span class="line">## 5.进制问题</span><br><span class="line"></span><br><span class="line">&gt; 进制说明</span><br><span class="line"></span><br><span class="line">二进制：0b</span><br><span class="line">十进制：默认</span><br><span class="line">八进制：0 逢八进一</span><br><span class="line">十六进制：0x 逢十六进一</span><br><span class="line"></span><br><span class="line">银行业务用什么表示？用BigDecimal类 数学工具类</span><br><span class="line">不能使用浮点数。</span><br><span class="line"></span><br><span class="line">- float：</span><br><span class="line"></span><br><span class="line">  浮点数是有限的 舍入误差，大约，接近但不等于</span><br><span class="line"></span><br><span class="line">- double：</span><br><span class="line">  最好完全使用浮点数进行比较</span><br><span class="line">  最好完全使用浮点数进行比较</span><br><span class="line">  最好完全使用浮点数进行比较</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    int i1 = 10;</span><br><span class="line">    int i2 = 010;</span><br><span class="line">    int i3 = 0x10;</span><br><span class="line">    System.out.println(i1);//10</span><br><span class="line">    System.out.println(i2);//8</span><br><span class="line">    System.out.println(i3);//16</span><br><span class="line"></span><br><span class="line">    float f = 0.1f;//0.1</span><br><span class="line">    double d = 1.0/10;//0.1</span><br><span class="line">    System.out.println(f == d);//false</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>字符扩展？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">System.out.println(c1);</span><br><span class="line">System.out.println((<span class="type">int</span>)c1);<span class="comment">//97 强制转换</span></span><br><span class="line">System.out.println(c2);</span><br><span class="line">System.out.println((<span class="type">int</span>)c2);<span class="comment">//20013</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>所有的字符本质还是数字<br>编码问题 Unicode 表：（97 &#x3D; a，65 &#x3D; A） 编码 占了两个字节</p>
<p>转义字符<br>\t 制表符<br>\n 换行<br>…</p>
<h2 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6.类型转换"></a>6.类型转换</h2><blockquote>
<p>通过查看byte包装类型得到：byte 最大值信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>   <span class="variable">MIN_VALUE</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>   <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<hr>
<p>  由于java是强类型语言，所以要进行有些运算的时候，需要用到类型转换。</p>
<p>  低 ———————————————-&gt;高<br>  byte，short，char—&gt;，int—&gt;，float—&gt;，long—&gt;，double</p>
<p>  运算中，不同类型的数据先转换为同一类型，然后进行运算。（小数优先级高于整数）</p>
<blockquote>
<p>强制类型转换</p>
</blockquote>
<p>高到低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) i;<span class="comment">//内存溢出</span></span><br><span class="line">System.out.println(i);<span class="comment">//128</span></span><br><span class="line">System.out.println(b);<span class="comment">//-128</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>自动类型转换</p>
</blockquote>
<p>低到高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> i;</span><br><span class="line">System.out.println(i);<span class="comment">//128</span></span><br><span class="line">System.out.println(d);<span class="comment">//128.0</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
</blockquote>
<ol>
<li>不能对布尔类型进行转换。（不能把人转成猪，可以把男人转女人）</li>
<li>不能把对象类型转换为不相干的类型。</li>
<li>在把高容量转换为低容量的时候，需要强制转换。</li>
<li>转换的时候可能存在内存溢出，或者精度问题。</li>
</ol>
<h1 id="Java流程控制"><a href="#Java流程控制" class="headerlink" title="Java流程控制"></a>Java流程控制</h1><h2 id="1-Scanner-类"><a href="#1-Scanner-类" class="headerlink" title="1.Scanner 类"></a>1.Scanner 类</h2><p>  通过scanner 类的next() 与nextLine() 方法获取输入的字符串，在读取我们一般需要使用hasNext() 与 hasNextLine() 判断是否还有输入的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//从键盘接收数据</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;使用next方式接收：&quot;</span>);</span><br><span class="line">    <span class="comment">//判断是否还有输入</span></span><br><span class="line">    <span class="keyword">if</span> (sc.hasNext())&#123;</span><br><span class="line">        <span class="comment">//next() 只读取第一个字符串</span></span><br><span class="line">        <span class="comment">//String str = sc.next();</span></span><br><span class="line">        <span class="comment">//nextLine() 获取一行数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;用户输入是：&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">    sc.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<h2 id="next-："><a href="#next-：" class="headerlink" title="next()："></a>next()：</h2><ol>
<li>一定要读取到有效字符后才可以结束输入。</li>
<li>对输入有效字符之前遇到的空白，next（）方法会自动将其去掉。</li>
<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li>
<li>next（）方法不能得到有空格的不能得到有空格的字符串</li>
</ol>
<h2 id="nextLine"><a href="#nextLine" class="headerlink" title="nextLine():"></a>nextLine():</h2><ol>
<li>以Enter为结束符，也就是说 nextLine() 方法返回的是输入回车之前的所有字符</li>
<li>可以获得空白。</li>
</ol>
<h2 id="4-switch-多选择语句"><a href="#4-switch-多选择语句" class="headerlink" title="4.switch 多选择语句"></a>4.switch 多选择语句</h2><p>  switch case 语句判断一个变量和与一系列值中某个值相等，每个值称为一个分支。<br>  switch 语句中的变量类型可以是：</p>
<ol>
<li>byte、short、int、或者是char</li>
<li>从 Java SE 7开始</li>
<li>switch 开始支持字符串 String 类型了</li>
<li>同时case 标签必须为字符串常量或字面量</li>
</ol>
<h1 id="第7章面向对象基础部分"><a href="#第7章面向对象基础部分" class="headerlink" title="第7章面向对象基础部分"></a>第7章面向对象基础部分</h1><h2 id="7-1创建对象"><a href="#7-1创建对象" class="headerlink" title="7.1创建对象"></a>7.1创建对象</h2><ol>
<li>先声明再创建<br> Cat cat ; &#x2F;&#x2F;声明对象 cat<br> cat &#x3D; new Cat(); &#x2F;&#x2F;创建</li>
<li>直接创建<br> Cat cat &#x3D; new Cat();</li>
</ol>
<p>创建对象 在方法区加载	</p>
<h2 id="7-2Java-内存的结构分析"><a href="#7-2Java-内存的结构分析" class="headerlink" title="7.2Java 内存的结构分析"></a>7.2Java 内存的结构分析</h2><ol>
<li><p>栈： 一般存放基本数据类型(局部变量)</p>
</li>
<li><p>堆： 存放对象(Cat cat , 数组等)</p>
</li>
<li><p>方法区：常量池(常量，比如字符串)， 类加载信息</p>
</li>
<li><p>示意图 [Cat (name, age, price)]<br> Java 创建对象的流程简单分析<br> Person p &#x3D; new Person();<br> p.name &#x3D; “jack”;<br> p.age &#x3D; 10</p>
</li>
<li><p>先加载 Person 类信息(属性和方法信息, 只会加载一次)</p>
</li>
<li><p>在堆中分配空间, 进行默认初始化(看规则)</p>
</li>
<li><p>把地址赋给 p , p 就指向对象</p>
</li>
<li><p>进行指定初始化， 比如 p.name &#x3D;”jack”</p>
</li>
<li><p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220201213124076.png" alt="image-20220201213124076"></p>
</li>
</ol>
<p>方法的调用机制原理</p>
<p>1.当程序执行到方法时，就会开辟一个独立的空间（栈空间）</p>
<p>2.当方法执行完毕，或者执行到return语句时就会返回</p>
<p>3.返回到调用方法的地方</p>
<p>4.返回后继续执行方法后面的代码</p>
<p>5.当main方法（栈）执行完毕，整个程序退出</p>
<p>方法的访问修饰符</p>
<p><img src="http://uploadfiles.nowcoder.com/images/20150921/458054_1442766565525_E93E59ACFE1791E0A5503384BEBDC544" alt="img"></p>
<p>方法的返回数据类型</p>
<p>void可无return，或者return;</p>
<h2 id="7-4成员方法传参机制"><a href="#7-4成员方法传参机制" class="headerlink" title="7.4成员方法传参机制"></a>7.4成员方法传参机制</h2><h3 id="7-4-1基本数据类型的传参机制"><a href="#7-4-1基本数据类型的传参机制" class="headerlink" title="7.4.1基本数据类型的传参机制"></a>7.4.1基本数据类型的传参机制</h3><p>基本数据类型，传递的是值 ，形参的任何改变不影响实参</p>
<h3 id="7-4-2引用数据类型的传参机制"><a href="#7-4-2引用数据类型的传参机制" class="headerlink" title="7.4.2引用数据类型的传参机制"></a>7.4.2引用数据类型的传参机制</h3><p>B 类中编写一个方法 test100，可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化？会变化</p>
<p>B 类中编写一个方法 test200，可以接收一个 Person(age,sal)对象，在方法中修改该对象属性，看看原来的对象是否变化？会变化</p>
<p>引用类型传递的是地址（传递也是值，但是值是地址）</p>
<p>方法栈 </p>
<p>如果对方法传入的引入对象 然后对引入对象进行更改，并没有对原指针更改，而是将指针传给另一个值，可以根据这个地址更改原来指向的对象的属性，但不能更改原来的对象的地址</p>
<p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220202033837223.png" alt="image-20220202033837223"></p>
<p>&#x2F;&#x2F;编写一个方法 copyPerson，可以复制一个 Person 对象，返回复制的对象。克隆对象，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意要求得到新对象和原来的对象是两个独立的对象，只是他们的属性相同</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//编写方法的思路</span></span><br><span class="line"><span class="comment">//1. 方法的返回类型 Person</span></span><br><span class="line"><span class="comment">//2. 方法的名字 copyPerson</span></span><br><span class="line"><span class="comment">//3. 方法的形参 (Person p)</span></span><br><span class="line"><span class="comment">//4. 方法体, 创建一个新对象，并复制属性，返回即可</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">copyPerson</span><span class="params">(Person p)</span> &#123;</span><br><span class="line"><span class="comment">//创建一个新的对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p2.name = p.name; <span class="comment">//把原来对象的名字赋给 p2.name</span></span><br><span class="line">p2.age = p.age; <span class="comment">//把原来对象的年龄赋给 p2.age</span></span><br><span class="line"><span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-4-3方法的递归调用"><a href="#7-4-3方法的递归调用" class="headerlink" title="7.4.3方法的递归调用"></a>7.4.3方法的递归调用</h3><p>每次调用方法 都会形成方法栈 占用主栈的空间</p>
<h2 id="7-5方法重载"><a href="#7-5方法重载" class="headerlink" title="7.5方法重载"></a>7.5方法重载</h2><p>java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！ 比如：System.out.println(); out 是 PrintStream 类</p>
<p>方法名相同</p>
<p>形参列表必须不同 形参类型 或个数 或顺序</p>
<h2 id="7-6可变参数"><a href="#7-6可变参数" class="headerlink" title="7.6可变参数"></a>7.6可变参数</h2><h3 id="7-6-1基本概念"><a href="#7-6-1基本概念" class="headerlink" title="7.6.1基本概念"></a>7.6.1基本概念</h3><p>java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。<br>就可以通过可变参数实现</p>
<h3 id="7-6-2基本语法"><a href="#7-6-2基本语法" class="headerlink" title="7.6.2基本语法"></a>7.6.2基本语法</h3><p>访问修饰符 返回类型 方法名(数据类型… 形参名) {<br>}</p>
<h3 id="7-6-3快速入门案例"><a href="#7-6-3快速入门案例" class="headerlink" title="7.6.3快速入门案例"></a>7.6.3快速入门案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">看一个案例 类 HspMethod，方法 sum 【可以计算 <span class="number">2</span> 个数的和，<span class="number">3</span> 个数的和 ， <span class="number">4.</span> <span class="number">5</span>， 。。】</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarParameter01</span> &#123;</span><br><span class="line"><span class="comment">//编写一个 main 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">HspMethod</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HspMethod</span>();</span><br><span class="line">System.out.println(m.sum(<span class="number">1</span>, <span class="number">5</span>, <span class="number">100</span>)); <span class="comment">//106</span></span><br><span class="line">System.out.println(m.sum(<span class="number">1</span>,<span class="number">19</span>)); <span class="comment">//20</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HspMethod</span> &#123;</span><br><span class="line"><span class="comment">//可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。</span></span><br><span class="line"><span class="comment">//可以使用方法重载</span></span><br><span class="line"><span class="comment">// public int sum(int n1, int n2) &#123;//2 个数的和</span></span><br><span class="line"><span class="comment">// return n1 + n2;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// public int sum(int n1, int n2, int n3) &#123;//3 个数的和</span></span><br><span class="line"><span class="comment">// return n1 + n2 + n3;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// public int sum(int n1, int n2, int n3, int n4) &#123;//4 个数的和</span></span><br><span class="line"><span class="comment">// return n1 + n2 + n3 + n4;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//..... //上面的三个方法名称相同，功能相同, 参数个数不同-&gt; 使用可变参数优化</span></span><br><span class="line"><span class="comment">//1. int... 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多)</span></span><br><span class="line"><span class="comment">//2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组</span></span><br><span class="line"><span class="comment">//3. 遍历 nums 求和即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span> &#123;</span><br><span class="line"><span class="comment">//System.out.println(&quot;接收的参数个数=&quot; + nums.length);</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">res += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-6-4注意事项和使用细节"><a href="#7-6-4注意事项和使用细节" class="headerlink" title="7.6.4注意事项和使用细节"></a>7.6.4注意事项和使用细节</h3><p>可变参数的实参可以为0或任意多个</p>
<p>可变参数的实参可以维数组</p>
<p>可变参数的本质就是数组</p>
<p>可变参数可以和普通参数一起放在形参列表，但必须保证可变参数在最后</p>
<p>一个形参列表中只能出现一个可变参数</p>
<p>&#x2F;&#x2F;细节: 可变参数的实参可以为数组<br>int[] arr &#x3D; {1, 2, 3};<br>T t1 &#x3D; new T();<br>t1.f1(arr);<br>}<br>}<br>class T {<br>public void f1(int… nums) {<br>System.out.println(“长度&#x3D;” + nums.length);<br>}</p>
<h2 id="7-7作用域（对类来说）"><a href="#7-7作用域（对类来说）" class="headerlink" title="7.7作用域（对类来说）"></a>7.7作用域（对类来说）</h2><p>1.在Java编程中，主要的变量就是属性（成员变量）和局部变量</p>
<p>2.我们说的局部变量一般是指在成员方法中定义的变量</p>
<p>3.Java中作用域的分类</p>
<p>全局变量：也就是属性，作用域为整个类体</p>
<p>局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中</p>
<p>4.属性可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用因为没有默认值</p>
<p>5.注意事项和细节使用</p>
<p>属性和局部变量可以重名，访问时采用就近原则</p>
<p>同作用域不能重名</p>
<p>属性生命周期较长 伴随着对象的创建而创建，伴随着对象的销毁而销毁</p>
<p>局部变量伴随着代码快的执行而创建，伴随着代码的结束而销毁。即在一次方法调用过程中</p>
<p>作用域范围不同 ：属性可以被本类使用，或其他类使用（通过对象调用） 局部变量只能在本类中对应的方法中调用</p>
<p>修饰符不同 属性可以加修饰符，局部变量不可以加修饰符</p>
<h2 id="7-8构造方法-x2F-构造器"><a href="#7-8构造方法-x2F-构造器" class="headerlink" title="7.8构造方法&#x2F;构造器"></a>7.8构造方法&#x2F;构造器</h2><h1 id="第10章面向对象高级部分"><a href="#第10章面向对象高级部分" class="headerlink" title="第10章面向对象高级部分"></a>第10章面向对象高级部分</h1><h2 id="10-5-final-关键字"><a href="#10-5-final-关键字" class="headerlink" title="10.5 final 关键字"></a>10.5 final 关键字</h2><p>可以修饰类，属性，方法和局部变量</p>
<p>第13 章 常用类</p>
<h2 id="13-1包装类"><a href="#13-1包装类" class="headerlink" title="13.1包装类"></a>13.1包装类</h2><p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220129225411862.png" alt="image-20220129225411862"></p>
<p>有了类的特点，就可以调用类的方法</p>
<h3 id="13-1-1装箱拆箱"><a href="#13-1-1装箱拆箱" class="headerlink" title="13.1.1装箱拆箱"></a>13.1.1装箱拆箱</h3><p>JDK5前 装箱：基本数据类型-&gt;包装类 拆箱相反 手动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Integer01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//演示 int &lt;--&gt; Integer 的装箱和拆箱</span></span><br><span class="line"><span class="comment">//jdk5 前是手动装箱和拆箱</span></span><br><span class="line"><span class="comment">//手动装箱 int-&gt;Integer</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(n1);<span class="comment">//两种方式都可以 都是手动装箱</span></span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line"><span class="comment">//Integer -&gt; int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br><span class="line"><span class="comment">//jdk5 后，就可以自动装箱和自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">//自动装箱 int-&gt;Integer</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> n2; <span class="comment">//底层使用的是 Integer.valueOf(n2)</span></span><br><span class="line"><span class="comment">//自动拆箱 Integer-&gt;int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> integer2; <span class="comment">//底层仍然使用的是 intValue()方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-1-2包装类之间的转化"><a href="#13-1-2包装类之间的转化" class="headerlink" title="13.1.2包装类之间的转化"></a>13.1.2包装类之间的转化</h3><p>案例演示, 以 Integer 和 String 转换为例，其它类似:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.wrapper;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrapperVSString</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//包装类(Integer)-&gt;String</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line">  <span class="comment">//方式 1</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">//方式 2</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i.toString();</span><br><span class="line">  <span class="comment">//方式 3</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">  <span class="comment">//String -&gt; 包装类(Integer)</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.parseInt(str4);<span class="comment">//使用到自动装箱</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4);<span class="comment">//构造器</span></span><br><span class="line">  System.out.println(<span class="string">&quot;ok~~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-1-3Integer-类和-Character类的常用方法"><a href="#13-1-3Integer-类和-Character类的常用方法" class="headerlink" title="13.1.3Integer 类和 Character类的常用方法"></a>13.1.3Integer 类和 Character类的常用方法</h3><p>public class WrapperMethod {<br>public static void main(String[] args) {<br>System.out.println(Character.isDigit(‘a’));&#x2F;&#x2F;判断是不是数字<br>System.out.println(Character.isLetter(‘a’));&#x2F;&#x2F;判断是不是字母<br>System.out.println(Character.isUpperCase(‘a’));&#x2F;&#x2F;判断是不是大写<br>System.out.println(Character.isLowerCase(‘a’));&#x2F;&#x2F;判断是不是小写<br>System.out.println(Character.isWhitespace(‘a’));&#x2F;&#x2F;判断是不是空格<br>System.out.println(Character.toUpperCase(‘a’));&#x2F;&#x2F;转成大写<br>System.out.println(Character.toLowerCase(‘A’));&#x2F;&#x2F;转成小写</p>
<h3 id="13-1-4面试题"><a href="#13-1-4面试题" class="headerlink" title="13.1.4面试题"></a>13.1.4面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrapperExercise02</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j); <span class="comment">//False</span></span><br><span class="line"><span class="comment">//所以，这里主要是看范围 -128 ~ 127 就是直接返回</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回</span></span><br><span class="line"><span class="comment">//2. 如果不在 -128~127,就直接 new Integer(i)</span></span><br><span class="line"><span class="comment">public static Integer valueOf(int i) &#123;</span></span><br><span class="line"><span class="comment">if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span></span><br><span class="line"><span class="comment">return IntegerCache.cache[i + (-IntegerCache.low)];</span></span><br><span class="line"><span class="comment">return new Integer(i);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//底层 Integer.valueOf(1); -&gt; 阅读源码</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//底层 Integer.valueOf(1);</span></span><br><span class="line">System.out.println(m == n); <span class="comment">//T</span></span><br><span class="line"><span class="comment">//所以，这里主要是看范围 -128 ~ 127 就是直接返回</span></span><br><span class="line"><span class="comment">//，否则，就 new Integer(xx);</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;<span class="comment">//底层 Integer.valueOf(1);</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;<span class="comment">//底层 Integer.valueOf(1);</span></span><br><span class="line">System.out.println(x == y);<span class="comment">//False</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="13-2-String-类（双引号括起来）"><a href="#13-2-String-类（双引号括起来）" class="headerlink" title="13.2 String 类（双引号括起来）"></a>13.2 String 类（双引号括起来）</h2><h3 id="13-2-1-String-类的理解和创建对象"><a href="#13-2-1-String-类的理解和创建对象" class="headerlink" title="13.2.1 String 类的理解和创建对象"></a>13.2.1 String 类的理解和创建对象</h3><p>字符串常量用双引号扩起的字符序列 ： “你好”，”12.97”等</p>
<p>使用Unicode编码 一个字符（不区分字母还是汉子)占两个字节</p>
<p>String 类常用构造器（看手册）</p>
<p>&#x2F;&#x2F;1.String 对象用于保存字符串，也就是一组字符序列<br>&#x2F;&#x2F;2. “jack” 字符串常量, 双引号括起的字符序列<br>&#x2F;&#x2F;3. 字符串的字符使用 Unicode 字符编码，一个字符(不区分字母还是汉字)占两个字节<br>&#x2F;&#x2F;4. String 类有很多构造器，构造器的重载<br>&#x2F;&#x2F; 常用的有 String s1 &#x3D; new String(); &#x2F;&#x2F;<br>&#x2F;&#x2F;String s2 &#x3D; new String(String original);<br>&#x2F;&#x2F;String s3 &#x3D; new String(char[] a);<br>&#x2F;&#x2F;String s4 &#x3D; new String(char[] a,int startIndex,int count)<br>&#x2F;&#x2F;String s5 &#x3D; new String(byte[] b)<br>&#x2F;&#x2F;5. String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】<br>&#x2F;&#x2F; 接口 Comparable [String 对象可以比较大小]<br>&#x2F;&#x2F;6. String 是 final 类，不能被其他的类继承<br>&#x2F;&#x2F;7. String 有属性 private final char value[]; 用于存放字符串内容<br>&#x2F;&#x2F;8. 一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向<br>&#x2F;&#x2F; 新的地址，但是单个字符内容是可以变化</p>
<h3 id="13-2-2创建String对象的两种方式"><a href="#13-2-2创建String对象的两种方式" class="headerlink" title="13.2.2创建String对象的两种方式"></a>13.2.2创建String对象的两种方式</h3><p>方式一：直接赋值 String s &#x3D; “ashndkjand”;</p>
<p>方式二: 调用构造器 String s &#x3D; new String( “ashndkjand”);</p>
<h3 id="13-2-3两种方式的区别"><a href="#13-2-3两种方式的区别" class="headerlink" title="13.2.3两种方式的区别"></a>13.2.3两种方式的区别</h3><p>方式一：先从常量池找是否有 “ashndkjand”数据空间，若有则直接指向，若没有则在常量池中创建，然后指向</p>
<p>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的”ashndkjand”空间。如果常量池中没有 “ashndkjand”空间，重新创建，如果有value直接指向常量池， s最终指向的对空间</p>
<h2 id="13-3字符串的特性"><a href="#13-3字符串的特性" class="headerlink" title="13.3字符串的特性"></a>13.3字符串的特性</h2><p>​	<img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220202143350591.png" alt="image-20220202143350591"></p>
<h2 id="13-4-String类的常见方法"><a href="#13-4-String类的常见方法" class="headerlink" title="13.4 String类的常见方法"></a>13.4 String类的常见方法</h2><p>​	String类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringMethod01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">**<span class="comment">//1. equals 前面已经讲过了. 比较内容是否相同，区分大小写**</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//</span></span><br><span class="line">**<span class="comment">// 2.equalsIgnoreCase 忽略大小写的判断内容是否相等**</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;johN&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;john&quot;</span>.equalsIgnoreCase(username)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Failure!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">**<span class="comment">// 3.length 获取字符的个数，字符串的长度**</span></span><br><span class="line">System.out.println(<span class="string">&quot;韩顺平&quot;</span>.length());</span><br><span class="line">**<span class="comment">// 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1**</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;wer@terwe@g&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s1.indexOf(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">System.out.println(index);<span class="comment">// 3</span></span><br><span class="line">System.out.println(<span class="string">&quot;weIndex=&quot;</span> + s1.indexOf(<span class="string">&quot;we&quot;</span>));<span class="comment">//0</span></span><br><span class="line">**<span class="comment">// 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1**</span></span><br><span class="line">s1 = <span class="string">&quot;wer@terwe@g@&quot;</span>;</span><br><span class="line">index = s1.lastIndexOf(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">System.out.println(index);<span class="comment">//11</span></span><br><span class="line">System.out.println(<span class="string">&quot;ter 的位置=&quot;</span> + s1.lastIndexOf(<span class="string">&quot;ter&quot;</span>));<span class="comment">//4</span></span><br><span class="line">**<span class="comment">// 6.substring 截取指定范围的子串**</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;hello,张三&quot;</span>;</span><br><span class="line"><span class="comment">//下面 name.substring(6) 从索引 6 开始截取后面所有的内容</span></span><br><span class="line">System.out.println(name.substring(<span class="number">6</span>));<span class="comment">//截取后面的字符</span></span><br><span class="line"><span class="comment">//name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置</span></span><br><span class="line">System.out.println(name.substring(<span class="number">2</span>,<span class="number">5</span>));<span class="comment">//llo</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringMethod02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">**<span class="comment">// 1.toUpperCase 转换成大写**</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;heLLo&quot;</span>;</span><br><span class="line">System.out.println(s.toUpperCase());<span class="comment">//HELLO</span></span><br><span class="line">**<span class="comment">// 2.toLowerCase**</span></span><br><span class="line">System.out.println(s.toLowerCase());<span class="comment">//hello</span></span><br><span class="line">**<span class="comment">// 3.concat 拼接字符串**</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;宝玉&quot;</span>;</span><br><span class="line">s1 = s1.concat(<span class="string">&quot;林黛玉&quot;</span>).concat(<span class="string">&quot;薛宝钗&quot;</span>).concat(<span class="string">&quot;together&quot;</span>);</span><br><span class="line">System.out.println(s1);<span class="comment">//宝玉林黛玉薛宝钗 together</span></span><br><span class="line">**<span class="comment">// 4.replace 替换字符串中的字符**</span></span><br><span class="line">s1 = <span class="string">&quot;宝玉 and 林黛玉 林黛玉 林黛玉&quot;</span>;</span><br><span class="line"><span class="comment">//在 s1 中，将 所有的 林黛玉 替换成薛宝钗</span></span><br><span class="line"><span class="comment">// 老韩解读: s1.replace() 方法执行后，返回的结果才是替换过的. // 注意对 s1 没有任何影响</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s11</span> <span class="operator">=</span> s1.replace(<span class="string">&quot;宝玉&quot;</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">System.out.println(s1);<span class="comment">//宝玉 and 林黛玉 林黛玉 林黛玉</span></span><br><span class="line">System.out.println(s11);<span class="comment">//jack and 林黛玉 林黛玉 林黛玉</span></span><br><span class="line">**<span class="comment">// 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\等**</span></span><br><span class="line"><span class="type">String</span> <span class="variable">poem</span> <span class="operator">=</span> <span class="string">&quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;</span>;</span><br><span class="line"><span class="comment">//老韩解读：</span></span><br><span class="line"><span class="comment">// 1. 以 , 为标准对 poem 进行分割 , 返回一个数组</span></span><br><span class="line"><span class="comment">// 2. 在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \</span></span><br><span class="line">String[] split = poem.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">poem = <span class="string">&quot;E:\\aaa\\bbb&quot;</span>;</span><br><span class="line">split = poem.split(<span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;==分割后内容===&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; split.length; i++) &#123;</span><br><span class="line">System.out.println(split[i]);</span><br><span class="line">&#125;</span><br><span class="line">**<span class="comment">// 6.toCharArray 转换成字符数组**</span></span><br><span class="line">s = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] chs = s.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">System.out.println(chs[i]);</span><br><span class="line">&#125;</span><br><span class="line">**<span class="comment">// 7.compareTo 比较两个字符串的大小，如果前者大，**</span></span><br><span class="line">**<span class="comment">// 则返回正数，后者大，则返回负数，如果相等，返回 0**</span></span><br><span class="line"><span class="comment">// 老韩解读</span></span><br><span class="line"><span class="comment">// (1) 如果长度相同，并且每个字符也相同，就返回 0</span></span><br><span class="line"><span class="comment">// (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小</span></span><br><span class="line"><span class="comment">// 就返回 if (c1 != c2) &#123;</span></span><br><span class="line"><span class="comment">// return c1 - c2;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// (3) 如果前面的部分都相同，就返回 str1.len - str2.len</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;jcck&quot;</span>;<span class="comment">// len = 3</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span>;<span class="comment">// len = 4</span></span><br><span class="line">System.out.println(a.compareTo(b)); <span class="comment">// 返回值是 &#x27;c&#x27; - &#x27;a&#x27; = 2 的值</span></span><br><span class="line">**<span class="comment">// 8.format 格式字符串**</span></span><br><span class="line"><span class="comment">/* 占位符有:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">%s 字符串 %c 字符 %d 整型 %.2f 浮点型</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;john&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">56.857</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有的信息都拼接在一个字符串. String info =</span></span><br><span class="line"><span class="string">&quot;我的姓名是&quot;</span> + name + <span class="string">&quot;年龄是&quot;</span> + age + <span class="string">&quot;,成绩是&quot;</span> + score + <span class="string">&quot;性别是&quot;</span> + gender + <span class="string">&quot;。希望大家喜欢我！</span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line">System.out.println(info);</span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. %s , %d , %.2f %c 称为占位符</span></span><br><span class="line"><span class="comment">//2. 这些占位符由后面变量来替换</span></span><br><span class="line"><span class="comment">//3. %s 表示后面由 字符串来替换</span></span><br><span class="line"><span class="comment">//4. %d 是整数来替换</span></span><br><span class="line"><span class="comment">//5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理</span></span><br><span class="line"><span class="comment">//6. %c 使用 char 类型来替换</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formatStr</span> <span class="operator">=</span> <span class="string">&quot;我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">info2</span> <span class="operator">=</span> String.format(formatStr, name, age, score, gender);</span><br><span class="line">System.out.println(<span class="string">&quot;info2=&quot;</span> + info2);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//7 split()（分裂）根据匹配给定的正则表达式来拆分字符串</span></span><br><span class="line">   <span class="comment">//注意、.、$、|、等转义字符，必须加\\ 注意：多个分隔符可以用|作为连字符 </span></span><br><span class="line">    <span class="keyword">public</span> String[] split(String regex, <span class="type">int</span> limit)</span><br><span class="line">        <span class="comment">//regex 正则表达式分隔符 limit 分割的份数</span></span><br><span class="line">        <span class="comment">//return 字符串</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-5-StringBuffer类"><a href="#13-5-StringBuffer类" class="headerlink" title="13.5 StringBuffer类"></a>13.5 StringBuffer类</h2><h3 id="13-5-1基本介绍"><a href="#13-5-1基本介绍" class="headerlink" title="13.5.1基本介绍"></a>13.5.1基本介绍</h3><p>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删。</p>
<p>很多方法与String相同 ，但StringBuilder是可变长度的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuffer01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. StringBuffer 的直接父类 是 AbstractStringBuilder</span></span><br><span class="line"><span class="comment">//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化</span></span><br><span class="line"><span class="comment">//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final</span></span><br><span class="line"><span class="comment">// 该 value 数组存放 字符串内容，引出存放在堆中的</span></span><br><span class="line"><span class="comment">//4. StringBuffer 是一个 final 类，不能被继承</span></span><br><span class="line"><span class="comment">//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)</span></span><br><span class="line"><span class="comment">// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-5-2-String-vs-StringBuffer"><a href="#13-5-2-String-vs-StringBuffer" class="headerlink" title="13.5.2 String vs StringBuffer"></a>13.5.2 String vs StringBuffer</h3><p>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低</p>
<p>StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更改内容，不用每次都更新地址效率较高</p>
<h3 id="13-5-3-两者的互相转换"><a href="#13-5-3-两者的互相转换" class="headerlink" title="13.5.3 两者的互相转换"></a>13.5.3 两者的互相转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringAndStringBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//看 String——&gt;StringBuffer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello tom&quot;</span>;</span><br><span class="line"><span class="comment">//方式 1 使用构造器</span></span><br><span class="line"><span class="comment">//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line"><span class="comment">//方式 2 使用的是 append 方法</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer1 = stringBuffer1.append(str);</span><br><span class="line"><span class="comment">//看看 StringBuffer -&gt;String</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;韩顺平教育&quot;</span>);</span><br><span class="line"><span class="comment">//方式 1 使用 StringBuffer 提供的 toString 方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuffer3.toString();</span><br><span class="line"><span class="comment">//方式 2: 使用构造器来搞定</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringBuffer3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-5-4-StringBuffer-类常见方法"><a href="#13-5-4-StringBuffer-类常见方法" class="headerlink" title="13.5.4 StringBuffer 类常见方法"></a>13.5.4 StringBuffer 类常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferMethod</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">s.append(<span class="string">&#x27;,&#x27;</span>);<span class="comment">// &quot;hello,&quot;</span></span><br><span class="line">s.append(<span class="string">&quot;张三丰&quot;</span>);<span class="comment">//&quot;hello,张三丰&quot;</span></span><br><span class="line">s.append(<span class="string">&quot;赵敏&quot;</span>).append(<span class="number">100</span>).append(<span class="literal">true</span>).append(<span class="number">10.5</span>);<span class="comment">//&quot;hello,张三丰赵敏 100true10.5&quot;</span></span><br><span class="line">    System.out.println(s);<span class="comment">//&quot;hello,张三丰赵敏 100true10.5&quot;</span></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</span></span><br><span class="line"><span class="comment">* 解读: 删除 11~14 的字符 [11, 14)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s.delete(<span class="number">11</span>, <span class="number">14</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰赵敏 true10.5&quot;</span></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line"><span class="comment">//老韩解读，使用 周芷若 替换 索引 9-11 的字符 [9,11)</span></span><br><span class="line">s.replace(<span class="number">9</span>, <span class="number">11</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰周芷若 true10.5&quot;</span></span><br><span class="line"><span class="comment">//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">indexOf</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">System.out.println(indexOf);<span class="comment">//6</span></span><br><span class="line"><span class="comment">//插</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//老韩解读，在索引为 9 的位置插入 &quot;赵敏&quot;,原来索引为 9 的内容自动后移</span></span><br><span class="line">s.insert(<span class="number">9</span>, <span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰赵敏周芷若 true10.5&quot;</span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">System.out.println(s.length());<span class="comment">//22</span></span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="13-6-StringBuilder-线程不安全的StringBuffer"><a href="#13-6-StringBuilder-线程不安全的StringBuffer" class="headerlink" title="13.6 StringBuilder 线程不安全的StringBuffer"></a>13.6 StringBuilder 线程不安全的StringBuffer</h2><h2 id="13-7-Math-类"><a href="#13-7-Math-类" class="headerlink" title="13.7 Math 类"></a>13.7 Math 类</h2><p>Math类包含用于执行基本数学运算的方法，如初等函数、对数、平方根和三角函数。</p>
<p>均为静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathMethod</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//看看 Math 常用的方法(静态方法)</span></span><br><span class="line"><span class="comment">//1.abs 绝对值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">abs</span> <span class="operator">=</span> Math.abs(-<span class="number">9</span>);</span><br><span class="line">System.out.println(abs);<span class="comment">//9</span></span><br><span class="line"><span class="comment">//2.pow 求幂</span></span><br><span class="line"><span class="type">double</span> <span class="variable">pow</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>, <span class="number">4</span>);<span class="comment">//2 的 4 次方</span></span><br><span class="line">System.out.println(pow);<span class="comment">//16</span></span><br><span class="line"><span class="comment">//3.ceil 向上取整,返回&gt;=该参数的最小整数(转成 double);</span></span><br><span class="line"><span class="type">double</span> <span class="variable">ceil</span> <span class="operator">=</span> Math.ceil(<span class="number">3.9</span>);</span><br><span class="line">System.out.println(ceil);<span class="comment">//4.0</span></span><br><span class="line"><span class="comment">//4.floor 向下取整，返回&lt;=该参数的最大整数(转成 double)</span></span><br><span class="line"><span class="type">double</span> <span class="variable">floor</span> <span class="operator">=</span> Math.floor(<span class="number">4.001</span>);</span><br><span class="line">System.out.println(floor);<span class="comment">//4.0</span></span><br><span class="line"><span class="comment">//5.round 四舍五入 Math.floor(该参数+0.5)</span></span><br><span class="line"><span class="type">long</span> <span class="variable">round</span> <span class="operator">=</span> Math.round(<span class="number">5.51</span>);</span><br><span class="line">System.out.println(round);<span class="comment">//6</span></span><br><span class="line"><span class="comment">//6.sqrt 求开方</span></span><br><span class="line"><span class="type">double</span> <span class="variable">sqrt</span> <span class="operator">=</span> Math.sqrt(<span class="number">9.0</span>);</span><br><span class="line">System.out.println(sqrt);<span class="comment">//3.0</span></span><br><span class="line"><span class="comment">//7.random 求随机数</span></span><br><span class="line"><span class="comment">// random 返回的是 0 &lt;= x &lt; 1 之间的一个随机小数</span></span><br><span class="line"><span class="comment">// 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7</span></span><br><span class="line"><span class="comment">// 即返回一个数 x 2 &lt;= x &lt;= 7</span></span><br><span class="line"><span class="comment">// 解读 Math.random() * (b-a) 返回的就是 0 &lt;= 数 &lt;= b-a</span></span><br><span class="line"><span class="comment">// (1) (int)(a) &lt;= x &lt;= (int)(a + Math.random() * (b-a +1) )</span></span><br><span class="line"><span class="comment">// (2) 使用具体的数给小伙伴介绍 a = 2 b = 7</span></span><br><span class="line"><span class="comment">// (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)</span></span><br><span class="line"><span class="comment">// Math.random()*6 返回的是 0 &lt;= x &lt; 6 小数</span></span><br><span class="line"><span class="comment">// 2 + Math.random()*6 返回的就是 2&lt;= x &lt; 8 小数</span></span><br><span class="line"><span class="comment">// (int)(2 + Math.random()*6) = 2 &lt;= x &lt;= 7</span></span><br><span class="line"><span class="comment">// (3) 公式就是 (int)(a + Math.random() * (b-a +1) )</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println((<span class="type">int</span>)(<span class="number">2</span> + Math.random() * (<span class="number">7</span> - <span class="number">2</span> + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//max , min 返回最大值和最小值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(<span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(<span class="number">45</span>, <span class="number">90</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;min=&quot;</span> + min);</span><br><span class="line">System.out.println(<span class="string">&quot;max=&quot;</span> + max);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-8-Arrays类"><a href="#13-8-Arrays类" class="headerlink" title="13.8 Arrays类"></a>13.8 Arrays类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysMethod01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Integer[] integers = &#123;<span class="number">1</span>, <span class="number">20</span>, <span class="number">90</span>&#125;;</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="comment">// for(int i = 0; i &lt; integers.length; i++) &#123;</span></span><br><span class="line"><span class="comment">// System.out.println(integers[i]);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//直接使用 Arrays.toString 方法，显示数组</span></span><br><span class="line"><span class="comment">// System.out.println(Arrays.toString(integers));//</span></span><br><span class="line"><span class="comment">//演示 sort 方法的使用</span></span><br><span class="line">Integer arr[] = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">89</span>&#125;;</span><br><span class="line"><span class="comment">//进行排序</span></span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. 可以直接使用冒泡排序 , 也可以直接使用 Arrays 提供的 sort 方法排序</span></span><br><span class="line"><span class="comment">//2. 因为数组是引用类型，所以通过 sort 排序后，会直接影响到 实参 arr</span></span><br><span class="line"><span class="comment">//3. sort 重载的，也可以通过传入一个接口 Comparator 实现定制排序</span></span><br><span class="line"><span class="comment">//4. 调用 定制排序 时，传入两个参数 (1) 排序的数组 arr</span></span><br><span class="line"><span class="comment">// (2) 实现了 Comparator 接口的匿名内部类 , 要求实现 compare 方法</span></span><br><span class="line"><span class="comment">//5. 先演示效果，再解释</span></span><br><span class="line"><span class="comment">//6. 这里体现了接口编程的方式 , 看看源码，就明白</span></span><br><span class="line"><span class="comment">// 源码分析</span></span><br><span class="line"><span class="comment">//(1) Arrays.sort(arr, new Comparator()</span></span><br><span class="line"><span class="comment">//(2) 最终到 TimSort 类的 private static &lt;T&gt; void binarySort(T[] a, int lo, int hi, int start, // Comparator&lt;? super T&gt; c)()</span></span><br><span class="line"><span class="comment">//(3) 执行到 binarySort 方法的代码, 会根据动态绑定机制 c.compare()执行我们传入的</span></span><br><span class="line"><span class="comment">// 匿名内部类的 compare ()</span></span><br><span class="line"><span class="comment">// while (left &lt; right) &#123;</span></span><br><span class="line"><span class="comment">// int mid = (left + right) &gt;&gt;&gt; 1;</span></span><br><span class="line"><span class="comment">// if (c.compare(pivot, a[mid]) &lt; 0)</span></span><br><span class="line"><span class="comment">// right = mid;</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// left = mid + 1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//(4) new Comparator() &#123;</span></span><br><span class="line"><span class="comment">// @Override</span></span><br><span class="line"><span class="comment">// public int compare(Object o1, Object o2) &#123;</span></span><br><span class="line"><span class="comment">// Integer i1 = (Integer) o1;</span></span><br><span class="line"><span class="comment">// Integer i2 = (Integer) o2;</span></span><br><span class="line"><span class="comment">// return i2 - i1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//(5) public int compare(Object o1, Object o2) 返回的值&gt;0 还是 &lt;0</span></span><br><span class="line"><span class="comment">// 会影响整个排序结果, 这就充分体现了 接口编程+动态绑定+匿名内部类的综合使用</span></span><br><span class="line"><span class="comment">// 将来的底层框架和源码的使用方式，会非常常见</span></span><br><span class="line"><span class="comment">//Arrays.sort(arr); // 默认排序方法</span></span><br><span class="line"><span class="comment">//定制排序</span></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> (Integer) o1;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> (Integer) o2;</span><br><span class="line"><span class="keyword">return</span> i2 - i1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;===排序后===&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.hspedu.arrays_;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysSortCustom</span> &#123;</span><br><span class="line">韩顺平循序渐进学 Java 零基础</span><br><span class="line">第 <span class="number">575</span>页</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="comment">//bubble01(arr);</span></span><br><span class="line">bubble02(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> (Integer) o1;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> (Integer) o2;</span><br><span class="line"><span class="keyword">return</span> i2 - i1;<span class="comment">// return i2 - i1;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;==定制排序后的情况==&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用冒泡完成排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble01</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line"><span class="comment">//从小到大</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">韩顺平循序渐进学 Java 零基础</span><br><span class="line">第 <span class="number">576</span>页</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结合冒泡 + 定制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble02</span><span class="params">(<span class="type">int</span>[] arr, Comparator c)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line"><span class="comment">//数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定</span></span><br><span class="line"><span class="keyword">if</span> (c.compare(arr[j], arr[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hspedu.arrays_;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysMethod02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">90</span>, <span class="number">123</span>, <span class="number">567</span>&#125;;</span><br><span class="line"><span class="comment">// binarySearch 通过二分搜索法进行查找，要求必须排好</span></span><br><span class="line"><span class="comment">// 老韩解读</span></span><br><span class="line"><span class="comment">//1. 使用 binarySearch 二叉查找</span></span><br><span class="line"><span class="comment">//2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch</span></span><br><span class="line"><span class="comment">//3. 如果数组中不存在该元素，就返回 return -(low + 1); // key not found. int index = Arrays.binarySearch(arr, 567);</span></span><br><span class="line">System.out.println(<span class="string">&quot;index=&quot;</span> + index);</span><br><span class="line"><span class="comment">//copyOf 数组元素的复制</span></span><br><span class="line"><span class="comment">// 老韩解读</span></span><br><span class="line"><span class="comment">//1. 从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中</span></span><br><span class="line"><span class="comment">//2. 如果拷贝的长度 &gt; arr.length 就在新数组的后面 增加 null</span></span><br><span class="line"><span class="comment">//3. 如果拷贝长度 &lt; 0 就抛出异常 NegativeArraySizeException</span></span><br><span class="line"><span class="comment">//4. 该方法的底层使用的是 System.arraycopy()</span></span><br><span class="line">Integer[] newArr = Arrays.copyOf(arr, arr.length);</span><br><span class="line">System.out.println(<span class="string">&quot;==拷贝执行完毕后==&quot;</span>);</span><br><span class="line">韩顺平循序渐进学 Java 零基础</span><br><span class="line">第 <span class="number">578</span>页</span><br><span class="line">System.out.println(Arrays.toString(newArr));</span><br><span class="line"><span class="comment">//ill 数组元素的填充</span></span><br><span class="line">Integer[] num = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. 使用 99 去填充 num 数组，可以理解成是替换原理的元素</span></span><br><span class="line">Arrays.fill(num, <span class="number">99</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;==num 数组填充后==&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(num));</span><br><span class="line"><span class="comment">//equals 比较两个数组元素内容是否完全一致</span></span><br><span class="line">Integer[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">90</span>, <span class="number">123</span>&#125;;</span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. 如果 arr 和 arr2 数组的元素一样，则方法 true;</span></span><br><span class="line"><span class="comment">//2. 如果不是完全一样，就返回 false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">equals</span> <span class="operator">=</span> Arrays.equals(arr, arr2);</span><br><span class="line">System.out.println(<span class="string">&quot;equals=&quot;</span> + equals);</span><br><span class="line"><span class="comment">//asList 将一组值，转换成 list</span></span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. asList 方法，会将 (2,3,4,5,6,1)数据转成一个 List 集合</span></span><br><span class="line"><span class="comment">//2. 返回的 asList 编译类型 List(接口)</span></span><br><span class="line"><span class="comment">//3. asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的</span></span><br><span class="line"><span class="comment">// 静态内部类 private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span></span><br><span class="line"><span class="comment">// implements RandomAccess, java.io.Serializable</span></span><br><span class="line"><span class="type">List</span> <span class="variable">asList</span> <span class="operator">=</span> Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;asList=&quot;</span> + asList);</span><br><span class="line">System.out.println(<span class="string">&quot;asList 的运行类型&quot;</span> + asList.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-9-System类"><a href="#13-9-System类" class="headerlink" title="13.9 System类"></a>13.9 System类</h2><p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220202152301760.png" alt="image-20220202152301760"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.system_;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System_</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//exit 退出当前程序</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;ok1&quot;);</span></span><br><span class="line"><span class="comment">// //老韩解读</span></span><br><span class="line"><span class="comment">// //1. exit(0) 表示程序退出</span></span><br><span class="line"><span class="comment">// //2. 0 表示一个状态 , 正常的状态</span></span><br><span class="line"><span class="comment">// System.exit(0);//</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;ok2&quot;);</span></span><br><span class="line"><span class="comment">//arraycopy ：复制数组元素，比较适合底层调用，</span></span><br><span class="line"><span class="comment">// 一般使用 Arrays.copyOf 完成复制数组</span></span><br><span class="line"><span class="type">int</span>[] src=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] dest = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">// dest 当前是 &#123;0,0,0&#125;</span></span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. 主要是搞清楚这五个参数的含义</span></span><br><span class="line"><span class="comment">//2. // 源数组</span></span><br><span class="line">韩顺平循序渐进学 Java 零基础</span><br><span class="line">第 <span class="number">586</span>页</span><br><span class="line"><span class="comment">// * @param src the source array. // srcPos： 从源数组的哪个索引位置开始拷贝</span></span><br><span class="line"><span class="comment">// * @param srcPos starting position in the source array. // dest : 目标数组，即把源数组的数据拷贝到哪个数组</span></span><br><span class="line"><span class="comment">// * @param dest the destination array. // destPos: 把源数组的数据拷贝到 目标数组的哪个索引</span></span><br><span class="line"><span class="comment">// * @param destPos starting position in the destination data. // length: 从源数组拷贝多少个数据到目标数组</span></span><br><span class="line"><span class="comment">// * @param length the number of array elements to be copied. System.arraycopy(src, 0, dest, 0, src.length);</span></span><br><span class="line"><span class="comment">// int[] src=&#123;1,2,3&#125;;</span></span><br><span class="line">System.out.println(<span class="string">&quot;dest=&quot;</span> + Arrays.toString(dest));<span class="comment">//[1, 2, 3]</span></span><br><span class="line"><span class="comment">//currentTimeMillens:返回当前时间距离 1970-1-1 的毫秒数</span></span><br><span class="line"><span class="comment">// 老韩解读:</span></span><br><span class="line">System.out.println(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-10-BigInteger和BigDecimal类"><a href="#13-10-BigInteger和BigDecimal类" class="headerlink" title="13.10 BigInteger和BigDecimal类"></a>13.10 BigInteger和BigDecimal类</h2><p>应用场景：</p>
<p> BigInteger适合保存较大的整形</p>
<p>BigDecimal适合保存精度更高的浮点型</p>
<p>两者的常见方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigInteger_</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//当我们编程中，需要处理很大的整数，long 不够用</span></span><br><span class="line"><span class="comment">//可以使用 BigInteger 的类来搞定</span></span><br><span class="line"><span class="comment">// long l = 23788888899999999999999999999l;</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;l=&quot; + l);</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;23788888899999999999999999999&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">BigInteger</span>(<span class="string">&quot;10099999999999999999999999999999999999999999999999999999999999999999999999999999999&quot;</span>);</span><br><span class="line">System.out.println(bigInteger);</span><br><span class="line"><span class="comment">//解读</span></span><br><span class="line"><span class="comment">//1. 在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /</span></span><br><span class="line"><span class="comment">//2. 可以创建一个 要操作的 BigInteger 然后进行相应操作</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">add</span> <span class="operator">=</span> bigInteger.add(bigInteger2);</span><br><span class="line">System.out.println(add);<span class="comment">//</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">subtract</span> <span class="operator">=</span> bigInteger.subtract(bigInteger2);</span><br><span class="line">System.out.println(subtract);<span class="comment">//减</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">multiply</span> <span class="operator">=</span> bigInteger.multiply(bigInteger2);</span><br><span class="line">System.out.println(multiply);<span class="comment">//乘</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">divide</span> <span class="operator">=</span> bigInteger.divide(bigInteger2);</span><br><span class="line">System.out.println(divide);<span class="comment">//除</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimal_</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//当我们需要保存一个精度很高的数时，double 不够用</span></span><br><span class="line"><span class="comment">//可以是 BigDecimal</span></span><br><span class="line"><span class="comment">// double d = 1999.11111111111999999999999977788d;</span></span><br><span class="line"><span class="comment">// System.out.println(d);</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1999.11&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">System.out.println(bigDecimal);</span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. 如果对 BigDecimal 进行运算，比如加减乘除，需要使用对应的方法</span></span><br><span class="line"><span class="comment">//2. 创建一个需要操作的 BigDecimal 然后调用相应的方法即可</span></span><br><span class="line">System.out.println(bigDecimal.add(bigDecimal2));</span><br><span class="line">System.out.println(bigDecimal.subtract(bigDecimal2));</span><br><span class="line">System.out.println(bigDecimal.multiply(bigDecimal2));</span><br><span class="line"><span class="comment">//System.out.println(bigDecimal.divide(bigDecimal2));//可能抛出异常 ArithmeticException</span></span><br><span class="line"><span class="comment">//在调用 divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING</span></span><br><span class="line"><span class="comment">//如果有无限循环小数，就会保留 分子 的精度</span></span><br><span class="line">System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="第14章-集合"><a href="#第14章-集合" class="headerlink" title="第14章 集合"></a>第14章 集合</h1><p>Deque是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。</p>
<p>关于Queue的介绍可以看上一篇文章：Java队列Queue使用详解</p>
<p>Deque有三种用途：<br>普通队列(一端进另一端出):<br>Queue queue &#x3D; new LinkedList()或Deque deque &#x3D; new LinkedList()<br>双端队列(两端都可进出)<br>Deque deque &#x3D; new LinkedList()<br>堆栈<br>Deque deque &#x3D; new LinkedList()<br>注意：Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。Deque堆栈操作方法：push()、pop()、peek()。</p>
<p>Deque是一个线性collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。</p>
<p>此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 Deque 实现设计的；在大多数实现中，插入操作不能失败。</p>
<p>下表总结了上述 12 种方法：</p>
<p>第一个元素 (头部)	最后一个元素 (尾部)<br>抛出异常	特殊值	抛出异常	特殊值<br>插入	addFirst(e)	offerFirst(e)	addLast(e)	offerLast(e)<br>删除	removeFirst()	pollFirst()	removeLast()	pollLast()<br>检查	getFirst()	peekFirst()	getLast()	peekLast()<br>Deque接口扩展(继承)了 Queue 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示：</p>
<p>Queue方法	等效Deque方法<br>add(e)	addLast(e)<br>offer(e)	offerLast(e)<br>remove()	removeFirst()<br>poll()	pollFirst()<br>element()	getFirst()<br>peek()	peekFirst()  增加一个方法，可以返回当前栈顶的值, 但是不是真正的 pop</p>
<p>双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 Stack 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示：</p>
<p>堆栈方法	等效Deque方法<br>push(e)	addFirst(e)<br>pop()	removeFirst()<br>peek()	peekFirst(<br>————————————————<br>版权声明：本文为CSDN博主「devnn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/devnn/article/details/82716447">https://blog.csdn.net/devnn/article/details/82716447</a></p>
<p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220221002311468.png" alt="image-20220221002311468"></p>
<h2 id="14-1集合的理解与好处"><a href="#14-1集合的理解与好处" class="headerlink" title="14.1集合的理解与好处"></a>14.1集合的理解与好处</h2><p>数组长度固定不能更改 CRUD（增加 (Create)、读取(Retrieve) (重新得到数据)、更新 (Update)和删除 (Delete)增删改查）不方便</p>
<p>集合可以动态保存任意多个对象（底层源码运用扩容机制），提供了一系列方便的方法，add、remove、set、get等</p>
<h2 id="14-2集合的框架体系"><a href="#14-2集合的框架体系" class="headerlink" title="14.2集合的框架体系"></a>14.2集合的框架体系</h2><p>单列集合</p>
<p>add（“tom”）</p>
<p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20211228165026757.png" alt="image-20211228165026757"></p>
<p>接口定义方法类会自己具体实现各种方法</p>
<p>双列集合 put（“NO1”,“北京”）</p>
<p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20211228165036103.png" alt="image-20211228165036103"></p>
<h2 id="14-3-Collection接口和常用方法"><a href="#14-3-Collection接口和常用方法" class="headerlink" title="14.3 Collection接口和常用方法"></a>14.3 Collection接口和常用方法</h2><p>Collection的实现类 有可以存放重复的元素 有些不可以</p>
<p>​					有些是有序的（list）有些是无序的（set）</p>
<p>Collection接口没有直接的实现子类，是通过子接口set和list来实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Collection 接口常用方法,以实现子类 ArrayList 来演示. CollectionMethod.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hspedu.collection_;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionMethod</span> &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">// add:添加单个元素</span></span><br><span class="line">list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">list.add(<span class="number">10</span>);<span class="comment">//list.add(new Integer(10))</span></span><br><span class="line">list.add(<span class="literal">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">// remove:删除指定元素</span></span><br><span class="line"><span class="comment">//list.remove(0);//删除第一个元素</span></span><br><span class="line">list.remove(<span class="literal">true</span>);<span class="comment">//指定删除某个元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">// contains:查找元素是否存在</span></span><br><span class="line">System.out.println(list.contains(<span class="string">&quot;jack&quot;</span>));<span class="comment">//T</span></span><br><span class="line"><span class="comment">// size:获取元素个数</span></span><br><span class="line">System.out.println(list.size());<span class="comment">//2</span></span><br><span class="line"><span class="comment">// isEmpty:判断是否为空</span></span><br><span class="line">System.out.println(list.isEmpty());<span class="comment">//F</span></span><br><span class="line"><span class="comment">// clear:清空</span></span><br><span class="line">list.clear();</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">// addAll:添加多个元素</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list2.add(<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;三国演义&quot;</span>);</span><br><span class="line">list.addAll(list2);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">// containsAll:查找多个元素是否都存在</span></span><br><span class="line">System.out.println(list.containsAll(list2));<span class="comment">//T</span></span><br><span class="line"><span class="comment">// removeAll：删除多个元素</span></span><br><span class="line">list.add(<span class="string">&quot;聊斋&quot;</span>);</span><br><span class="line">list.removeAll(list2);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);<span class="comment">//[聊斋]</span></span><br><span class="line"><span class="comment">// 说明：以 ArrayList 实现类来演示. &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="第21章-网络编程"><a href="#第21章-网络编程" class="headerlink" title="第21章 网络编程"></a>第21章 网络编程</h1><p>查询 API 的一般流程是：找包→找类或接口→查看类或接口→找方法或变量</p>
<h3 id="21-1网络的相关概念"><a href="#21-1网络的相关概念" class="headerlink" title="21.1网络的相关概念"></a>21.1网络的相关概念</h3><p>计算机网络</p>
<h3 id="21-2InetAddress类"><a href="#21-2InetAddress类" class="headerlink" title="21.2InetAddress类"></a>21.2InetAddress类</h3><h4 id="21-2-1相关方法"><a href="#21-2-1相关方法" class="headerlink" title="21.2.1相关方法"></a>21.2.1相关方法</h4><p>1.获取本机InetAddress对象  InetAddress.getLocalHost 静态方法 ，return LAPTOP-PH64GORS&#x2F;192.168.137.1</p>
<p>2.根据指定主机名&#x2F;域名获取ip地址对象InetAddress.getByName（主机名）</p>
<p>3.获取InetAddress对象的主机名 getHostName</p>
<p>4.获取InetAddress对象的地址 getHostAddress</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 获取本机的InetAddress 对象</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">System.out.println(localHost);<span class="comment">//DESKTOP-S4MP84S/192.168.12.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 根据指定主机名 获取 InetAddress对象</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">host1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;LAPTOP-PH64GORS&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;host1=&quot;</span> + host1);<span class="comment">//DESKTOP-S4MP84S/192.168.12.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 根据域名返回 InetAddress对象, 比如 www.baidu.com 对应</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">host2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;host2=&quot;</span> + host2);<span class="comment">//www.baidu.com / 110.242.68.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 通过 InetAddress 对象，获取对应的地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hostAddress</span> <span class="operator">=</span> host2.getHostAddress();<span class="comment">//IP 110.242.68.4</span></span><br><span class="line">System.out.println(<span class="string">&quot;host2 对应的ip = &quot;</span> + hostAddress);<span class="comment">//110.242.68.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 通过 InetAddress 对象，获取对应的主机名/或者的域名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> host2.getHostName();</span><br><span class="line">System.out.println(<span class="string">&quot;host2对应的主机名/域名=&quot;</span> + hostName); <span class="comment">// www.baidu.com</span></span><br></pre></td></tr></table></figure>

<h3 id="21-3-Socket"><a href="#21-3-Socket" class="headerlink" title="21.3 Socket"></a>21.3 Socket</h3><h4 id="21-3-1基本介绍"><a href="#21-3-1基本介绍" class="headerlink" title="21.3.1基本介绍"></a>21.3.1基本介绍</h4><p>1.套接字（Socket）开发网络应用程序被广泛采用，以至成为事实上的标准</p>
<p>2.通信两端都要是Socket，是两台机器间通信的端点</p>
<p>3.网络通信其实就是Socket的通信</p>
<p>4.Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</p>
<p>5.一般主动发起通信的应用程序属于客户端，等待的为服务端</p>
<p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220113075737710.png" alt="image-20220113075737710"></p>
<h3 id="21-4-TCP网络通信编程"><a href="#21-4-TCP网络通信编程" class="headerlink" title="21.4  TCP网络通信编程"></a>21.4  TCP网络通信编程</h3><p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220113075830893.png" alt="image-20220113075830893"></p>
<h4 id="21-4-1使用字节流"><a href="#21-4-1使用字节流" class="headerlink" title="21.4.1使用字节流"></a>21.4.1使用字节流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP01Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 连接服务端 (ip , 端口）</span></span><br><span class="line">        <span class="comment">//解读: 连接本机的 9999端口, 如果连接成功，返回Socket对象</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端 socket返回=&quot;</span> + socket.getClass());</span><br><span class="line">        <span class="comment">//2. 连接上后，生成Socket, 通过socket.getOutputStream()</span></span><br><span class="line">        <span class="comment">//   得到 和 socket对象关联的输出流对象</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3. 通过输出流，写入数据到 数据通道</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;hello, server&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//4. 关闭流对象和socket, 必须关闭</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端退出.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP01Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 在本机 的9999端口监听, 等待连接</span></span><br><span class="line">        <span class="comment">//   细节: 要求在本机没有其它服务在监听9999</span></span><br><span class="line">        <span class="comment">//   细节：这个 ServerSocket 可以通过 accept() 返回多个Socket[多个客户端连接服务器的并发]</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端，在9999端口监听，等待连接..&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 当没有客户端连接9999端口时，程序会 阻塞, 等待连接</span></span><br><span class="line">        <span class="comment">//   如果有客户端连接，则会返回Socket对象，程序继续</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端 socket =&quot;</span> + socket.getClass());</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4. IO读取</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((readLen = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));<span class="comment">//根据读取到的实际长度，显示内容.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.关闭流和socket</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();<span class="comment">//关闭</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="21-4-2使用字符流"><a href="#21-4-2使用字符流" class="headerlink" title="21.4.2使用字符流"></a>21.4.2使用字符流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 连接服务端 (ip , 端口）</span></span><br><span class="line">        <span class="comment">//解读: 连接本机的 9999端口, 如果连接成功，返回Socket对象</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端 socket返回=&quot;</span> + socket.getClass());</span><br><span class="line">        <span class="comment">//2. 连接上后，生成Socket, 通过socket.getOutputStream()</span></span><br><span class="line">        <span class="comment">//   得到 和 socket对象关联的输出流对象</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3. 通过输出流，写入数据到 数据通道, 使用字符流</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello, server 字符流&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();<span class="comment">//插入一个换行符，表示写入的内容结束, 注意，要求对方使用readLine()!!!!</span></span><br><span class="line">        bufferedWriter.flush();<span class="comment">// 如果使用的字符流，需要手动刷新，否则数据不会写入数据通道</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 获取和socket关联的输入流. 读取数据(字符)，并显示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 关闭流对象和socket, 必须关闭</span></span><br><span class="line">        bufferedReader.close();<span class="comment">//关闭外层流</span></span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端退出.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP03Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 在本机 的9999端口监听, 等待连接</span></span><br><span class="line">        <span class="comment">//   细节: 要求在本机没有其它服务在监听9999</span></span><br><span class="line">        <span class="comment">//   细节：这个 ServerSocket 可以通过 accept() 返回多个Socket[多个客户端连接服务器的并发]</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端，在9999端口监听，等待连接..&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 当没有客户端连接9999端口时，程序会 阻塞, 等待连接</span></span><br><span class="line">        <span class="comment">//   如果有客户端连接，则会返回Socket对象，程序继续</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端 socket =&quot;</span> + socket.getClass());</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//3. 通过socket.getInputStream() 读取客户端写入到数据通道的数据, 显示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4. IO读取, 使用字符流, 老师使用 InputStreamReader 将 inputStream 转成字符流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 获取socket相关联的输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">       <span class="comment">//    使用字符输出流的方式回复信息</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello client 字符流&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();<span class="comment">// 插入一个换行符，表示回复内容的结束</span></span><br><span class="line">        bufferedWriter.flush();<span class="comment">//注意需要手动的flush</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭流和socket</span></span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();<span class="comment">//关闭</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="21-4-3文件发送"><a href="#21-4-3文件发送" class="headerlink" title="21.4.3文件发送"></a>21.4.3文件发送</h4><h4 id="21-4-4-netstat-指令"><a href="#21-4-4-netstat-指令" class="headerlink" title="21.4.4 netstat 指令"></a>21.4.4 netstat 指令</h4><p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220113083050590.png" alt="image-20220113083050590"></p>
<p>telnet ip 端口号 连接服务器</p>
<p>crtl+】 显示字符</p>
<p>用Java连接服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;time-a.nist.gov&quot;</span>, <span class="number">13</span>); <span class="comment">//打开一个关键字，负责启动该程序内部和外部的通信 若连接失败 它将抛出</span></span><br><span class="line">     <span class="comment">// 一个UnknownHostException,</span></span><br><span class="line">     <span class="comment">// 如果存在其他问题将抛出一个IOException 因为UnknownException是IOException的一个子类 这仅是示例程序仅捕获超类的异常</span></span><br><span class="line">      <span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(s.getInputStream(), StandardCharsets.UTF_8))</span><br><span class="line"><span class="comment">//一旦套接字打开 Socket 类中的getInputStream 类就会返回一个InputSteam对象，该对象可以像任何其他流对象使用，该程序一旦获得了</span></span><br><span class="line">        <span class="comment">//这个流 该程序会将直接把每一行打印到标准输出 该程序只适用非常简单的服务器</span></span><br><span class="line">        <span class="comment">//在比较复杂的网络程序中 客户端发送请求而服务器可能在响应结束是并不立刻断开连接</span></span><br><span class="line">        <span class="comment">//java库隐藏了建立网络连接和通过连接发送数据的复杂过程</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates the InetAddress class. Supply a host name as command-line</span></span><br><span class="line"><span class="comment"> * argument, or run without command-line arguments to see the address of the local host.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.02 2012-06-05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cay Horstmann</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressTest</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">         InetAddress[] addresses = InetAddress.getAllByName(host);<span class="comment">//为给定的主机名创建一个InetAddress对象</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="keyword">for</span> (InetAddress a : addresses)</span><br><span class="line">            System.out.println(a);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="type">InetAddress</span> <span class="variable">localHostAddress</span> <span class="operator">=</span> InetAddress.getLocalHost(); <span class="comment">//为本机主机创建一个InetAddress对象</span></span><br><span class="line">         System.out.println(localHostAddress);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InetAddress</p>
<p>Socket</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>byte是字节类型</p>
<p>char 是unicode 是万国码 16位 兼容assic</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>自动向上类型转换</p>
<p>强制向下转换(对表达式强转)</p>
<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p>&amp;gt 则返回 1</p>
<p>&amp;lt 则返回 -1</p>
<p>sort 默认从小到大,比较器不关注sort,只关注传递大小信息</p>
<p>lamda随便写写  基本类型不支持比较器</p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220824094548657.png" alt="image-20220824094548657"></p>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><blockquote>
<p>创建文件对象,对对象进行操作 文件夹或文件皆可抽象为file,但文件夹不能被输入输出</p>
</blockquote>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>字节与字符的区别</p>
<p>字节(Byte)是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位。</p>
<p>字符(Character)计算机中使用的字母、数字、字和符号，比如’A’、’B’、’$’、’&amp;’等。</p>
<p>一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/05/242dd42a2834349bfaa71500c4ea15ce37d3be96.jpeg" alt="img"></p>
<p><strong>字节与字符：</strong></p>
<ul>
<li>ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。</li>
<li>UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。</li>
<li>Unicode 编码中，一个英文为一个字节，一个中文为两个字节。</li>
<li>符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 <strong>.</strong> 占1个字节的大小，中文句号 <strong>。</strong>占2个字节的大小。</li>
<li>UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode 扩展区的一些汉字存储需要 4 个字节）。</li>
<li>UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。</li>
</ul>
<p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220824100349380.png" alt="image-20220824100349380"></p>
<p><strong>输出流默认覆盖写,文件不存在则创建文件</strong></p>
<h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>1、外部类前可以修饰：public、default、abstract、final</p>
<ul>
<li><p>对于顶级类(外部类)来说，只有两种修饰符：public和默认(default)。因为外部类的上一单元是包，所以外部类只有两个作用域：同包，任何位置。因此，只需要两种控制权限：包控制权限和公开访问权限，也就对应两种控制修饰符：public和默认(default)。可以满足所有的情况了。</p>
<p>如果类使用了private修饰符，说明是个内部类。内部类的上一级是外部类，那么对应的有四种访问控制修饰符：本类(private)，同包(default)，父子类(protected)，任何位置(public)。当一个内部类使用了private修饰后，只能在该类的外部类内部使用。</p>
<p>上面这些都是平时使用司空见惯的，但是为什么是这种情况呢？</p>
<p>可以想一下，一个java项目是不可能在一个class里面完成的。mvc模式中，是把类分为三层，一层层调用类。如果定义为私有的和受保护的就无法调用。换句话说，对于一个java文件，要么就是自己单独运行，要么就是被其他程序作为库调用，如果一个java文件的类被private修饰，那么是不是其他的程序或是类是无法使用它的，那么他作为一个单独的文件就没啥用了。如果它作为单个文件运行，类加载怎么找到它呢，因为它对外不可见。同时，也失去了类的存在意义。</p>
</li>
</ul>
<p>2、内部类前可以修饰：public、protected、default、private、abstract、final、static</p>
<p>3、局部(指方法 代码块等)内部类前可以修饰：abstract、final</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>1、 public ：对 所有用户 开放，所有用户都可直接调用<br>2、 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a> ：私有。 除了class自己之外，任何人都不可直接使用 ，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可使用。</p>
<p>default 类内部 与 同包 ,即对于外包的类和子类朋友类相当于为私有不能访问</p>
<p>3、 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=protected&spm=1001.2101.3001.7020">protected</a> ：对于子女、朋友来说，就是public的，可自由使用，无任何限制；而对于其他的外部class，protected就变成private。（ 同一个包中的类，若不在同一个包中，必须为其子孙类才可使用 ）</p>
<h2 id="接口抽象类"><a href="#接口抽象类" class="headerlink" title="接口抽象类"></a>接口抽象类</h2><p>接口里的静态方法，即static修饰的有方法体的方法不会被继承或者实现，但是静态变量会被继承</p>
<p>接口中的static方法不能被继承，也不能被实现类调用，只能被自身调用</p>
<h1 id="Guava入门"><a href="#Guava入门" class="headerlink" title="Guava入门"></a>Guava入门</h1><p>guava就是类库，是java api的增强与扩展，里面有大量的方法供我们使用，使用之前需要引入包</p>
<dependencies>

<pre><code>    &lt;!--guava依赖--&gt;

    &lt;dependency&gt;

        &lt;groupId&gt;com.google.guava&lt;/groupId&gt;

        &lt;artifactId&gt;guava&lt;/artifactId&gt;

        &lt;version&gt;27.0.1&lt;/version&gt;

    &lt;/dependency&gt;
</code></pre>
</dependencies>

<p>guava有哪些方法呢？我们先从以下几方面开始学习：</p>
<p>字符串处理：分割，连接，填充<br>新增的集合类型<br>原生类型<br>1.原生类型</p>
<p> 定义list，map</p>
<p>public void test() {<br>        &#x2F;&#x2F;JDK<br>        List<String> list &#x3D; new ArrayList<String>();<br>        list.add(“a”);<br>        list.add(“b”);<br>        list.add(“c”);<br>        list.add(“d”);<br>        &#x2F;&#x2F;guava<br>        List<String> lists &#x3D; Lists.newArrayList(“a”, “b”, “g”, null, “8”, “9”);<br>        List<String> lists1 &#x3D; Lists.newArrayList();<br>        Map&lt;Integer, String&gt; maps &#x3D; Maps.newHashMap();<br>}<br>guava就是类库，是java api的增强与扩展，里面有大量的方法供我们使用，使用之前需要引入包</String></String></String></String></p>
<dependencies>

<pre><code>    &lt;!--guava依赖--&gt;

    &lt;dependency&gt;

        &lt;groupId&gt;com.google.guava&lt;/groupId&gt;

        &lt;artifactId&gt;guava&lt;/artifactId&gt;

        &lt;version&gt;27.0.1&lt;/version&gt;

    &lt;/dependency&gt;
</code></pre>
</dependencies>

<p>guava有哪些方法呢？我们先从以下几方面开始学习：</p>
<p>字符串处理：分割，连接，填充<br>新增的集合类型<br>原生类型<br>1.原生类型</p>
<p> 定义list，map</p>
<p>public void test() {<br>        &#x2F;&#x2F;JDK<br>        List<String> list &#x3D; new ArrayList<String>();<br>        list.add(“a”);<br>        list.add(“b”);<br>        list.add(“c”);<br>        list.add(“d”);<br>        &#x2F;&#x2F;guava<br>        List<String> lists &#x3D; Lists.newArrayList(“a”, “b”, “g”, null, “8”, “9”);<br>        List<String> lists1 &#x3D; Lists.newArrayList();<br>        Map&lt;Integer, String&gt; maps &#x3D; Maps.newHashMap();<br>}<br>2.新增集合（这里我只讲一下Mulitmap,平时用这个会使代码很方便，这里我就多讲一下）</String></String></String></String></p>
<p>a Multimap的使用</p>
<p>   Multimap就是将相同key的value值放在一个list里面，这样子取相同key下面的所有value值就非常简单了，不然还得for循环去匹配，把相同key值的value值找出来，在进行处理。map&lt;key,value&gt;键值key不能重复，所以当遇到这样子场景的时候map就非常不适合了，guava提供了Multimap适用于该场景。</p>
<p>当我们需要一个map中包含key为String类型，value为List类型的时候，以前我们是这样写的</p>
<p>&#x2F;&#x2F; jdk方式<br>Map&lt;String,List<Integer>&gt; map &#x3D; new HashMap&lt;String,List<Integer>&gt;();<br>List<Integer> list &#x3D; new ArrayList<Integer>();<br>list.add(1);<br>list.add(2);<br>map.put(“aa”, list);<br>System.out.println(map.get(“aa”));&#x2F;&#x2F;[1, 2]</Integer></Integer></Integer></Integer></p>
<p>&#x2F;&#x2F; guava方式<br>Multimap&lt;String,Integer&gt; map &#x3D; ArrayListMultimap.create();<br>map.put(“aa”, 1);<br>map.put(“aa”, 2);<br>System.out.println(map.get(“aa”));  &#x2F;&#x2F;[1, 2]<br> Multimap.get(key)即使没有key值，会返回空的list。</p>
<p> Multimap.keySet()返回的用set<T>表示的不重复key;</T></p>
<p> Multimap.keys()返回的是用Multiset表示的key,key数量跟value值数量一致；</p>
<p> Multimap.containKeys()是表示是否包含这个key;</p>
<p> Multimap.size()返回所有值的个数，而非不同键的个数。要得到不同键的个数，要用Multimap.keySet().size()</p>
<p>想要更多了解Multimap可以参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e0537d878b6c">https://www.jianshu.com/p/e0537d878b6c</a></p>
<p>3.字符串的处理：分割，连接，填充</p>
<p>   a. joiner 连接器</p>
<p>joiner on就是将list用，连接转成字符串</p>
<p>@Test<br>    public void joinerListTest() {<br>        List<String> lists &#x3D; Lists.newArrayList(“a”,”b”,”g”,”8”,”9”);<br>        String result &#x3D; Joiner.on(“,”).join(lists);<br>        System.out.println(result);<br>    }</String></p>
<p>结果：a,b,g,8,9<br>joiner skipNulls()连接跳过null元素(第一个test为了跟第二个进行比对一下)</p>
<p>@Test<br>    public void joinerListTest1() {<br>        List<String> lists &#x3D; Lists.newArrayList(“a”,”b”,”g”,null,”8”,”9”);<br>        String result &#x3D; Joiner.on(“,”).join(lists);<br>        System.out.println(result);<br>    }</String></p>
<p>结果：a,b,g,null,8,9</p>
<p>@Test<br>public void joinerListTest2() {<br>    List<String> lists &#x3D; Lists.newArrayList(“a”,”b,”g”,null,”8”,”9”);<br>    String result &#x3D; Joiner.on(“,”).skipNulls().join(lists);<br>    System.out.println(result);<br>}<br>结果：a,b,g,8,9<br>  如果连接的时候list里面含有null值，会报空指针，因为join实现如下：</String></p>
<ol>
<li><p>public final String join(Iterable&lt;?&gt; parts) {<br>  return this.join(parts.iterator());<br>  }</p>
</li>
<li><p>public final String join(Iterator&lt;?&gt; parts) {<br>  return this.appendTo(new StringBuilder(), parts).toString();<br>  }</p>
</li>
<li><p>@CanIgnoreReturnValue<br>  public final StringBuilder appendTo(StringBuilder builder, Iterator&lt;?&gt; parts) {<br>  try {<br>      this.appendTo((Appendable)builder, (Iterator)parts);<br>      return builder;<br>  } catch (IOException var4) {<br>      throw new AssertionError(var4);<br>  }<br>  }</p>
</li>
<li><p>@CanIgnoreReturnValue<br>  public <A extends appendable> A appendTo(A appendable, Iterator&lt;?&gt; parts) throws IOException {<br>  Preconditions.checkNotNull(appendable);<br>  if (parts.hasNext()) {<br>      appendable.append(this.toString(parts.next()));<br><br>      while(parts.hasNext()) {<br>          appendable.append(this.separator);<br>          appendable.append(this.toString(parts.next()));<br>      }<br>  }<br>  return appendable;<br>  }</A></p>
</li>
<li><p>@CanIgnoreReturnValue<br>  public static <T> T checkNotNull(T reference) {<br>  if (reference &#x3D;&#x3D; null) {<br>      throw new NullPointerException();<br>  } else {<br>      return reference;<br>  }<br>  }<br> joiner useForNull(final String value)用value替换null元素值</T></p>
</li>
</ol>
<p>@Test<br>    public void useNullListTest() {<br>        List<String> lists &#x3D; Lists.newArrayList(“a”, “b”, “g”, null, “8”, “9”);<br>        String result &#x3D; Joiner.on(“,”).useForNull(“哈哈”).join(lists);<br>        System.out.println(result);<br>    }</String></p>
<p>结果：a,b,g,哈哈,8,9<br> joiner withKeyValueSeparator(String value)   map连接器，keyValueSeparator为key和value之间的分隔符</p>
<p>@Test<br>    public void withMapTest() {<br>        Map&lt;Integer, String&gt; maps &#x3D; Maps.newHashMap();<br>        maps.put(1, “哈哈”);<br>        maps.put(2, “压压”);<br>        String result &#x3D; Joiner.on(“,”).withKeyValueSeparator(“:”).join(maps);<br>        System.out.println(result);<br>        System.out.println(maps);<br>    }</p>
<p>结果：<br>1:哈哈,2:压压<br>{1&#x3D;哈哈, 2&#x3D;压压}<br>  b. splitter 拆分器</p>
<p> splitter on 拆分</p>
<p>@Test<br>    public void splitterListTest() {<br>        String test &#x3D; “34344,34,34,哈哈”;<br>        List<String> lists &#x3D; Splitter.on(“,”).splitToList(test);<br>        System.out.println(lists);<br>    }</String></p>
<p>结果：[34344, 34, 34, 哈哈]<br> splitter trimResults 拆分去除前后空格</p>
<p>@Test<br>    public void trimResultListTest() {<br>        String test &#x3D; “  34344,34,34,哈哈 “;<br>        List<String> lists &#x3D; Splitter.on(“,”).trimResults().splitToList(test);<br>        System.out.println(lists);<br>    }</String></p>
<p>结果：[34344, 34, 34, 哈哈]<br>splitter omitEmptyStrings 去除拆分出来空的字符串</p>
<p>@Test<br>    public void omitEmptyStringsTest() {<br>        String test &#x3D; “  3434,434,34,,哈哈 “;<br>        List<String> lists &#x3D; Splitter.on(“,”).omitEmptyStrings().splitToList(test);<br>        System.out.println(lists);<br>    }</String></p>
<p>结果：[  3434, 434, 34, 哈哈 ]<br>splitter fixedLength(int lenght) 把字符串按固定长度分割</p>
<p>@Test<br>    public void fixedLengthTest() {<br>        String test &#x3D; “343443434哈哈”;<br>        List<String> lists &#x3D; Splitter.fixedLength(3).splitToList(test);<br>        System.out.println(lists);<br>    }</String></p>
<p>结果：[343, 443, 434, 哈哈]<br>  b. charMatcher 匹配器</p>
<p>charMatcher is(Char char)  给单一字符匹配</p>
<p>@Test<br>    public void isTest() {<br>        String str &#x3D; “12312,agg”;<br>        CharMatcher charMatcher1 &#x3D; CharMatcher.is(‘g’);<br>        System.out.println(charMatcher1.retainFrom(str));<br>    }</p>
<p>结果：gg<br>charMatcher  retainFrom(String s)  在字符序列中保留匹配字符，移除其他字符</p>
<p>@Test<br>    public void charMatcherTest() {<br>        String str &#x3D; “12312,agg  “;<br>        &#x2F;&#x2F;两个匹配符,先匹配再操作<br>        CharMatcher charMatcher1 &#x3D; CharMatcher.is(‘1’);<br>        CharMatcher charMatcher2 &#x3D; CharMatcher.is(‘2’);<br>        &#x2F;&#x2F;两个CharMatcher或操作<br>        CharMatcher charMatcher3 &#x3D; charMatcher1.or(charMatcher2);<br>        System.out.println(charMatcher3.retainFrom(str));<br>    }</p>
<p>结果：1212<br>charMatcher matchersAllOf(Char char) 测试是否字符序列所有字符都匹配</p>
<p>@Test<br>    public void matchesAllOfTest() {<br>        String str &#x3D; “12312,agg”;<br>        CharMatcher charMatcher1 &#x3D; CharMatcher.is(‘g’);<br>        System.out.println(charMatcher1.matchesAllOf(str));<br>    }</p>
<p>结果：false<br>@Test<br>    public void matchesAllOfTest() {<br>        String str &#x3D; “ggggg”;<br>        CharMatcher charMatcher1 &#x3D; CharMatcher.is(‘g’);<br>        System.out.println(charMatcher1.matchesAllOf(str));<br>    }</p>
<p>结果：true</p>
<h1 id="arr与list转换"><a href="#arr与list转换" class="headerlink" title="arr与list转换"></a>arr与list转换</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ints = &#123;<span class="number">2</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">22</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        <span class="type">long</span>[] longs = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">double</span>[] doubles = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class="line">        Arrays.stream(longs).boxed().collect(Collectors.toList());</span><br><span class="line">        Arrays.stream(doubles).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><strong>直接for,add就完事了反之同理</strong></p>
<p><strong>java数组转list误区</strong><br><strong>一、不能把基本数据类型转化为列表</strong><br>仔细观察可以发现asList接受的参数是一个泛型的变长参数，而基本数据类型是无法泛型化的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">App</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span> [] intarray = &#123; <span class="number">1</span> ,  <span class="number">2</span> ,  <span class="number">3</span> ,  <span class="number">4</span> ,  <span class="number">5</span> &#125;;</span><br><span class="line">     <span class="comment">//List&lt;Integer&gt; list = Arrays.asList(intarray); 编译通不过</span></span><br><span class="line">     List&lt; <span class="type">int</span> []&gt; list = Arrays.asList(intarray);</span><br><span class="line">     System.out.println(list);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">[[I @66d3c617 ]</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>这是因为把int类型的数组当参数了，所以转换后的列表就只包含一个int[]元素。<br>解决方案：<br>要想把基本数据类型的数组转化为其包装类型的list，可以使用guava类库的工具方法，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] intArray = &#123; <span class="number">1</span> ,  <span class="number">2</span> ,  <span class="number">3</span> ,  <span class="number">4</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = Ints.asList(intArray);</span><br></pre></td></tr></table></figure>

<h2 id="第一种方式-未必最佳-使用ArrayList-asList-strArray"><a href="#第一种方式-未必最佳-使用ArrayList-asList-strArray" class="headerlink" title="第一种方式(未必最佳):使用ArrayList.asList(strArray)"></a>第一种方式(未必最佳):使用ArrayList.asList(strArray)</h2><p>使用Arrays工具类Arrays.asList(strArray)方式,转换完成后,只能对List<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>进行查改,不能增删,增删就会抛出UnsupportedOperationException 异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Demo1</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] str = &#123;<span class="string">&quot;fgx&quot;</span>, <span class="string">&quot;lzy&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//注意这个List不是Collections包内的List,而是util包里面的List接口</span></span><br><span class="line">        List&lt;String&gt; ints = Arrays.asList(str);</span><br><span class="line">    	<span class="comment">//这里会报错</span></span><br><span class="line">        ints.add(<span class="string">&quot;laopo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>添加数据报错:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.UnsupportedOperationException</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:<span class="number">148</span>)</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:<span class="number">108</span>)</span><br><span class="line">at JAVA基础.JDK8新特性.Java数组转List.Demo1(Java数组转List.java:<span class="number">20</span>)</span><br><span class="line">at JAVA基础.JDK8新特性.Java数组转List.main(Java数组转List.java:<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">报错原因:Arrays.asList(str)返回值是java.util.Arrays类中一个私有静态内部类 </span><br><span class="line">java.utiil.Arrays.Arraylist,并不是我们平时用的java.util.ArrayList();</span><br><span class="line"></span><br><span class="line">使用场景:Arrays.asList(strArray)方式仅能用在将数组转换为List后，不需要增删其中的值，仅作为数据源读取使用。</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<h2 id="第二种方法-支持增删查改"><a href="#第二种方法-支持增删查改" class="headerlink" title="第二种方法(支持增删查改):"></a>第二种方法(支持增删查改):</h2><p>通过ArrayList的构造器,将Arrays.asList(strArray)的返回值由java.utilArrays.ArrayList转为java.util.ArrayList.<br>关键代码：ArrayList list &#x3D; new ArrayList(Arrays.asList(strArray)) ;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  String[] str = &#123;<span class="string">&quot;fgx&quot;</span>, <span class="string">&quot;lzy&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//注意这个List不是Collections包内的List,而是util包里面的List接口</span></span><br><span class="line">        java.util.ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(str));</span><br><span class="line">        strings.add(<span class="string">&quot;aop&quot;</span>);</span><br><span class="line">        strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/f33d7ecf29754253b15d6abeda2034aa.png" alt="在这里插入图片描述"><br>使用场景:需要在将数组转换为List后，对List进行增删改查操作，在List的数据量不大的情况下，可以使用。</p>
<h2 id="第三种方式-通过集合工具类Collections-addAll-方法-最高效"><a href="#第三种方式-通过集合工具类Collections-addAll-方法-最高效" class="headerlink" title="第三种方式(通过集合工具类Collections.addAll()方法(最高效))"></a>第三种方式(通过集合工具类Collections.addAll()方法(最高效))</h2><p>通过Collections.addAll(arrayList, strArray)方式转换，根据数组的长度创建一个长度相同的List，然后通过Collections.addAll()方法，将数组中的元素转为二进制，然后添加到List中，这是最高效的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Demo3</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//注意这个List不是Collections包内的List,而是util包里面的List接口</span></span><br><span class="line">       String[] str = &#123;<span class="string">&quot;fgx&quot;</span>, <span class="string">&quot;lzy&quot;</span>&#125;;</span><br><span class="line">       java.util.ArrayList&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(str.length);</span><br><span class="line">       Collections.addAll(stringList,str);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四种方式通过JDK8的Stream流将3总基本类型数组转为List"><a href="#第四种方式通过JDK8的Stream流将3总基本类型数组转为List" class="headerlink" title="第四种方式通过JDK8的Stream流将3总基本类型数组转为List"></a>第四种方式通过JDK8的Stream流将3总基本类型数组转为List</h2><p>如果JDK版本在1.8以上,使用流stream来将下列3种数组快速转为List,分别是int[],long[],double[],不支持short[ ],byte[ ],char[]在JDK1.8中暂不支持.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span>[] ints = &#123;<span class="number">2</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">22</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        <span class="type">long</span>[] longs = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">double</span>[] doubles = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class="line">        Arrays.stream(longs).boxed().collect(Collectors.toList());</span><br><span class="line">        Arrays.stream(doubles).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>TIPs:为什么int[]不能直接转为List,而Integer[]可以转为List,而Integer[]就可以转为List了,因为List中的泛型必须是引用类型。</p>
<p><strong>java数组转list误区</strong><br><strong>一、不能把基本数据类型转化为列表</strong><br>仔细观察可以发现asList接受的参数是一个泛型的变长参数，而基本数据类型是无法泛型化的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">App</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span> [] intarray = &#123; <span class="number">1</span> ,  <span class="number">2</span> ,  <span class="number">3</span> ,  <span class="number">4</span> ,  <span class="number">5</span> &#125;;</span><br><span class="line">     <span class="comment">//List&lt;Integer&gt; list = Arrays.asList(intarray); 编译通不过</span></span><br><span class="line">     List&lt; <span class="type">int</span> []&gt; list = Arrays.asList(intarray);</span><br><span class="line">     System.out.println(list);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">[[I @66d3c617 ]</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>这是因为把int类型的数组当参数了，所以转换后的列表就只包含一个int[]元素。<br>解决方案：<br>要想把基本数据类型的数组转化为其包装类型的list，可以使用guava类库的工具方法，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] intArray = &#123; <span class="number">1</span> ,  <span class="number">2</span> ,  <span class="number">3</span> ,  <span class="number">4</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = Ints.asList(intArray);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><strong>二、asList方法返回的是数组的一个视图</strong><br>视图意味着，对这个list的操作都会反映在原数组上，而且这个list是定长的，不支持add、remove等改变长度的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">App</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span> [] intArray = &#123; <span class="number">1</span> ,  <span class="number">2</span> ,  <span class="number">3</span> ,  <span class="number">4</span> &#125;;</span><br><span class="line">     List&lt;Integer&gt; list = Ints.asList(intArray);</span><br><span class="line">     list.set( <span class="number">0</span> ,  <span class="number">100</span> );</span><br><span class="line">     System.out.println(Arrays.toString(intArray));</span><br><span class="line">     list.add( <span class="number">5</span> );</span><br><span class="line">     list.remove( <span class="number">0</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">[ <span class="number">100</span> ,  <span class="number">2</span> ,  <span class="number">3</span> ,  <span class="number">4</span> ]</span><br><span class="line">UnsupportedOperationException</span><br><span class="line">UnsupportedOperationException</span><br></pre></td></tr></table></figure>



<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><ul>
<li><p>依赖 use-a</p>
</li>
<li><p>聚合 has-a</p>
</li>
<li><p>继承 is-a</p>
</li>
</ul>
<h2 id="1-域变量与局部变量"><a href="#1-域变量与局部变量" class="headerlink" title="1.域变量与局部变量"></a>1.域变量与局部变量</h2><p>域变量会初始化为自动默认值,如果不明确初始化会影响代码的可读性</p>
<p>局部变量不会自动初始化为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Emplpyee[] staff = <span class="keyword">new</span> <span class="title class_">Employee</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 省略不同的名字初始化</span></span><br><span class="line"><span class="comment">// 如果需要返回一个可变数据域的拷贝,应该使用clone</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">System.out.println(boss.name); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Employee other)</span> &#123;</span><br><span class="line">        <span class="comment">//访问</span></span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        System.out.println(a);<span class="comment">//报错 在使用时a未被初始化 当然如果不使用a就不会报错</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p>首先方法可以访问所调用对象的私有数据(平常使用显而易见).</p>
<p>然后让人奇怪的是一个<strong>方法可以访问所属类的所有对象的私有数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//    ...</span></span><br><span class="line">    Employee (String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Employee other)</span> &#123;</span><br><span class="line">        <span class="comment">//访问</span></span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">harry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;harry&quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(boss.name); // 编译器报错</span></span><br><span class="line">        <span class="keyword">if</span> (boss.equals(harry)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Employee的方法可以访问Employee类任何一个对象的私有域&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>private 方法</strong>内部使用,想删就删(不会被外部使用)</p>
<p><strong>final实例域</strong> 必须确保在每个构造器执行后这个域的值被设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;<span class="comment">//编译器报错</span></span><br><span class="line">    <span class="comment">//如果去掉无参构造器则不报错</span></span><br><span class="line">    Employee () &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Employee (String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;不能改&quot;</span>;<span class="comment">// 报错: name&#x27; might already have been assigned(分配) to,因为涉及更改引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>final关键字只是表示不会在指向别的地方,对象本身可以更改</p>
<p>静态方法不需要构建对象就可以调用</p>
<p>静态代码(只有在装载类的时候被执行) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    A() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    B() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();   </span><br><span class="line">        <span class="comment">// 12aba</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个类都可以有一个main方法</p>
<p>方法可以改变一个对象参数的状态,但不能整体改变(用x指向别的)因为是局部变量只是改变局部变量的值 真正的引用未被改变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">A <span class="title function_">a</span><span class="params">(a)</span>,b(b)</span><br><span class="line">swap(a,b);</span><br><span class="line">swap(x,y) &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = x;   </span><br><span class="line">&#125;<span class="comment">// 如果是传应用</span></span><br><span class="line">sout(a,b) 输出 b,a</span><br><span class="line">但是并没有奏效输出还是a,b</span><br></pre></td></tr></table></figure>

<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>方法同名不同参数</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>子类覆盖父类:方法签名覆盖 方法名与参数列表完全一致</p>
<p>区分重载:</p>
<p>super不是一个对象的引用,不能将super赋给另一个对象变量,它只是一个指示编译器调用超类方法的特殊关键字</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法名+参数列表称为方法签名</p>
<p><strong>动态绑定</strong></p>
<blockquote>
<p>C x &#x3D; new B();</p>
<p>x.f(args)</p>
</blockquote>
<ol>
<li>获取父类public且对应名称的方法和声明类的对应名称方法</li>
<li>找一个参数类型完全匹配的方法(这个过程称为重载解析) 有可能类型转换 没找到就会报错</li>
<li>实际调用会调用x的真正类型的方法,虚拟机预先为每个类有一个方法表</li>
</ol>
<p>作用: 无需对现存代码修改,就可以对程序扩展</p>
<p><strong>静态绑定</strong>: private,static,final或者构造器等编译器可以准确的知道应该调用哪个方法,所以称为静态绑定</p>
<h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p><strong>final类</strong> 为不允许扩展的的类,所有方法自动成为final,不包括域,确保它们不会在子类改变语义</p>
<p>如果一个方法没有被覆盖并且很短就可被优化为<strong>内联</strong> 例如: e.getNname 将被替换为访问e.name域 详见:Java核心卷10</p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>允许子类引用赋值给父类<strong>反之必须类型转换</strong>才能通过<strong>运行时</strong>检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//    ...</span></span><br><span class="line">    Employee () &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Employee (String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Employee other)</span> &#123;</span><br><span class="line">        <span class="comment">//访问</span></span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;员工共有之work&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    Manager (String name) &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;经理独有之manage&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每个经理是一个员工</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3.405</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> (<span class="type">int</span>) x;</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Employee[] staff = <span class="keyword">new</span> <span class="title class_">Employee</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//        Employee b = new Employee(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">//        Manager c = (Manager)b;</span></span><br><span class="line"><span class="comment">//        c.manage(); 这三行会报 ClassCastException</span></span><br><span class="line">       <span class="comment">//改进:</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Manager c; <span class="comment">// 局部变量未使用不会报错</span></span><br><span class="line">        <span class="keyword">if</span> (b <span class="keyword">instanceof</span> Manager) &#123;</span><br><span class="line">            c = (Manager) b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        staff[<span class="number">0</span>] = a;<span class="comment">// 转化为E 实际为M</span></span><br><span class="line"><span class="comment">//        staff[0].manage();//报错</span></span><br><span class="line">        a = (Manager)staff[<span class="number">0</span>];<span class="comment">// 将父类强转为子类 唯一原因是:暂时忽视对象的?后,使用对象的全部功能</span></span><br><span class="line">        a.manage(); <span class="comment">// 正常调用</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:父类转换为子类之前要使用instanceof,并且只能在继承层次内进行类型转换</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h2><ol>
<li>含有抽象方法(不需要实现的方法)的必须是抽象类</li>
<li>不含有抽象方法也可以声明为抽象类,只是不能被实例化</li>
<li>可以包含具体数据与方法</li>
</ol>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>**hashCode()**每个对象都有,其值为对象的存储地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        System.out.println(s.hashCode() + <span class="string">&quot; &quot;</span>+sb.hashCode());</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(t);</span><br><span class="line">        System.out.println(t.hashCode() + <span class="string">&quot; &quot;</span>+tb.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3548 460141958<br>3548 1163157884</p>
<p>String 的hashcode()是内容导向的 如果equals为true那么hashcode也要一致</p>
</blockquote>
<h3 id="为什么重写equals方法就必须重写hashCode方法？"><a href="#为什么重写equals方法就必须重写hashCode方法？" class="headerlink" title="为什么重写equals方法就必须重写hashCode方法？"></a>为什么重写equals方法就必须重写hashCode方法？</h3><ul>
<li><p>在散列表中，<br>1、如果两个对象相等，那么它们的hashCode()值一定要相同； 这里的相等是指，通过equals()比较两个对象 时返回true</p>
<p>2、如果两个对象hashCode()相等，它们并不一定相等。(不相等时就是哈希冲突)</p>
<p> 注意：这是在散列表中的情况。在非散列表中一定如此！</p>
</li>
<li><p>考虑只重写equals而不重写 hashcode 时，虽然两个属性值完全相同的对象通过equals方法判断为true，但是当把这两个对象加入到 HashSet 时。会发现HashSet中有重复元素，这就是因为HashSet 使用 hashcode 判断对象是否已存在时造成了歧义，结果会导 致HashSet 的不正常运行。所以重写 equals 方法必须重写 hashcode 方法。</p>
</li>
</ul>
<p>map的put 拿到hashcode()进行散列定槽 如果槽为空直接加入</p>
<p>如果槽不为空(判断key是否相等(key不能重复),)如果key相同直接覆盖  value ,否则解决哈希冲突</p>
<p>还是从set角度说重写hashCode</p>
<h2 id="enum关键字"><a href="#enum关键字" class="headerlink" title="enum关键字"></a>enum关键字</h2><h1 id="接口、lambda表达式与内部类"><a href="#接口、lambda表达式与内部类" class="headerlink" title="接口、lambda表达式与内部类"></a>接口、lambda表达式与内部类</h1><ul>
<li>接口,lambda</li>
<li>内部类机制,内部类中的方法可以访问外部的域</li>
<li>代理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iinterface</span> &#123; <span class="comment">// 内部接口默认为static的</span></span><br><span class="line">         <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Iinterface</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部接口可被private,protectd static(默认static) public,  修饰&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类(接口)权限修饰符只能是public 或者不写&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类可被final修饰(接口不行),不能被继承,不能static修饰&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口方法自动的是public,实现类必须写好</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>类泛型 写在类名之后&lt;&gt; 可以用在类内部域,方法参数,方法返回值,方法参数,局部变量等所有能声明的: 从结果来说可以理解为限定了一个限定符 等指定之后在进行替换不指定则为null,当第一次被确定时就被确定了比如set,在使用时都进行泛型指定<br>在实现Comparable<Employee>接口的类中必须提供下列方法<br>int compareTo(Employee other )<br>可用instanceof 检查对象是否实现了某个特定的接口,instancof限定上限	</Employee></p>
</blockquote>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>可以为接口提供默认实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Tother)</span> &#123;<span class="keyword">return</span> <span class="number">0</span>&#125;;<span class="comment">// 可以不用实现但既然</span></span><br><span class="line">    <span class="comment">//用处并不大,每一个实际实现都要覆盖这个方法(逻辑覆盖并不是一定要实现),不过有些情况默认方法可能很有用</span></span><br><span class="line">    <span class="comment">// 重要用法: 接口演化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DeInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span>  <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> <span class="keyword">implements</span> <span class="title class_">DeInterface</span>&#123;</span><br><span class="line">	<span class="comment">//不用实现默认方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="异常、断言和日志"><a href="#异常、断言和日志" class="headerlink" title="异常、断言和日志"></a>异常、断言和日志</h1><p><strong>简述:</strong> </p>
<p>程序运行过程发生错误就会”抛出异常”,抛出异常比终止程序灵活,因为可以提供一个”捕获”异常的处理器(handler)对异常情况进行处理,如果没有提供处理器程序就会终止,并在控制台打印信息</p>
<p>异常有两种类型,未检查异常和已检查异常</p>
<ul>
<li>对于已检查异常,编译器会检查是否提供处理器,(提示要添加异常处理的都是已检查异常)</li>
<li>常见的如空指针都属于未检查异常,编译器不会查看,因为应该精心编写代码来避免这些错误</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    handler action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异常层次</strong></p>
<p><img src="/2022/10/08/all/1java/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220920092824156.png" alt="image-20220920092824156"></p>
<h3 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h3><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
<p>此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>
<p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p>
<h3 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>
<ul>
<li><strong>运行时异常</strong> 	未检查异常</li>
</ul>
<p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<ul>
<li><strong>非运行时异常</strong> （编译异常必须从语法角度进行处理）  已检查异常</li>
</ul>
<p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li><p><strong>应该寻找更加适当的子类或创建自己的异常类</strong></p>
</li>
<li></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io">ggq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io/2022/10/08/all/1java/">https://gouguoqiang.github.io/2022/10/08/all/1java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gouguoqiang.github.io" target="_blank">ggq</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/09/all/9MicroService/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">微服务</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/08/mysql/mysql/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">mysql</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ggq</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Java-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第2章 Java 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Java%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-JVM"><span class="toc-number">1.1.</span> <span class="toc-text">2.1 Java核心机制-JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2JDK-JRE"><span class="toc-number">1.2.</span> <span class="toc-text">2.2JDK JRE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-java%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.</span> <span class="toc-text">2.3 java开发注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">第3章 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8EAPI"><span class="toc-number">2.1.</span> <span class="toc-text">3.1数据类型与API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2Java%E7%B1%BB%E7%9A%84%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">3.2Java类的组织形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-char-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">3.3 char+字符编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4Unicode"><span class="toc-number">2.4.</span> <span class="toc-text">3.4Unicode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5UTF-8"><span class="toc-number">2.5.</span> <span class="toc-text">3.5UTF-8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.6.</span> <span class="toc-text">3.6基本数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.7.</span> <span class="toc-text">3.7 强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">第4章 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">3.1.</span> <span class="toc-text">4.1命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.2.</span> <span class="toc-text">4.2键盘输入语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">6.类型转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">Java流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Scanner-%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">1.Scanner 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#next-%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">next()：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nextLine"><span class="toc-number">4.3.</span> <span class="toc-text">nextLine():</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-switch-%E5%A4%9A%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.4.</span> <span class="toc-text">4.switch 多选择语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="toc-number">5.</span> <span class="toc-text">第7章面向对象基础部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.</span> <span class="toc-text">7.1创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2Java-%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">5.2.</span> <span class="toc-text">7.2Java 内存的结构分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">7.4成员方法传参机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.1.</span> <span class="toc-text">7.4.1基本数据类型的传参机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.2.</span> <span class="toc-text">7.4.2引用数据类型的传参机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-number">5.3.3.</span> <span class="toc-text">7.4.3方法的递归调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">5.4.</span> <span class="toc-text">7.5方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">5.5.</span> <span class="toc-text">7.6可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.5.1.</span> <span class="toc-text">7.6.1基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">5.5.2.</span> <span class="toc-text">7.6.2基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-3%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">5.5.3.</span> <span class="toc-text">7.6.3快速入门案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-4%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">5.5.4.</span> <span class="toc-text">7.6.4注意事项和使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88%E5%AF%B9%E7%B1%BB%E6%9D%A5%E8%AF%B4%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">7.7作用域（对类来说）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-x2F-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">5.7.</span> <span class="toc-text">7.8构造方法&#x2F;构造器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86"><span class="toc-number">6.</span> <span class="toc-text">第10章面向对象高级部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.1.</span> <span class="toc-text">10.5 final 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">13.1包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-1%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-number">6.2.1.</span> <span class="toc-text">13.1.1装箱拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-2%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="toc-number">6.2.2.</span> <span class="toc-text">13.1.2包装类之间的转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-3Integer-%E7%B1%BB%E5%92%8C-Character%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">13.1.3Integer 类和 Character类的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-4%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">6.2.4.</span> <span class="toc-text">13.1.4面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-String-%E7%B1%BB%EF%BC%88%E5%8F%8C%E5%BC%95%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">13.2 String 类（双引号括起来）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-1-String-%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.3.1.</span> <span class="toc-text">13.2.1 String 类的理解和创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-2%E5%88%9B%E5%BB%BAString%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.2.</span> <span class="toc-text">13.2.2创建String对象的两种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-3%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.3.</span> <span class="toc-text">13.2.3两种方式的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">6.4.</span> <span class="toc-text">13.3字符串的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-String%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.</span> <span class="toc-text">13.4 String类的常见方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-StringBuffer%E7%B1%BB"><span class="toc-number">6.6.</span> <span class="toc-text">13.5 StringBuffer类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.6.1.</span> <span class="toc-text">13.5.1基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-2-String-vs-StringBuffer"><span class="toc-number">6.6.2.</span> <span class="toc-text">13.5.2 String vs StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-3-%E4%B8%A4%E8%80%85%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.6.3.</span> <span class="toc-text">13.5.3 两者的互相转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-4-StringBuffer-%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.4.</span> <span class="toc-text">13.5.4 StringBuffer 类常见方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-StringBuilder-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84StringBuffer"><span class="toc-number">6.7.</span> <span class="toc-text">13.6 StringBuilder 线程不安全的StringBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-Math-%E7%B1%BB"><span class="toc-number">6.8.</span> <span class="toc-text">13.7 Math 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-8-Arrays%E7%B1%BB"><span class="toc-number">6.9.</span> <span class="toc-text">13.8 Arrays类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-9-System%E7%B1%BB"><span class="toc-number">6.10.</span> <span class="toc-text">13.9 System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-10-BigInteger%E5%92%8CBigDecimal%E7%B1%BB"><span class="toc-number">6.11.</span> <span class="toc-text">13.10 BigInteger和BigDecimal类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E9%9B%86%E5%90%88"><span class="toc-number">7.</span> <span class="toc-text">第14章 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1%E9%9B%86%E5%90%88%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%A5%BD%E5%A4%84"><span class="toc-number">7.1.</span> <span class="toc-text">14.1集合的理解与好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">7.2.</span> <span class="toc-text">14.2集合的框架体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-Collection%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">14.3 Collection接口和常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">第21章 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-1%E7%BD%91%E7%BB%9C%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">8.0.1.</span> <span class="toc-text">21.1网络的相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-2InetAddress%E7%B1%BB"><span class="toc-number">8.0.2.</span> <span class="toc-text">21.2InetAddress类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-2-1%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">8.0.2.1.</span> <span class="toc-text">21.2.1相关方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-3-Socket"><span class="toc-number">8.0.3.</span> <span class="toc-text">21.3 Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-3-1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.0.3.1.</span> <span class="toc-text">21.3.1基本介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-4-TCP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">8.0.4.</span> <span class="toc-text">21.4  TCP网络通信编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-4-1%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">8.0.4.1.</span> <span class="toc-text">21.4.1使用字节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-4-2%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">8.0.4.2.</span> <span class="toc-text">21.4.2使用字符流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-4-3%E6%96%87%E4%BB%B6%E5%8F%91%E9%80%81"><span class="toc-number">8.0.4.3.</span> <span class="toc-text">21.4.3文件发送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-4-4-netstat-%E6%8C%87%E4%BB%A4"><span class="toc-number">8.0.4.4.</span> <span class="toc-text">21.4.4 netstat 指令</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">9.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.1.</span> <span class="toc-text">基础类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.2.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">9.3.</span> <span class="toc-text">比较器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date"><span class="toc-number">9.4.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">9.5.</span> <span class="toc-text">File类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">9.6.</span> <span class="toc-text">IO流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">10.</span> <span class="toc-text">权限修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">10.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">10.2.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">10.3.</span> <span class="toc-text">接口抽象类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Guava%E5%85%A5%E9%97%A8"><span class="toc-number">11.</span> <span class="toc-text">Guava入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arr%E4%B8%8Elist%E8%BD%AC%E6%8D%A2"><span class="toc-number">12.</span> <span class="toc-text">arr与list转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">12.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F-%E6%9C%AA%E5%BF%85%E6%9C%80%E4%BD%B3-%E4%BD%BF%E7%94%A8ArrayList-asList-strArray"><span class="toc-number">12.2.</span> <span class="toc-text">第一种方式(未必最佳):使用ArrayList.asList(strArray)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95-%E6%94%AF%E6%8C%81%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9"><span class="toc-number">12.3.</span> <span class="toc-text">第二种方法(支持增删查改):</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-%E9%80%9A%E8%BF%87%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BBCollections-addAll-%E6%96%B9%E6%B3%95-%E6%9C%80%E9%AB%98%E6%95%88"><span class="toc-number">12.4.</span> <span class="toc-text">第三种方式(通过集合工具类Collections.addAll()方法(最高效))</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E9%80%9A%E8%BF%87JDK8%E7%9A%84Stream%E6%B5%81%E5%B0%863%E6%80%BB%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BAList"><span class="toc-number">12.5.</span> <span class="toc-text">第四种方式通过JDK8的Stream流将3总基本类型数组转为List</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.</span> <span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%9F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">13.1.</span> <span class="toc-text">1.域变量与局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">13.2.</span> <span class="toc-text">重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">14.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95"><span class="toc-number">14.1.</span> <span class="toc-text">覆盖方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">14.2.</span> <span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-number">14.3.</span> <span class="toc-text">修饰类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">14.4.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">14.5.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object"><span class="toc-number">14.6.</span> <span class="toc-text">Object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E5%B0%B1%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">14.6.1.</span> <span class="toc-text">为什么重写equals方法就必须重写hashCode方法？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enum%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">14.7.</span> <span class="toc-text">enum关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">接口、lambda表达式与内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.1.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">15.2.</span> <span class="toc-text">默认方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97"><span class="toc-number">16.</span> <span class="toc-text">异常、断言和日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Error%EF%BC%88%E9%94%99%E8%AF%AF%EF%BC%89"><span class="toc-number">16.0.1.</span> <span class="toc-text">Error（错误）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exception%EF%BC%88%E5%BC%82%E5%B8%B8%EF%BC%89"><span class="toc-number">16.0.2.</span> <span class="toc-text">Exception（异常）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">16.0.3.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/17/%E7%AE%97%E6%B3%95/" title="排序算法"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序算法"/></a><div class="content"><a class="title" href="/2022/10/17/%E7%AE%97%E6%B3%95/" title="排序算法">排序算法</a><time datetime="2022-10-17T08:09:45.000Z" title="发表于 2022-10-17 16:09:45">2022-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/09/all/5redis/" title="redis"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis"/></a><div class="content"><a class="title" href="/2022/10/09/all/5redis/" title="redis">redis</a><time datetime="2022-10-09T03:36:23.000Z" title="发表于 2022-10-09 11:36:23">2022-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/09/all/4spring/" title="Spring"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring"/></a><div class="content"><a class="title" href="/2022/10/09/all/4spring/" title="Spring">Spring</a><time datetime="2022-10-09T03:36:23.000Z" title="发表于 2022-10-09 11:36:23">2022-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/09/all/8JUC/" title="JUC"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC"/></a><div class="content"><a class="title" href="/2022/10/09/all/8JUC/" title="JUC">JUC</a><time datetime="2022-10-09T03:36:23.000Z" title="发表于 2022-10-09 11:36:23">2022-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/09/all/7JVM/" title="JVM"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/2022/10/09/all/7JVM/" title="JVM">JVM</a><time datetime="2022-10-09T03:36:23.000Z" title="发表于 2022-10-09 11:36:23">2022-10-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By ggq</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>