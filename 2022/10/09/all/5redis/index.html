<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>redis | ggq</title><meta name="keywords" content="redis"><meta name="author" content="ggq"><meta name="copyright" content="ggq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="redis日常基础使用 一些配置 与说明   (守护进程)daemonize yes 启动:  123456#可能需要进入redis目录redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.confredis-cliauth (可以不写用户)密码keys*  关闭 1redis-cli shutdown    使用RedisDesktopManager连接远程服务器redis 修">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="https://gouguoqiang.github.io/2022/10/09/all/5redis/index.html">
<meta property="og:site_name" content="ggq">
<meta property="og:description" content="redis日常基础使用 一些配置 与说明   (守护进程)daemonize yes 启动:  123456#可能需要进入redis目录redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.confredis-cliauth (可以不写用户)密码keys*  关闭 1redis-cli shutdown    使用RedisDesktopManager连接远程服务器redis 修">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-09T03:36:23.000Z">
<meta property="article:modified_time" content="2022-10-09T13:56:59.482Z">
<meta property="article:author" content="ggq">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://gouguoqiang.github.io/2022/10/09/all/5redis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-09 21:56:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ggq</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-09T03:36:23.000Z" title="发表于 2022-10-09 11:36:23">2022-10-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-09T13:56:59.482Z" title="更新于 2022-10-09 21:56:59">2022-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="redis日常基础使用"><a href="#redis日常基础使用" class="headerlink" title="redis日常基础使用"></a>redis日常基础使用</h1><blockquote>
<p>一些配置 与说明</p>
</blockquote>
<p><img src="/2022/10/09/all/5redis/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220730184343432.png" alt="image-20220730184343432"></p>
<p>(守护进程)daemonize yes</p>
<p>启动: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可能需要进入redis目录</span></span><br><span class="line">redis-server /usr/local/redis/redis.conf</span><br><span class="line">redis-cli</span><br><span class="line">auth (可以不写用户)密码</span><br><span class="line"></span><br><span class="line">keys*</span><br></pre></td></tr></table></figure>

<p>关闭</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure>



<p>使用RedisDesktopManager连接远程服务器redis</p>
<p>修改 .conf </p>
<p>​	bind 0.0.0.0 允许所有主机 127.~ 只允许本机</p>
<p>​	protectmode yes  只允许本机 no  允许所有主机</p>
<p>​	requierpass  密码</p>
<p><img src="/2022/10/09/all/5redis/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220730193623030.png" alt="image-20220730193623030"></p>
<p>服务器防火墙开放 6379端口就ok</p>
<h1 id="第三章-redis多线程VS单线程"><a href="#第三章-redis多线程VS单线程" class="headerlink" title="第三章 redis多线程VS单线程"></a>第三章 redis多线程VS单线程</h1><h2 id="Redis工作线程是单线程的-整个Redis来说，是多线程的；"><a href="#Redis工作线程是单线程的-整个Redis来说，是多线程的；" class="headerlink" title="Redis工作线程是单线程的,整个Redis来说，是多线程的；"></a>Redis工作线程是单线程的,整个Redis来说，是多线程的；</h2><p>主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程。</p>
<p>但Redis的其他功能，比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。<br>Redis工作线程是单线程的，但是，整个Redis来说，是多线程的；</p>
<h2 id="单线程快的原因"><a href="#单线程快的原因" class="headerlink" title="单线程快的原因"></a>单线程快的原因</h2><p>1 避免上下文切换：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程不会导致死锁问题的发生</p>
<p>2 即使使用单线程模型也并发的处理多客户端的请求，主要使用的是多路复用和非阻塞 IO；</p>
<p>3 对于 Redis 系统来说，主要的性能瓶颈是内存或者网络带宽而并非 CPU。</p>
<h2 id="单线程的弊病"><a href="#单线程的弊病" class="headerlink" title="单线程的弊病"></a>单线程的弊病</h2><p>正常情况下使用 del 指令可以很快的删除数据，而当被删除的 key 是一个非常大的对象时，例如时包含了成千上万个元素的 hash 集合时，那么 del 指令就会造成 Redis 主线程卡顿。</p>
<p>这就是redis3.x单线程时代最经典的故障，大key删除的头疼问题，</p>
<p>由于redis是单线程的，del  bigKey …..<br>等待很久这个线程才会释放，类似加了一个synchronized锁，你可以想象高并发下，程序堵成什么样子？</p>
<p>在Redis 4.0就引入了多个线程来实现数据的异步惰性删除等功能，<br>但是其处理读写请求的仍然只有一个线程，所以仍然算是狭义上的单线程</p>
<p><img src="/2022/10/09/all/5redis/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220803225348512.png" alt="image-20220803225348512"></p>
<p><img src="/2022/10/09/all/5redis/Users\再难也会过\AppData\Roaming\Typora\typora-user-images\image-20220803225413220.png" alt="image-20220803225413220"></p>
<p>Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理8W到10W的QPS，</p>
<p>这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。</p>
<h2 id="默认单线程"><a href="#默认单线程" class="headerlink" title="默认单线程"></a>默认单线程</h2><p>在Redis6.0中，多线程机制默认是关闭的，如果需要使用多线程功能，需要在redis.conf中完成两个设置</p>
<p><img src="/2022/10/09/all/5redis/image/99E6354B-3BE3-4FD3-8011-EE713D865BE6.png" alt="img"></p>
<p>1.设置io-thread-do-reads配置项为yes，表示启动多线程。</p>
<p>2。设置线程个数。关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。</p>
<h1 id="第五章-经典五种数据类型-都是针对value-介绍及落地应用"><a href="#第五章-经典五种数据类型-都是针对value-介绍及落地应用" class="headerlink" title="第五章 经典五种数据类型(都是针对value)介绍及落地应用"></a>第五章 经典五种数据类型(都是针对value)介绍及落地应用</h1><h2 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h2><h3 id="1-1-常用指令"><a href="#1-1-常用指令" class="headerlink" title="1.1 常用指令"></a>1.1 常用指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br><span class="line">get key</span><br><span class="line"></span><br><span class="line">同时设置/获取多个键值  </span><br><span class="line">MGET key [key ....]</span><br><span class="line">MSET key value [key value ....]</span><br><span class="line"></span><br><span class="line">数值增减</span><br><span class="line">INCR key</span><br><span class="line">增加指定的整数 </span><br><span class="line">INCRBY key increment</span><br><span class="line">递减数值 </span><br><span class="line">DECR key</span><br><span class="line">减少指定的整数</span><br><span class="line">DECRBY key decrement</span><br><span class="line"></span><br><span class="line">获取字符串长度</span><br><span class="line">STRLEN key</span><br><span class="line"></span><br><span class="line">分布式锁</span><br><span class="line">setnx key value</span><br><span class="line">set key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure>

<h3 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2 应用场景"></a>1.2 应用场景</h3><p>比如抖音无限点赞某个视频或者商品，点一下加一次</p>
<h2 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2. Hash"></a>2. Hash</h2><p>Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>
<h3 id="2-1常用指令"><a href="#2-1常用指令" class="headerlink" title="2.1常用指令"></a>2.1常用指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一次设置一个字段值</span><br><span class="line">HSET key field value</span><br><span class="line">一次获取一个字段值</span><br><span class="line">HGET key field</span><br><span class="line">一次设置多个字段值</span><br><span class="line">HMSET key field value [field value ...]</span><br><span class="line">一次获取多个字段值</span><br><span class="line">HMGET key field [field ....]</span><br><span class="line">获取所有字段值</span><br><span class="line">hgetall key</span><br><span class="line">获取某个key内的全部数量</span><br><span class="line">hlen</span><br><span class="line">删除一个key</span><br><span class="line">hdel</span><br></pre></td></tr></table></figure>



<h3 id="2-2应用场景"><a href="#2-2应用场景" class="headerlink" title="2.2应用场景"></a>2.2应用场景</h3><p>​	Map&lt;String,Map&lt;Object,Object&gt;&gt;</p>
<p>​	hset key field value </p>
<p>​	JD早期购物车 中小场可用</p>
<p>​		新增商品 → hset shopcar:uid1024 334488 1</p>
<p>​		新增商品 → hset shopcar:uid1024 334477 1</p>
<p>​		增加商品数量 → hincrby shopcar:uid1024 334477 1</p>
<p>​		商品总数 → hlen shopcar:uid1024</p>
<p>​		全部选择 → hgetall shopcar:uid1024</p>
<h2 id="3-List"><a href="#3-List" class="headerlink" title="3. List"></a>3. List</h2><p>一个双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景。</p>
<h3 id="3-1-常用指令"><a href="#3-1-常用指令" class="headerlink" title="3.1 常用指令"></a>3.1 常用指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">向列表左边添加元素</span><br><span class="line">LPUSH key value [value ...]</span><br><span class="line">向列表右边添加元素</span><br><span class="line">RPUSH key value [value ....]</span><br><span class="line">查看列表</span><br><span class="line">LRANGE key start stop</span><br><span class="line">获取列表中元素的个数</span><br><span class="line">LLEN key</span><br></pre></td></tr></table></figure>





<h3 id="3-2-应用场景"><a href="#3-2-应用场景" class="headerlink" title="3.2 应用场景"></a>3.2 应用场景</h3><p>微信订阅号消息,关注了作者,如果作者发布了文章 就会向关注的list添加</p>
<p>​		1 订阅了的公众号和CSDN发布了文章分别是 11 和 22</p>
<p>​		2 ggq关注了他们两个，只要他们发布了新文章，就会安装进ggq的List</p>
<pre><code>       lpush likearticle:ggqid    11 22
</code></pre>
<p>​		3 查看ggq自己的号订阅的全部文章，类似分页，下面0~10就是一次显示10条</p>
<p>​		  lrange likearticle:ggqid 0 9</p>
<p>​	商品评论</p>
<p>​		商品ID key 和 value评论信息</p>
<p>​		按时间顺序</p>
<h2 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h2><h3 id="4-1-常用指令"><a href="#4-1-常用指令" class="headerlink" title="4.1 常用指令"></a>4.1 常用指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">添加元素</span><br><span class="line">SADD key member [member ...]</span><br><span class="line">删除元素</span><br><span class="line">SREM key member [member ...]</span><br><span class="line">遍历集合中的所有元素</span><br><span class="line">SMEMBERS key</span><br><span class="line">判断元素是否在集合中</span><br><span class="line">SISMEMBER key member</span><br><span class="line">获取集合中的元素总数</span><br><span class="line">SCARD key</span><br><span class="line">从集合中随机弹出一个元素，元素不删除</span><br><span class="line">SRANDMEMBER key [数字]</span><br><span class="line">从集合中随机弹出一个元素，出一个删一个</span><br><span class="line">SPOP key [数字]</span><br><span class="line"></span><br><span class="line">集合运算</span><br><span class="line">SDIFF key [key ...] # 属于A但不属于B的元素构成的集合</span><br><span class="line">SINTER key [key ...] # 属于A同时也属于B的共同拥有的元素构成的集合</span><br><span class="line">SUNION key [key ...] # 属于A或者属于B的元素合并后的集合</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-2-应用场景"><a href="#4-2-应用场景" class="headerlink" title="4.2 应用场景"></a>4.2 应用场景</h3><p>抽奖</p>
<p>1 用户ID，立即参与按钮</p>
<p>sadd key 用户ID</p>
<p>2 显示已经有多少人参与了，上图23208人参加</p>
<p>SCARD key</p>
<p>3 抽奖(从set中任意选取N个中奖人)</p>
<p>SRANDMEMBER key 2    随机抽奖2个人，元素不删除</p>
<p>SPOP key 3             随机抽奖3个人，元素会删除</p>
<p>​	集合运算 共同好友,共同关注</p>
<p>​	可能认识的人</p>
<h2 id="5-sortedSet-Zset"><a href="#5-sortedSet-Zset" class="headerlink" title="5. sortedSet(Zset)"></a>5. sortedSet(Zset)</h2><p>向有序集合中加入一个元素和该元素的分数</p>
<h3 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score member [score member ...]</span><br><span class="line"></span><br><span class="line">按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素</span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">获取元素的分数</span><br><span class="line">ZSCORE key member</span><br><span class="line">删除元素</span><br><span class="line">ZREM key member [member ...]</span><br><span class="line">获取指定分数范围的元素</span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">增加某个元素的分数</span><br><span class="line">ZINCRBY key increment member</span><br><span class="line">获取集合中元素的数量</span><br><span class="line">ZCARD key</span><br><span class="line">获得指定分数范围内的元素个数</span><br><span class="line">ZCOUNT key min max</span><br><span class="line">按照排名范围删除元素</span><br><span class="line">ZREMRANGEBYRANK key start stop</span><br><span class="line">获取元素的排名</span><br><span class="line">ZRANK key member # 从小到大</span><br><span class="line">ZREVRANK key member # 从大到小</span><br></pre></td></tr></table></figure>



<h3 id="5-2-应用场景"><a href="#5-2-应用场景" class="headerlink" title="5.2 应用场景"></a>5.2 应用场景</h3><p>​	商品排行</p>
<p>​	抖音热搜 incrby</p>
<p>​	展示多少条 zrange min max</p>
<h3 id="5-3-案例实战"><a href="#5-3-案例实战" class="headerlink" title="5.3 案例实战"></a>5.3 案例实战</h3><h1 id="第六章-redis新类型bitmap-x2F-hyperloglgo-x2F-GEO"><a href="#第六章-redis新类型bitmap-x2F-hyperloglgo-x2F-GEO" class="headerlink" title="第六章 redis新类型bitmap&#x2F;hyperloglgo&#x2F;GEO"></a>第六章 redis新类型bitmap&#x2F;hyperloglgo&#x2F;GEO</h1><p>存的进+取得快+多统计</p>
<h2 id="亿级系统中常见的四种统计统计的类型"><a href="#亿级系统中常见的四种统计统计的类型" class="headerlink" title="亿级系统中常见的四种统计统计的类型"></a>亿级系统中常见的四种统计统计的类型</h2><ol>
<li><p>聚合统计</p>
<ol>
<li>统计多个集合元素的聚合结果，就是前面讲解过的交差并等集合统计</li>
<li>交并差集和聚合函数的应用</li>
</ol>
</li>
<li><p>排序统计</p>
<ol>
<li><p>抖音视频最新评论留言的场景，请你设计一个展现列表。</p>
<p>考察你的数据结构和设计思路</p>
</li>
<li><p>设计案例和回答思路</p>
<ol>
<li><p>每个商品评价对应一个List集合，这个List包含了对这个商品的所有评论，而且会按照评论时间保存这些评论，</p>
<p>每来一个新评论就用LPUSH命令把它插入List的队头。但是，如果在演示第二页前，又产生了一个新评论，</p>
<p>第2页的评论不一样了。原因：</p>
<p>List是通过元素在List中的位置来排序的，当有一个新元素插入时，原先的元素在List中的位置都后移了一位，</p>
<p>原来在第1位的元素现在排在了第2位，当LRANGE读取时，就会读到旧元素。</p>
<p><img src="/2022/10/09/all/5redis/image/75DA0CFD-A589-4E86-BC98-85942A31D884.png" alt="img"></p>
<p>在⾯对需要展示最新列表、排行榜等场景时，</p>
<p>如果数据更新频繁或者需要分页显示，建议使⽤ZSet</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>二值统计</p>
<ol>
<li><p>集合元素的取值就只有0和1两种。</p>
<p>在钉钉上班签到打卡的场景中，我们只用记录有签到(1)或没签到(0) bitmap</p>
</li>
</ol>
</li>
<li><p>基数统计</p>
<ol>
<li>指统计⼀个集合中不重复的元素个数 见hyperloglog</li>
</ol>
</li>
</ol>
<h2 id="1-BitMap"><a href="#1-BitMap" class="headerlink" title="1. BitMap"></a>1. BitMap</h2><h3 id="1-1-常用指令-1"><a href="#1-1-常用指令-1" class="headerlink" title="1.1 常用指令"></a>1.1 常用指令</h3><h3 id="1-2应用场景"><a href="#1-2应用场景" class="headerlink" title="1.2应用场景"></a>1.2应用场景</h3><p>​	按字节(8位)扩容	</p>
<p>​	setbit key offset value 偏移位从0开始算 value 只能是01</p>
<p>​	由0和1状态表现的二进制位的bit数组</p>
<p>​	用于状态统计</p>
<p>​			</p>
<h2 id="2-HyperLogLog"><a href="#2-HyperLogLog" class="headerlink" title="2. HyperLogLog"></a>2. HyperLogLog</h2><h3 id="2-1-常用指令"><a href="#2-1-常用指令" class="headerlink" title="2.1 常用指令"></a>2.1 常用指令</h3><h3 id="2-2应用场景-1"><a href="#2-2应用场景-1" class="headerlink" title="2.2应用场景"></a>2.2应用场景</h3><h2 id="3-GEO"><a href="#3-GEO" class="headerlink" title="3. GEO"></a>3. GEO</h2><h3 id="3-1-常用指令-1"><a href="#3-1-常用指令-1" class="headerlink" title="3.1 常用指令"></a>3.1 常用指令</h3><h3 id="3-2应用场景"><a href="#3-2应用场景" class="headerlink" title="3.2应用场景"></a>3.2应用场景</h3><h2 id><a href="#" class="headerlink" title></a></h2><h1 id="第七-章-布隆过滤器"><a href="#第七-章-布隆过滤器" class="headerlink" title="第七 章 布隆过滤器"></a>第七 章 布隆过滤器</h1><p>​	由一个初值都为零的bit数组和多个哈希函数构成，</p>
<p>​	用来快速判断某个数据是否存在</p>
<p>​	判断结果没有的一定没有,有的大概率有 只添加不删除</p>
<p>​	多重hash </p>
<h2 id="linux安装布隆过滤器的两种方式"><a href="#linux安装布隆过滤器的两种方式" class="headerlink" title="linux安装布隆过滤器的两种方式"></a>linux安装布隆过滤器的两种方式</h2><ol>
<li><p>采用docker安装RedisBloom，推荐</p>
<ol>
<li><p>Redis 在 4.0 之后有了插件功能（Module），可以使用外部的扩展功能，</p>
<p>可以使用 RedisBloom 作为 Redis 布隆过滤器插件。</p>
</li>
<li><p>docker run -p 6379:6379 –name&#x3D;redis6379bloom -d redislabs&#x2F;rebloom<img src="/2022/10/09/all/5redis/image/DB0DEE9F-34A6-4889-8D4F-434B8C6BDAF8.png" alt="img"></p>
<p><img src="/2022/10/09/all/5redis/image/833A0328-D959-4EF8-B897-CD3EDFB1D236.png" alt="img"></p>
</li>
<li><p>docker exec -it redis6379bloom &#x2F;bin&#x2F;bash </p>
<ol>
<li>redis-cli</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bf.reserve key error_rate的值 initial_size 的值 默认的error_rate是 0.01，</span><br><span class="line">默认的initial_size是 100。</span><br><span class="line">bf.add key 值</span><br><span class="line">bf.exists key 值</span><br><span class="line">bf.madd 一次添加多个元素</span><br><span class="line">bf.mexists 一次查询多个元素是否存在</span><br></pre></td></tr></table></figure>



<h1 id="Redis高级"><a href="#Redis高级" class="headerlink" title="Redis高级"></a>Redis高级</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>目标1：能够说出redis中的数据删除策与略淘汰策略</p>
<p>目标2：能够说出主从复制的概念，工作流程以及场景问题及解决方案</p>
<p>目标3：能够说出哨兵的作用以及工作原理，以及如何启用哨兵</p>
<p>目标4：能够说出集群的架构设计，完成集群的搭建</p>
<p>目标5：能够说出缓存预热，雪崩，击穿，穿透的概念，能说出redis的相关监控指标</p>
<h2 id="1-数据删除与淘汰策略"><a href="#1-数据删除与淘汰策略" class="headerlink" title="1.数据删除与淘汰策略"></a>1.数据删除与淘汰策略</h2><h3 id="1-1-过期数据"><a href="#1-1-过期数据" class="headerlink" title="1.1 过期数据"></a>1.1 过期数据</h3><h4 id="1-1-1-Redis中的数据特征"><a href="#1-1-1-Redis中的数据特征" class="headerlink" title="1.1.1 Redis中的数据特征"></a><strong>1.1.1 Redis中的数据特征</strong></h4><p>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态</p>
<p>TTL返回的值有三种情况：正数，-1，-2</p>
<ul>
<li><strong>正数</strong>：代表该数据在内存中还能存活的时间</li>
<li><strong>-1</strong>：永久有效的数据</li>
<li><strong>2</strong> ：已经过期的数据 或被删除的数据 或 未定义的数据</li>
</ul>
<p><strong>删除策略就是针对已过期数据的处理策略</strong>，已过期的数据是真的就立即删除了吗？其实也不是，我们会有多种删除策略，是分情况的，在不同的场景下使用不同的删除方式会有不同效果，这也正是我们要将的数据的删除策略的问题</p>
<h4 id="1-1-2-时效性数据的存储结构"><a href="#1-1-2-时效性数据的存储结构" class="headerlink" title="1.1.2 时效性数据的存储结构"></a>1.1.2 时效性数据的存储结构</h4><p>在Redis中，如何给数据设置它的失效周期呢？数据的时效在redis中如何存储呢？看下图：</p>
<p><img src="/2022/10/09/all/5redis/image/1.png"></p>
<p>过期数据是一块独立的存储空间，Hash结构，field是内存地址，value是过期时间，保存了所有key的过期描述，在最终进行过期处理的时候，对该空间的数据进行检测， 当时间到期之后通过field找到内存该地址处的数据，然后进行相关操作。</p>
<h3 id="1-2-数据删除策略"><a href="#1-2-数据删除策略" class="headerlink" title="1.2 数据删除策略"></a>1.2 数据删除策略</h3><h4 id="1-2-1-数据删除策略的目标"><a href="#1-2-1-数据删除策略的目标" class="headerlink" title="1.2.1 数据删除策略的目标"></a>1.2.1 数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或 内存泄露</p>
<p>针对过期数据要进行删除的时候都有哪些删除策略呢？</p>
<ul>
<li>1.定时删除</li>
<li>2.惰性删除</li>
<li>3.定期删除</li>
</ul>
<h4 id="1-2-2-定时删除"><a href="#1-2-2-定时删除" class="headerlink" title="1.2.2 定时删除"></a>1.2.2 定时删除</h4><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</p>
<ul>
<li><strong>优点</strong>：节约内存，到时就删除，快速释放掉不必要的内存占用</li>
<li><strong>缺点</strong>：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li>
<li><strong>总结</strong>：用处理器性能换取存储空间（拿时间换空间）</li>
</ul>
<p><img src="/2022/10/09/all/5redis/image/2-1663909573981.png"></p>
<h4 id="1-2-3-惰性删除"><a href="#1-2-3-惰性删除" class="headerlink" title="1.2.3 惰性删除"></a>1.2.3 惰性删除</h4><p>数据到达过期时间，不做处理。等下次访问该数据时，我们需要判断</p>
<ol>
<li>如果未过期，返回数据</li>
<li>发现已过期，删除，返回不存在</li>
</ol>
<ul>
<li><strong>优点</strong>：节约CPU性能，发现必须删除的时候才删除</li>
<li><strong>缺点</strong>：内存压力很大，出现长期占用内存的数据</li>
<li><strong>总结</strong>：用存储空间换取处理器性能（拿时间换空间）</li>
</ul>
<p><img src="/2022/10/09/all/5redis/image/3.png"></p>
<h4 id="1-2-4-定期删除"><a href="#1-2-4-定期删除" class="headerlink" title="1.2.4 定期删除"></a>1.2.4 定期删除</h4><p>定时删除和惰性删除这两种方案都是走的极端，那有没有折中方案？</p>
<p>我们来讲redis的定期删除方案：</p>
<ul>
<li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10 即每100ms一次</p>
</li>
<li><p>每秒钟执行server.hz次<strong>serverCron()</strong>——–&gt;<strong>databasesCron()</strong>———&gt;<strong>activeExpireCycle()</strong></p>
</li>
<li><p>**activeExpireCycle()*<em>对每个expires[</em>]逐一进行检测，每次执行耗时：250ms&#x2F;server.hz</p>
</li>
<li><p>对某个expires[*]检测时，随机挑选W个key检测</p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果key超时，删除key</span><br><span class="line"></span><br><span class="line">如果一轮中删除的key的数量&gt;W<span class="emphasis">*25%，循环该过程</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">如果一轮中删除的key的数量≤W*</span>25%，检查下一个expires[<span class="emphasis">*]，0-15循环</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数current_db用于记录<strong>activeExpireCycle()</strong> 进入哪个expires[*] 执行</p>
</li>
<li><p>如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行</p>
</li>
</ul>
<p><img src="/2022/10/09/all/5redis/image/4-1663909591661.png"></p>
<p>总的来说：定期删除就是周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</p>
<ul>
<li><strong>特点1</strong>：CPU性能占用设置有峰值，检测频度可自定义设置</li>
<li><strong>特点2</strong>：内存压力不是很大，长期占用内存的冷数据会被持续清理</li>
<li><strong>总结</strong>：周期性抽查存储空间（随机抽查，重点抽查）</li>
</ul>
<h4 id="1-2-5-删除策略对比"><a href="#1-2-5-删除策略对比" class="headerlink" title="1.2.5 删除策略对比"></a>1.2.5 删除策略对比</h4><p>1：定时删除：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节约内存，无占用,</span><br><span class="line">不分时段占用CPU资源，频度高,</span><br><span class="line">拿时间换空间</span><br></pre></td></tr></table></figure>

<p>2：惰性删除：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内存占用严重</span><br><span class="line">延时执行，CPU利用率高</span><br><span class="line">拿空间换时间</span><br></pre></td></tr></table></figure>

<p>3：定期删除：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内存定期随机清理</span><br><span class="line">每秒花费固定的CPU资源维护内存</span><br><span class="line">随机抽查，重点抽查</span><br></pre></td></tr></table></figure>

<h3 id="1-3-数据淘汰策略（逐出算法）"><a href="#1-3-数据淘汰策略（逐出算法）" class="headerlink" title="1.3 数据淘汰策略（逐出算法）"></a>1.3 数据淘汰策略（逐出算法）</h3><h4 id="1-3-1-淘汰策略概述"><a href="#1-3-1-淘汰策略概述" class="headerlink" title="1.3.1 淘汰策略概述"></a>1.3.1 淘汰策略概述</h4><p>什么叫数据淘汰策略？什么样的应用场景需要用到数据淘汰策略？</p>
<p>当新数据进入redis时，如果内存不足怎么办？在执行每一个命令前，会调用**freeMemoryIfNeeded()**检测内存是否充足。如果内存不满足新 加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</p>
<p>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕，  如不能达到内存清理的要求，将出现错误信息如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) OOM command not allowed when used memory &gt;&#x27;maxmemory&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-策略配置"><a href="#1-3-2-策略配置" class="headerlink" title="1.3.2 策略配置"></a>1.3.2 策略配置</h4><p>影响数据淘汰的相关配置如下：</p>
<p>1：最大可使用内存，即占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxmemory</span> <span class="string">?mb</span></span><br></pre></td></tr></table></figure>

<p>2：每次选取待删除数据的个数，采用随机获取数据的方式作为待检测删除数据</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxmemory-samples</span> <span class="string">count</span></span><br></pre></td></tr></table></figure>

<p>3：对数据进行删除的选择策略</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxmemory-policy</span> <span class="string">policy</span></span><br></pre></td></tr></table></figure>

<p>那数据删除的策略policy到底有几种呢？一共是<strong>3类8种</strong></p>
<p><strong>第一类</strong>：检测易失数据（可能会过期的数据集server.db[i].expires ）</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volatile-lru：挑选最近最少使用的数据淘汰</span></span><br><span class="line"><span class="attr">volatile-lfu：挑选最近使用次数最少的数据淘汰</span></span><br><span class="line"><span class="attr">volatile-ttl：挑选将要过期的数据淘汰</span></span><br><span class="line"><span class="attr">volatile-random：任意选择数据淘汰</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/all/5redis/image/lru.png"></p>
<p><strong>第二类</strong>：检测全库数据（所有数据集server.db[i].dict ）</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">allkeys-lru：挑选最近最少使用的数据淘汰</span></span><br><span class="line"><span class="attr">allkeLyRs-lfu：：挑选最近使用次数最少的数据淘汰</span></span><br><span class="line"><span class="attr">allkeys-random：任意选择数据淘汰，相当于随机</span></span><br></pre></td></tr></table></figure>

<p><strong>第三类</strong>：放弃数据驱逐</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">no-enviction（驱逐）：禁止驱逐数据(redis4.0中默认策略)，会引发OOM(Out</span> <span class="string">Of Memory)</span></span><br></pre></td></tr></table></figure>

<p>注意：这些策略是配置到哪个属性上？怎么配置？如下所示</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">maxmemory-policy</span> <span class="string">volatile-lru</span></span><br></pre></td></tr></table></figure>

<p><strong>数据淘汰策略配置依据</strong></p>
<p> 使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置</p>
<h2 id="2-主从复制"><a href="#2-主从复制" class="headerlink" title="2.主从复制"></a>2.主从复制</h2><h3 id="2-1-主从复制简介"><a href="#2-1-主从复制简介" class="headerlink" title="2.1 主从复制简介"></a>2.1 主从复制简介</h3><h4 id="2-1-1-高可用"><a href="#2-1-1-高可用" class="headerlink" title="2.1.1 高可用"></a>2.1.1 高可用</h4><p>首先我们要理解互联网应用因为其独有的特性我们演化出的<strong>三高</strong>架构</p>
<ul>
<li><p>高并发</p>
<blockquote>
<p>应用要提供某一业务要能支持很多客户端同时访问的能力，我们称为并发，高并发意思就很明确了</p>
</blockquote>
</li>
<li><p>高性能</p>
<blockquote>
<p>性能带给我们最直观的感受就是：速度快，时间短</p>
</blockquote>
</li>
<li><p>高可用</p>
</li>
</ul>
<p><strong>可用性</strong>：一年中应用服务正常运行的时间占全年时间的百分比，如下图：表示了应用服务在全年宕机的时间</p>
<p>![](D:&#x2F;BaiduNetdiskDownload&#x2F;黑马微服务&#x2F;1.Redis高级【海量资源尽在 】&#x2F;1.Redis高级&#x2F;讲义-md版本&#x2F;img&#x2F;5.png</p>
<p>我们把这些时间加在一起就是全年应用服务不可用的时间，然后我们可以得到应用服务全年可用的时间</p>
<blockquote>
<p>4小时27分15秒+11分36秒+2分16秒&#x3D;4小时41分7秒&#x3D;16867秒</p>
<p>1年&#x3D;365<em>24</em>60*60&#x3D;31536000秒</p>
<p>可用性&#x3D;（31536000-16867）&#x2F;31536000*100%&#x3D;99.9465151%</p>
</blockquote>
<p>业界可用性目标**5个9，即99.999%**，即服务器年宕机时长低于315秒，约5.25分钟</p>
<h4 id="2-1-2-主从复制概念"><a href="#2-1-2-主从复制概念" class="headerlink" title="2.1.2 主从复制概念"></a>2.1.2 主从复制概念</h4><p>知道了三高的概念之后，我们想：你的“Redis”是否高可用？那我们要来分析单机redis的风险与问题</p>
<p>问题1.机器故障</p>
<ul>
<li>现象：硬盘故障、系统崩溃</li>
<li>本质：数据丢失，很可能对业务造成灾难性打击</li>
<li>结论：基本上会放弃使用redis.</li>
</ul>
<p>问题2.容量瓶颈</p>
<ul>
<li>现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存</li>
<li>本质：穷，硬件条件跟不上</li>
<li>结论：放弃使用redis</li>
</ul>
<p>结论：</p>
<p>为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。</p>
<p>多台服务器连接方案：</p>
<p><img src="/2022/10/09/all/5redis/image/6.png"></p>
<ul>
<li>提供数据方：<strong>master</strong></li>
</ul>
<p>主服务器，主节点，主库主客户端</p>
<ul>
<li>接收数据方：<strong>slave</strong></li>
</ul>
<p>从服务器，从节点，从库</p>
<p>从客户端</p>
<ul>
<li>需要解决的问题：</li>
</ul>
<p>数据同步（master的数据复制到slave中）</p>
<p>这里我们可以来解释主从复制的概念：</p>
<p><strong>概念：主从复制即将master中的数据即时、有效的复制到slave中</strong></p>
<p><strong>特征</strong>：一个master可以拥有多个slave，一个slave只对应一个master</p>
<p><strong>职责</strong>：master和slave各自的职责不一样</p>
<p>master:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">写数据</span><br><span class="line"></span><br><span class="line">执行写操作时，将出现变化的数据自动同步到slave</span><br><span class="line"></span><br><span class="line">读数据（可忽略）</span><br></pre></td></tr></table></figure>

<p>slave:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读数据</span><br><span class="line"></span><br><span class="line">写数据（禁止）</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-主从复制的作用"><a href="#2-1-3-主从复制的作用" class="headerlink" title="2.1.3 主从复制的作用"></a>2.1.3 主从复制的作用</h4><ul>
<li>读写分离：master写、slave读，提高服务器的读写负载能力</li>
<li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数 量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li>
<li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
<li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li>
</ul>
<h3 id="2-2-主从复制工作流程"><a href="#2-2-主从复制工作流程" class="headerlink" title="2.2 主从复制工作流程"></a>2.2 主从复制工作流程</h3><p>主从复制过程大体可以分为3个阶段</p>
<ul>
<li>建立连接阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段（反复同步）</li>
</ul>
<p><img src="/2022/10/09/all/5redis/image/7.png"></p>
<p>而命令的传播其实有4种，分别如下：</p>
<p><img src="/2022/10/09/all/5redis/image/8.png"></p>
<h4 id="2-2-1-主从复制的工作流程（三个阶段）"><a href="#2-2-1-主从复制的工作流程（三个阶段）" class="headerlink" title="2.2.1 主从复制的工作流程（三个阶段）"></a>2.2.1 主从复制的工作流程（三个阶段）</h4><h5 id="2-2-1-1-阶段一：建立连接"><a href="#2-2-1-1-阶段一：建立连接" class="headerlink" title="2.2.1.1 阶段一：建立连接"></a>2.2.1.1 阶段一：建立连接</h5><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号</p>
<p>流程如下：</p>
<ol>
<li>步骤1：设置master的地址和端口，保存master信息</li>
<li>步骤2：建立socket连接</li>
<li>步骤3：发送ping命令（定时器任务）</li>
<li>步骤4：身份验证</li>
<li>步骤5：发送slave端口信息</li>
</ol>
<p>至此，主从连接成功！</p>
<p>当前状态：</p>
<p>slave：保存master的地址与端口</p>
<p>master：保存slave的端口</p>
<p>总体：之间创建了连接的socket</p>
<p><img src="/2022/10/09/all/5redis/image/9.png"></p>
<p><strong>master和slave互联</strong></p>
<p>接下来就要通过某种方式将master和slave连接到一起</p>
<p>方式一：客户端发送命令</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slaveof</span> <span class="string">masterip masterport</span></span><br></pre></td></tr></table></figure>

<p>方式二：启动服务器参数</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-server</span> <span class="string">--slaveof masterip masterport</span></span><br></pre></td></tr></table></figure>

<p>方式三：服务器配置（<strong>主流方式</strong>）</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slaveof</span> <span class="string">masterip masterport</span></span><br></pre></td></tr></table></figure>

<p>slave系统信息</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">master_link_down_since_seconds</span></span><br><span class="line"><span class="attr">masterhost</span> <span class="string">&amp; masterport</span></span><br></pre></td></tr></table></figure>

<p>master系统信息</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">uslave_listening_port(多个)</span></span><br></pre></td></tr></table></figure>

<p><strong>主从断开连接</strong></p>
<p>断开slave与master的连接，slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slaveof</span> <span class="string">no one</span></span><br></pre></td></tr></table></figure>

<p><strong>授权访问</strong></p>
<p>master客户端发送命令设置密码</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">requirepass</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>

<p>master配置文件设置密码</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">config</span> <span class="string">set requirepass password</span></span><br><span class="line"><span class="attr">config</span> <span class="string">get requirepass</span></span><br></pre></td></tr></table></figure>

<p>slave客户端发送命令设置密码</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auth</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>

<p>slave配置文件设置密码</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">masterauth</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>

<p>slave启动服务器设置密码</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-server</span> <span class="string">–a password</span></span><br></pre></td></tr></table></figure>



<h5 id="2-2-1-2-阶段二：数据同步"><a href="#2-2-1-2-阶段二：数据同步" class="headerlink" title="2.2.1.2 阶段二：数据同步"></a>2.2.1.2 阶段二：数据同步</h5><ul>
<li>在slave初次连接master后，复制master中的所有数据到slave</li>
<li>将slave的数据库状态更新成master当前的数据库状态</li>
</ul>
<p>同步过程如下：</p>
<ol>
<li>步骤1：请求同步数据</li>
<li>步骤2：创建RDB同步数据</li>
<li>步骤3：恢复RDB同步数据</li>
<li>步骤4：请求部分同步数据</li>
<li>步骤5：恢复部分同步数据</li>
</ol>
<p>至此，数据同步工作完成！</p>
<p>当前状态：</p>
<p>slave：具有master端全部数据，包含RDB过程接收的数据</p>
<p>master：保存slave当前数据同步的位置</p>
<p>总体：之间完成了数据克隆</p>
<p><img src="/2022/10/09/all/5redis/image/10.png"></p>
<p><strong>数据同步阶段master说明</strong></p>
<p>1：如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p>
<p>2：复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repl-backlog-size</span> <span class="string">?mb</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</li>
</ol>
<p><img src="/2022/10/09/all/5redis/image/11.png"></p>
<p><strong>数据同步阶段slave说明</strong></p>
<ol>
<li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slave-serve-stale-data</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p>
</li>
<li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</p>
</li>
<li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择</p>
</li>
</ol>
<h5 id="2-2-1-3-阶段三：命令传播"><a href="#2-2-1-3-阶段三：命令传播" class="headerlink" title="2.2.1.3 阶段三：命令传播"></a>2.2.1.3 阶段三：命令传播</h5><ul>
<li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播</li>
<li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li>
</ul>
<p><strong>命令传播阶段的部分复制</strong></p>
<p>命令传播阶段出现了断网现象：</p>
<p>网络闪断闪连：忽略</p>
<p>短时间网络中断：部分复制</p>
<p>长时间网络中断：全量复制</p>
<p>这里我们主要来看部分复制，部分复制的三个核心要素</p>
<ol>
<li>服务器的运行 id（run id）</li>
<li>主服务器的复制积压缓冲区</li>
<li>主从服务器的复制偏移量</li>
</ol>
<ul>
<li>服务器运行ID（runid）</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</span><br><span class="line"></span><br><span class="line">组成：运行id由40位字符组成，是一个随机的十六进制字符</span><br><span class="line">例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</span><br><span class="line"></span><br><span class="line">作用：运行id被用于在服务器间进行传输，识别身份</span><br><span class="line">如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</span><br><span class="line"></span><br><span class="line">实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，</span><br><span class="line">slave保存此ID，通过info Server命令，可以查看节点的runid</span><br></pre></td></tr></table></figure>

<ul>
<li>复制缓冲区</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</span><br><span class="line"><span class="code">	复制缓冲区默认数据存储空间大小是1M</span></span><br><span class="line"><span class="code">	当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列</span></span><br><span class="line"><span class="code">作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/all/5redis/image/12.png"></p>
<p>复制缓冲区内部工作原理：</p>
<p>组成</p>
<ul>
<li><p>偏移量</p>
<blockquote>
<p>概念：一个数字，描述复制缓冲区中的指令字节位置</p>
<p>分类：</p>
<ul>
<li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li>
<li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li>
</ul>
<p>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</p>
<p>数据来源：</p>
<ul>
<li>master端：发送一次记录一次</li>
<li>slave端：接收一次记录一次</li>
</ul>
</blockquote>
</li>
<li><p>字节值</p>
</li>
</ul>
<p>工作原理</p>
<ul>
<li>通过offset区分不同的slave当前数据传播的差异</li>
<li>master记录已发送的信息对应的offset</li>
<li>slave记录已接收的信息对应的offset</li>
</ul>
<p><img src="/2022/10/09/all/5redis/image/13.png"></p>
<h4 id="2-2-2-流程更新-全量复制-x2F-部分复制"><a href="#2-2-2-流程更新-全量复制-x2F-部分复制" class="headerlink" title="2.2.2 流程更新(全量复制&#x2F;部分复制)"></a>2.2.2 流程更新(全量复制&#x2F;部分复制)</h4><p>我们再次的总结一下主从复制的三个阶段的工作流程：</p>
<p><img src="/2022/10/09/all/5redis/image/14.png"></p>
<h4 id="2-2-3-心跳机制"><a href="#2-2-3-心跳机制" class="headerlink" title="2.2.3 心跳机制"></a>2.2.3 心跳机制</h4><p>什么是心跳机制？</p>
<p>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</p>
<p>master心跳：</p>
<ul>
<li>内部指令：PING</li>
<li>周期：由repl-ping-slave-period决定，默认10秒</li>
<li>作用：判断slave是否在线</li>
<li>查询：INFO replication  获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li>
</ul>
<p>slave心跳任务</p>
<ul>
<li>内部指令：REPLCONF ACK {offset}</li>
<li>周期：1秒</li>
<li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li>
<li>作用2：判断master是否在线</li>
</ul>
<p>心跳阶段注意事项：</p>
<ul>
<li>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">min-slaves-to-write</span> <span class="string">2</span></span><br><span class="line"><span class="attr">min-slaves-max-lag</span> <span class="string">8</span></span><br></pre></td></tr></table></figure>

<p>slave数量少于2个，或者所有slave的延迟都大于等于8秒时，强制关闭master写功能，停止数据同步</p>
<ul>
<li><p>slave数量由slave发送REPLCONF ACK命令做确认</p>
</li>
<li><p>slave延迟由slave发送REPLCONF ACK命令做确认</p>
</li>
</ul>
<p>至此：我们可以总结出完整的主从复制流程：</p>
<p><img src="/2022/10/09/all/5redis/image/15.png"></p>
<h3 id="2-3-主从复制常见问题"><a href="#2-3-主从复制常见问题" class="headerlink" title="2.3 主从复制常见问题"></a>2.3 主从复制常见问题</h3><h4 id="2-3-1-频繁的全量复制"><a href="#2-3-1-频繁的全量复制" class="headerlink" title="2.3.1 频繁的全量复制"></a>2.3.1 频繁的全量复制</h4><ul>
<li>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作</li>
</ul>
<p>内部优化调整方案：</p>
<p>1：master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave</p>
<p>2：在master关闭时执行命令shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repl-id  repl-offset</span><br><span class="line"></span><br><span class="line">通过redis-check-rdb命令可以查看该信息</span><br></pre></td></tr></table></figure>

<p>3：master重启后加载RDB文件，恢复数据，重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master<span class="emphasis">_repl_</span>id=repl  master<span class="emphasis">_repl_</span>offset =repl-offset</span><br><span class="line"></span><br><span class="line">通过info命令可以查看该信息</span><br></pre></td></tr></table></figure>

<p>作用：本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master</p>
<ul>
<li>第二种出现频繁全量复制的问题现象：网络环境不佳，出现网络中断，slave不提供服务</li>
</ul>
<p>问题原因：复制缓冲区过小，断网后slave的offset越界，触发全量复制</p>
<p>最终结果：slave反复进行全量复制</p>
<p>解决方案：修改复制缓冲区大小</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repl-backlog-size</span> <span class="string">?mb</span></span><br></pre></td></tr></table></figure>

<p>建议设置如下：</p>
<p>1.测算从master到slave的重连平均时长second</p>
<p>2.获取master平均每秒产生写命令数据总量write_size_per_second</p>
<p>3.最优复制缓冲区空间 &#x3D; 2 * second * write_size_per_second</p>
<h4 id="2-3-2-频繁的网络中断"><a href="#2-3-2-频繁的网络中断" class="headerlink" title="2.3.2 频繁的网络中断"></a>2.3.2 频繁的网络中断</h4><ul>
<li>问题现象：master的CPU占用过高 或 slave频繁断开连接</li>
</ul>
<p>问题原因</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slave每1秒发送REPLCONFACK命令到master</span><br><span class="line"></span><br><span class="line">当slave接到了慢查询时（keys <span class="emphasis">* ，hgetall等），会大量占用CPU性能</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</span></span><br></pre></td></tr></table></figure>

<p>最终结果：master各种资源（输出缓冲区、带宽、连接等）被严重占用</p>
<p>解决方案：通过设置合理的超时时间，确认是否释放slave</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repl-timeout</span> <span class="string">seconds</span></span><br></pre></td></tr></table></figure>

<p>该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</p>
<ul>
<li>问题现象：slave与master连接断开</li>
</ul>
<p>问题原因</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">master发送ping指令频度较低</span><br><span class="line"></span><br><span class="line">master设定超时时间较短</span><br><span class="line"></span><br><span class="line">ping指令在网络中存在丢包</span><br></pre></td></tr></table></figure>

<p>解决方案：提高ping指令发送的频度</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repl-ping-slave-period</span> <span class="string">seconds</span></span><br></pre></td></tr></table></figure>

<p>超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</p>
<h4 id="2-3-3-数据不一致"><a href="#2-3-3-数据不一致" class="headerlink" title="2.3.3 数据不一致"></a>2.3.3 数据不一致</h4><p>问题现象：多个slave获取相同数据不同步</p>
<p>问题原因：网络信息不同步，数据发送有延迟</p>
<p>解决方案</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</span><br><span class="line"></span><br><span class="line">监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slave-serve-stale-data</span>	<span class="string">yes|no</span></span><br></pre></td></tr></table></figure>

<p>开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）</p>
<h2 id="3-哨兵模式"><a href="#3-哨兵模式" class="headerlink" title="3.哨兵模式"></a>3.哨兵模式</h2><h3 id="3-1-哨兵简介"><a href="#3-1-哨兵简介" class="headerlink" title="3.1 哨兵简介"></a>3.1 哨兵简介</h3><h4 id="3-1-1-哨兵概念"><a href="#3-1-1-哨兵概念" class="headerlink" title="3.1.1 哨兵概念"></a>3.1.1 哨兵概念</h4><p>首先我们来看一个业务场景：如果redis的master宕机了，此时应该怎么办？</p>
<p><img src="/2022/10/09/all/5redis/image/16.png"></p>
<p>那此时我们可能需要从一堆的slave中重新选举出一个新的master，那这个操作过程是什么样的呢？这里面会有什么问题出现呢？</p>
<p><img src="/2022/10/09/all/5redis/image/17.png"></p>
<p>要实现这些功能，我们就需要redis的哨兵，那哨兵是什么呢？</p>
<p><strong>哨兵</strong></p>
<p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过<strong>投票</strong>机制<strong>选择</strong>新的master并将所有slave连接到新的master。</p>
<p><img src="/2022/10/09/all/5redis/image/18.png"></p>
<h4 id="3-1-2-哨兵作用"><a href="#3-1-2-哨兵作用" class="headerlink" title="3.1.2 哨兵作用"></a>3.1.2 哨兵作用</h4><p>哨兵的作用：</p>
<ul>
<li><p>监控：监控master和slave</p>
<p>不断的检查master和slave是否正常运行</p>
<p>master存活检测、master与slave运行情况检测</p>
</li>
<li><p>通知（提醒）：当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知</p>
</li>
<li><p>自动故障转移：断开master与slave连接，选取一个slave作为master，将其他slave连接新的master，并告知客户端新的服务器地址</p>
</li>
</ul>
<p>注意：哨兵也是一台redis服务器，只是不提供数据相关服务，通常哨兵的数量配置为单数</p>
<h3 id="3-2-启用哨兵"><a href="#3-2-启用哨兵" class="headerlink" title="3.2 启用哨兵"></a>3.2 启用哨兵</h3><p>配置哨兵</p>
<ul>
<li><p>配置一拖二的主从结构（利用之前的方式启动即可）</p>
</li>
<li><p>配置三个哨兵（配置相同，端口不同），参看sentinel.conf</p>
</li>
</ul>
<p>1：设置哨兵监听的主服务器信息， sentinel_number表示参与投票的哨兵数量</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">monitor master_name  master_host	master_port	 sentinel_number</span></span><br></pre></td></tr></table></figure>

<p>2：设置判定服务器宕机时长，该设置控制是否进行主从切换</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">down-after-milliseconds master_name	million_seconds</span></span><br></pre></td></tr></table></figure>

<p>3：设置故障切换的最大超时时</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">failover-timeout master_name	million_seconds</span></span><br></pre></td></tr></table></figure>

<p>4：设置主从切换后，同时进行数据同步的slave数量，数值越大，要求网络资源越高，数值越小，同步时间越长</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sentinel</span> <span class="string">parallel-syncs master_name sync_slave_number</span></span><br></pre></td></tr></table></figure>


<ul>
<li>启动哨兵</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-sentinel</span> <span class="string">filename</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-哨兵工作原理"><a href="#3-3-哨兵工作原理" class="headerlink" title="3.3 哨兵工作原理"></a>3.3 哨兵工作原理</h3><p>哨兵在进行主从切换过程中经历三个阶段</p>
<ul>
<li>监控</li>
<li>通知</li>
<li>故障转移</li>
</ul>
<h4 id="3-3-1-监控"><a href="#3-3-1-监控" class="headerlink" title="3.3.1 监控"></a>3.3.1 监控</h4><p>用于同步各个节点的状态信息</p>
<p><img src="/2022/10/09/all/5redis/image/19.png"></p>
<ul>
<li><p>获取各个sentinel的状态（是否在线）</p>
</li>
<li><p>获取master的状态</p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">master属性</span><br><span class="line"><span class="code">	prunid</span></span><br><span class="line"><span class="code">	prole：master</span></span><br><span class="line"><span class="code">各个slave的详细信息	</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取所有slave的状态（根据master中的slave信息）</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slave属性</span><br><span class="line"><span class="code">	prunid</span></span><br><span class="line"><span class="code">	prole：slave</span></span><br><span class="line"><span class="code">	pmaster_host、master_port</span></span><br><span class="line"><span class="code">	poffset</span></span><br></pre></td></tr></table></figure>

<p>其内部的工作原理具体如下：</p>
<p><img src="/2022/10/09/all/5redis/image/20.png"></p>
<h4 id="3-3-2-通知"><a href="#3-3-2-通知" class="headerlink" title="3.3.2 通知"></a>3.3.2 通知</h4><p>sentinel在通知阶段要不断的去获取master&#x2F;slave的信息，然后在各个sentinel之间进行共享，具体的流程如下：</p>
<p><img src="/2022/10/09/all/5redis/image/21.png"></p>
<h4 id="3-3-3-故障转移"><a href="#3-3-3-故障转移" class="headerlink" title="3.3.3 故障转移"></a>3.3.3 故障转移</h4><p>当master宕机后sentinel是如何知晓并判断出master是真的宕机了呢？我们来看具体的操作流程</p>
<p><img src="/2022/10/09/all/5redis/image/22.png"></p>
<p>当sentinel认定master下线之后，此时需要决定更换master，那这件事由哪个sentinel来做呢？这时候sentinel之间要进行选举，如下图所示：</p>
<p><img src="/2022/10/09/all/5redis/image/23.png"></p>
<p>在选举的时候每一个人手里都有一票，而每一个人的又都想当这个处理事故的人，那怎么办？大家就开始抢，于是每个人都会发出一个指令，在内网里边告诉大家我要当选举人，比如说现在的sentinel1和sentinel4发出这个选举指令了，那么sentinel2既能接到sentinel1的也能接到sentinel4的，接到了他们的申请以后呢，sentinel2他就会把他的一票投给其中一方，投给谁呢？谁先过来我投给谁，假设sentinel1先过来，所以这个票就给到了sentinel1。那么给过去以后呢，现在sentinel1就拿到了一票，按照这样的一种形式，最终会有一个选举结果。对应的选举最终得票多的，那自然就成为了处理事故的人。需要注意在这个过程中有可能会存在失败的现象，就是一轮选举完没有选取，那就会接着进行第二轮第三轮直到完成选举。</p>
<p>接下来就是由选举胜出的sentinel去从slave中选一个新的master出来的工作，这个流程是什么样的呢？</p>
<p>首先它有一个在服务器列表中挑选备选master的原则</p>
<ul>
<li><p>不在线的OUT</p>
</li>
<li><p>响应慢的OUT</p>
</li>
<li><p>与原master断开时间久的OUT</p>
</li>
<li><p>优先原则</p>
<p>​	优先级<br>​		offset<br>​		runid</p>
</li>
</ul>
<p>选出新的master之后，发送指令（ sentinel ）给其他的slave：</p>
<ul>
<li><p>向新的master发送slaveof no one</p>
</li>
<li><p>向其他slave发送slaveof 新masterIP端口</p>
</li>
</ul>
<p><strong>总结</strong>：故障转移阶段</p>
<ol>
<li>发现问题，主观下线与客观下线</li>
<li>竞选负责人</li>
<li>优选新master</li>
<li>新master上任，其他slave切换master，原master作为slave故障恢复后连接</li>
</ol>
<h2 id="4-集群cluster"><a href="#4-集群cluster" class="headerlink" title="4.集群cluster"></a>4.集群cluster</h2><p>现状问题：业务发展过程中遇到的峰值瓶颈</p>
<ul>
<li>redis提供的服务OPS可以达到10万&#x2F;秒，当前业务OPS已经达到10万&#x2F;秒</li>
<li>内存单机容量达到256G，当前业务需求内存容量1T</li>
<li>使用集群的方式可以快速解决上述问题</li>
</ul>
<h3 id="4-1-集群简介"><a href="#4-1-集群简介" class="headerlink" title="4.1 集群简介"></a>4.1 集群简介</h3><p>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</p>
<p><img src="/2022/10/09/all/5redis/image/24.png"></p>
<p><strong>集群作用：</strong></p>
<ul>
<li>分散单台服务器的访问压力，实现负载均衡</li>
<li>分散单台服务器的存储压力，实现可扩展性</li>
<li>降低单台服务器宕机带来的业务灾难</li>
</ul>
<p><img src="/2022/10/09/all/5redis/image/25.png"></p>
<h3 id="4-2-Cluster集群结构设计"><a href="#4-2-Cluster集群结构设计" class="headerlink" title="4.2 Cluster集群结构设计"></a>4.2 Cluster集群结构设计</h3><p><strong>数据存储设计：</strong></p>
<ol>
<li><p>通过算法设计，计算出key应该保存的位置</p>
</li>
<li><p>将所有的存储空间计划切割成16384份，每台主机保存一部分</p>
<p>注意：每份代表的是一个存储空间，不是一个key的保存空间</p>
</li>
<li><p>将key按照计算出的结果放到对应的存储空间</p>
</li>
</ol>
<p><img src="/2022/10/09/all/5redis/image/26.png"></p>
<p>那redis的集群是如何增强可扩展性的呢？譬如我们要增加一个集群节点</p>
<p><img src="/2022/10/09/all/5redis/image/27.png"></p>
<p>当我们查找数据时，集群是如何操作的呢？</p>
<ul>
<li>各个数据库相互通信，保存各个库中槽的编号数据</li>
<li>一次命中，直接返回</li>
<li>一次未命中，告知具体位置</li>
</ul>
<p><img src="/2022/10/09/all/5redis/image/28.png"></p>
<h3 id="4-3-Cluster集群结构搭建"><a href="#4-3-Cluster集群结构搭建" class="headerlink" title="4.3 Cluster集群结构搭建"></a>4.3 Cluster集群结构搭建</h3><p>首先要明确的几个要点：</p>
<ul>
<li>配置服务器（3主3从）</li>
<li>建立通信（Meet）</li>
<li>分槽（Slot）</li>
<li>搭建主从（master-slave）</li>
</ul>
<p><strong>Cluster配置</strong></p>
<ul>
<li>是否启用cluster，加入cluster节点</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster-enabled</span> <span class="string">yes|no</span></span><br></pre></td></tr></table></figure>

<ul>
<li>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster-config-file</span> <span class="string">filename</span></span><br></pre></td></tr></table></figure>

<ul>
<li>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster-node-timeout</span> <span class="string">milliseconds</span></span><br></pre></td></tr></table></figure>

<ul>
<li>master连接的slave最小数量</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster-migration-barrier</span> <span class="string">min_slave_number</span></span><br></pre></td></tr></table></figure>

<p><strong>Cluster节点操作命令</strong></p>
<ul>
<li>查看集群节点信息</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">nodes</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更改slave指向新的master</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">replicate master-id</span></span><br></pre></td></tr></table></figure>

<ul>
<li>发现一个新节点，新增master</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">meet ip:port</span></span><br></pre></td></tr></table></figure>

<ul>
<li>忽略一个没有solt的节点</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">forget server_id</span></span><br></pre></td></tr></table></figure>

<ul>
<li>手动故障转移</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster</span> <span class="string">failover</span></span><br></pre></td></tr></table></figure>

<p><strong>集群操作命令：</strong></p>
<ul>
<li>创建集群</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">–-cluster create masterhost1:masterport1 masterhost2:masterport2  masterhost3:masterport3 [masterhostn:masterportn …] slavehost1:slaveport1  slavehost2:slaveport2 slavehost3:slaveport3 -–cluster-replicas n</span></span><br></pre></td></tr></table></figure>

<p>注意：master与slave的数量要匹配，一个master对应n个slave，由最后的参数n决定</p>
<p>master与slave的匹配顺序为第一个master与前n个slave分为一组，形成主从结构</p>
<ul>
<li>添加master到当前集群中，连接时可以指定任意现有节点地址与端口</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster add-node new-master-host:new-master-port now-host:now-port</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加slave</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster add-node new-slave-host:new-slave-port master-host:master-port --cluster-slave --cluster-master-id masterid</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除节点，如果删除的节点是master，必须保障其中没有槽slot</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster del-node del-slave-host:del-slave-port del-slave-id</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重新分槽，分槽是从具有槽的master中划分一部分给其他master，过程中不创建新的槽</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster reshard new-master-host:new-master:port --cluster-from src-  master-id1, src-master-id2, src-master-idn --cluster-to target-master-id --  cluster-slots slots</span></span><br></pre></td></tr></table></figure>

<p>注意：将需要参与分槽的所有masterid不分先后顺序添加到参数中，使用，分隔</p>
<p>指定目标得到的槽的数量，所有的槽将平均从每个来源的master处获取</p>
<ul>
<li>重新分配槽，从具有槽的master中分配指定数量的槽到另一个master中，常用于清空指定master中的槽</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis-cli</span> <span class="string">--cluster reshard src-master-host:src-master-port --cluster-from src-  master-id --cluster-to target-master-id --cluster-slots slots --cluster-yes</span></span><br></pre></td></tr></table></figure>

<h2 id="5-企业级解决方案"><a href="#5-企业级解决方案" class="headerlink" title="5.企业级解决方案"></a>5.企业级解决方案</h2><h3 id="5-1-缓存预热"><a href="#5-1-缓存预热" class="headerlink" title="5.1 缓存预热"></a>5.1 缓存预热</h3><p><strong>场景</strong>：“宕机”</p>
<p>服务器启动后迅速宕机</p>
<p><strong>问题排查</strong>：</p>
<p>1.请求数量较高，大量的请求过来之后都需要去从缓存中获取数据，但是缓存中又没有，此时从数据库中查找数据然后将数据再存入缓存，造成了短期内对redis的高强度操作从而导致问题</p>
<p>2.主从之间数据吞吐量较大，数据同步操作频度较高</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>前置准备工作：</li>
</ul>
<p>1.日常例行统计数据访问记录，统计访问频度较高的热点数据</p>
<p>2.利用LRU数据删除策略，构建数据留存队列例如：storm与kafka配合</p>
<ul>
<li>准备工作：</li>
</ul>
<p>1.将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</p>
<p>2.利用分布式多服务器同时进行数据读取，提速数据加载过程</p>
<p>3.热点数据主从同时预热</p>
<ul>
<li>实施：</li>
</ul>
<p>4.使用脚本程序固定触发数据预热过程</p>
<p>5.如果条件允许，使用了CDN（内容分发网络），效果会更好</p>
<p><strong>总的来说</strong>：缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<h3 id="5-2-缓存雪崩"><a href="#5-2-缓存雪崩" class="headerlink" title="5.2 缓存雪崩"></a>5.2 缓存雪崩</h3><p><strong>场景</strong>：数据库服务器崩溃，一连串的场景会随之儿来</p>
<p>1.系统平稳运行过程中，忽然数据库连接量激增</p>
<p>2.应用服务器无法及时处理请求</p>
<p>3.大量408，500错误页面出现</p>
<p>4.客户反复刷新页面获取数据</p>
<p>5.数据库崩溃</p>
<p>6.应用服务器崩溃</p>
<p>7.重启应用服务器无效</p>
<p>8.Redis服务器崩溃</p>
<p>9.Redis集群崩溃</p>
<p>10.重启数据库后再次被瞬间流量放倒</p>
<p><strong>问题排查</strong>：</p>
<p>1.在一个较短的时间内，缓存中较多的key集中过期</p>
<p>2.此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</p>
<p>3.数据库同时接收到大量的请求无法及时处理</p>
<p>4.Redis大量请求被积压，开始出现超时现象</p>
<p>5.数据库流量激增，数据库崩溃</p>
<p>6.重启后仍然面对缓存中无数据可用</p>
<p>7.Redis服务器资源被严重占用，Redis服务器崩溃</p>
<p>8.Redis集群呈现崩塌，集群瓦解</p>
<p>9.应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</p>
<p>10.应用服务器，redis，数据库全部重启，效果不理想</p>
<p>总而言之就两点：短时间范围内，大量key集中过期</p>
<p><strong>解决方案</strong></p>
<ul>
<li>思路：</li>
</ul>
<p>1.更多的页面静态化处理</p>
<p>2.构建多级缓存架构</p>
<p>​	Nginx缓存+redis缓存+ehcache缓存</p>
<p>3.检测Mysql严重耗时业务进行优化</p>
<p>​	对数据库的瓶颈排查：例如超时查询、耗时较高事务等</p>
<p>4.灾难预警机制</p>
<p>​	监控redis服务器性能指标</p>
<p>​		CPU占用、CPU使用率</p>
<p>​		内存容量</p>
<p>​		查询平均响应时间</p>
<p>​		线程数</p>
<p>5.限流、降级</p>
<p>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</p>
<ul>
<li>落地实践：</li>
</ul>
<p>1.LRU与LFU切换</p>
<p>2.数据有效期策略调整</p>
<p>​	根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</p>
<p>​	过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</p>
<p>3.超热数据使用永久key</p>
<p>4.定期维护（自动+人工）</p>
<p>​	对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</p>
<p>5.加锁：慎用！</p>
<p><strong>总的来说</strong>：缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的 出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p>
<h3 id="5-3-缓存击穿"><a href="#5-3-缓存击穿" class="headerlink" title="5.3 缓存击穿"></a>5.3 缓存击穿</h3><p><strong>场景</strong>：还是数据库服务器崩溃，但是跟之前的场景有点不太一样</p>
<p>1.系统平稳运行过程中</p>
<p>2.数据库连接量瞬间激增</p>
<p>3.Redis服务器无大量key过期</p>
<p>4.Redis内存平稳，无波动</p>
<p>5.Redis服务器CPU正常</p>
<p>6.数据库崩溃</p>
<p><strong>问题排查：</strong></p>
<p>1.Redis中某个key过期，该key访问量巨大</p>
<p>2.多个数据请求从服务器直接压到Redis后，均未命中</p>
<p>3.Redis在短时间内发起了大量对数据库中同一数据的访问</p>
<p>总而言之就两点：单个key高热数据，key过期</p>
<p><strong>解决方案</strong>：</p>
<p>1.预先设定</p>
<p>​	以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p>
<p>2.现场调整</p>
<p>​	监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</p>
<p>3.后台刷新数据</p>
<p>​	启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</p>
<p>4.二级缓存</p>
<p>​	设置不同的失效时间，保障不会被同时淘汰就行</p>
<p>5.加锁</p>
<p>​	分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</p>
<p><strong>总的来说</strong>：缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数 据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过 期监控难度较高，配合雪崩处理策略即可。</p>
<h3 id="5-4-缓存穿透"><a href="#5-4-缓存穿透" class="headerlink" title="5.4 缓存穿透"></a>5.4 缓存穿透</h3><p><strong>场景</strong>：数据库服务器又崩溃了，跟之前的一样吗？</p>
<p>1.系统平稳运行过程中</p>
<p>2.应用服务器流量随时间增量较大</p>
<p>3.Redis服务器命中率随时间逐步降低</p>
<p>4.Redis内存平稳，内存无压力</p>
<p>5.Redis服务器CPU占用激增</p>
<p>6.数据库服务器压力激增</p>
<p>7.数据库崩溃</p>
<p><strong>问题排查：</strong></p>
<p>1.Redis中大面积出现未命中</p>
<p>2.出现非正常URL访问</p>
<p><strong>问题分析</strong>：</p>
<ul>
<li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li>
<li>Redis获取到null数据未进行持久化，直接返回</li>
<li>下次此类数据到达重复上述过程</li>
<li>出现黑客攻击服务器</li>
</ul>
<p><strong>解决方案</strong>：</p>
<p>1.缓存null</p>
<p>​	对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</p>
<p>2.白名单策略</p>
<p>​	提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时放行，加载异常数据时直接拦截（效率偏低）</p>
<p>​	使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</p>
<p>2.实施监控</p>
<p>​	实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比</p>
<p>​		非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</p>
<p>​		活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象</p>
<p>​	根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</p>
<p>4.key加密</p>
<p>​	问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验</p>
<p>​	例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</p>
<p><strong>总的来说</strong>：缓存击穿是指访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。</p>
<p>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p>
<h3 id="5-5-性能指标监控"><a href="#5-5-性能指标监控" class="headerlink" title="5.5 性能指标监控"></a>5.5 性能指标监控</h3><p>redis中的监控指标如下：</p>
<ul>
<li>性能指标：Performance</li>
</ul>
<blockquote>
<p>响应请求的平均时间:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;latency</span></span><br></pre></td></tr></table></figure>

<p>平均每秒处理请求总数</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;instantaneous_ops_per_sec</span></span><br></pre></td></tr></table></figure>

<p>缓存查询命中率（通过查询总次数与查询得到非nil数据总次数计算而来）</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;hit_rate(calculated)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>内存指标：Memory</li>
</ul>
<blockquote>
<p>当前内存使用量</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;used_memory</span></span><br></pre></td></tr></table></figure>

<p>内存碎片率（关系到是否进行碎片整理）</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;mem_fragmentation_ratio</span></span><br></pre></td></tr></table></figure>

<p>为避免内存溢出删除的key的总数量</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;evicted_keys</span></span><br></pre></td></tr></table></figure>

<p>基于阻塞操作（BLPOP等）影响的客户端数量</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;blocked_clients</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>基本活动指标：Basic_activity</li>
</ul>
<blockquote>
<p>当前客户端连接总数</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;connected_clients</span></span><br></pre></td></tr></table></figure>

<p>当前连接slave总数</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;connected_slaves</span></span><br></pre></td></tr></table></figure>

<p>最后一次主从信息交换距现在的秒</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;master_last_io_seconds_ago</span></span><br></pre></td></tr></table></figure>

<p>key的总数</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;keyspace</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>持久性指标：Persistence</li>
</ul>
<blockquote>
<p>当前服务器最后一次RDB持久化的时间</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;rdb_last_save_time</span></span><br></pre></td></tr></table></figure>

<p>当前服务器最后一次RDB持久化后数据变化总量</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;rdb_changes_since_last_save</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>错误指标：Error</li>
</ul>
<blockquote>
<p>被拒绝连接的客户端总数（基于达到最大连接值的因素）</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;rejected_connections</span></span><br></pre></td></tr></table></figure>

<p>key未命中的总次数</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;keyspace_misses</span></span><br></pre></td></tr></table></figure>

<p>主从断开的秒数</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;master_link_down_since_seconds</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>要对redis的相关指标进行监控，我们可以采用一些用具：</p>
<ul>
<li>CloudInsight Redis</li>
<li>Prometheus</li>
<li>Redis-stat</li>
<li>Redis-faina</li>
<li>RedisLive</li>
<li>zabbix</li>
</ul>
<p>也有一些命令工具：</p>
<ul>
<li>benchmark</li>
</ul>
<blockquote>
<p>测试当前服务器的并发性能</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;redis-benchmark</span> <span class="string">[-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</span></span><br></pre></td></tr></table></figure>

<p>范例1：50个连接，10000次请求对应的性能</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;redis-benchmark</span></span><br></pre></td></tr></table></figure>

<p>范例2：100个连接，5000次请求对应的性能</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;redis-benchmark</span> <span class="string">-c 100 -n 5000</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/all/5redis/image/29.png"></p>
</blockquote>
<ul>
<li><p>redis-cli</p>
<p>​	monitor：启动服务器调试信息</p>
</li>
</ul>
<blockquote>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;monitor</span></span><br></pre></td></tr></table></figure>
</blockquote>
<pre><code>  slowlog：慢日志
</code></pre>
<blockquote>
<p>获取慢查询日志</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;slowlog</span> <span class="string">[operator]</span></span><br></pre></td></tr></table></figure>

<p>​	get ：获取慢查询日志信息</p>
<p>​	len ：获取慢查询日志条目数</p>
<p>​	reset ：重置慢查询日志</p>
<p>相关配置</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;slowlog-log-slower-than</span> <span class="string">1000 #设置慢查询的时间下线，单位：微妙</span></span><br><span class="line"><span class="attr">&gt;slowlog-max-len</span> <span class="string">100	#设置慢查询命令对应的日志显示长度，单位：命令数</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>Redis的高效在于其纯内存运算，但是有得就有失，数据全部存在内存中意味着一旦宕机，数据将会全部丢失，因此必须需要一种机制来保证Redis中的数据不会因为故障而丢失，这就需要Redis拥有数据持久化的能力。</p>
<h2 id="6-持久化"><a href="#6-持久化" class="headerlink" title="6. 持久化"></a>6. 持久化</h2><p>Redis的持久化机制有两种，一种是快照，也就是RDB（Redis DataBase），一种是AOF（Append Only File）日志。</p>
<h3 id="1-1-快照（RDB）"><a href="#1-1-快照（RDB）" class="headerlink" title="1.1 快照（RDB）"></a>1.1 快照（RDB）</h3><p>快照是一次性的全量备份，将某一时刻的全量数据以二进制序列化的形式存储，在空间上非常紧凑，能大大缩小存储所用的空间。</p>
<p>Redis是单线程，而文件IO操作是不支持多路复用的。这难道意味着在进行内存快照时Redis需要停止服务？这当然是不行的，那有指令时服务，没指令时持久化这样边持久化边服务？可是这样的话持久化的同时内存数据还在被指令修改，如果在持有化一个大的Hash字典时，过来一个指令把这个字段删了，这个可怎么办? 显然这样也不行。</p>
<p>为此，Redis使用操作系统的多进程COW（Copy On Write）机制来实现快照持久化。</p>
<p>Redis在持久化时会调用glibc的函数fork产生一个子进程，快照持久化交给子进程处理，父进程继续提供服务。子进程生成时和父进程共用代码段和数据段。也就是说这时间父子进程共享内存数据，因此在分离的一瞬间，内存消耗几乎没有。接下来子内存进行数据持久化，他仅仅是读取，不会修改内存。而父进程对外提供服务，修改数据，但是操作系统的COW机制会进行数据段页面的分离，数据段由操作系统的页面组合而成，父进程修改数据时，COW机制就将数据所在页复制一份出来，父进程在这个复制出来的数据也修改，此时原数据页也就是子线程访问的数据页还是原样，也就是子进程所看到的数据在子进程产生的一瞬间就已经凝固了，可以安心复制，这也是为什么这种持久化方法称为快照原因。 随着父进程的修改，会有越来越多的页面被赋值，但是最多也就是全复制，达到原内存空间的二倍，但是这在大数据量情况下很难发生，因为总会有冷数据存在，而且可能占据多数，所以复制的一般只会是其中的一部分。另外提一下：一个页面的大小是4K。</p>
<h3 id="1-2-AOF日志"><a href="#1-2-AOF日志" class="headerlink" title="1.2 AOF日志"></a>1.2 AOF日志</h3><p>AOF日志是连续性的增量备份，记录的是修改内存数据的指令记录文本。这样就可以通过对一个空的Redis实例顺序执行记录的命令，也就是重放，来复原实例。Redis在收到修改指令后，会先进行校验，如果没问题，会首先把指令追加记录磁盘上的AOF日志中，然后再执行指令，这样即使突发宕机，重放时也能重放到这个指令。</p>
<p>AOF日志随着运行时间的增长会变的越来越庞大，Redis重启时需要加载AOF日志进行指令重放所需的时间也会更加漫长，所以需要定期对AOF重写，进行瘦身。</p>
<h4 id="1-2-1-AOF重写"><a href="#1-2-1-AOF重写" class="headerlink" title="1.2.1 AOF重写"></a>1.2.1 AOF重写</h4><p>AOF重写原理就是开辟一个子进程，然后将内存数据遍历并转换成指令，再记录到一个新的AOF文件中，完毕后再将期间发生的增量AOF日志追加到新的AOF日志中，替换旧的AOF文件，就完成了AOF重写的工作，完成了瘦身。</p>
<h4 id="1-2-2-fsync"><a href="#1-2-2-fsync" class="headerlink" title="1.2.2 fsync"></a>1.2.2 fsync</h4><p>AOF日志是以文件方式存在的，程序对AOF日志进行操作时，实际上是先将内容写到内核为文件描述符分配的一块内存缓存上，然后内核异步将数据写入磁盘的。</p>
<p>但是如果机器突然宕机，内存缓存中的数据还没来的及写入磁盘，就会出现日志的丢失。Linux的gilbc提了了fsync(int fd)函数来强制把指定文件的内存缓存数据写入到磁盘中，实时使用fsync就能保证AOF日志不丢失。但是fsync涉及到磁盘写入，相较于内存操作会慢很多，如果每一个指令都fsync一次，Redis纯内存操作所带来的优势就不存在了。</p>
<p>因此目前主流的做法是Redis每隔1s执行一个fsync，1s是可配置的，可以根据需要配置。这样就在保持高效能的同时尽可能的减少日志丢失。Redis也提供了另外两种策略：一种是永不fsync，由操作系统决定什么时间将内存缓存同步到磁盘，这样无法掌控，很不安全。另一种是一次指令fsync一次，然后不会丢日志，单缺点上面也说过了，生产并不推荐。</p>
<p>Redis4.0新增了异步模型，可以打开fsync的异步处理开关，此时主线程不进行fsync，而是生成任务放到专门的fsync队列中去，由专门的fsync异步线程处理。</p>
<h3 id="1-3-持久化选在从节点"><a href="#1-3-持久化选在从节点" class="headerlink" title="1.3 持久化选在从节点"></a>1.3 持久化选在从节点</h3><p>无论是快照还是AOF，都比较消耗资源。快照需要遍历整个内存，大块磁盘读写加重系统负载。AOF的fsync是一个耗时的IO操作，也会影响Redis性能，加重系统IO负担。因此Redis的持久化一般并不安排在主节点，而是在从节点进行，从节点没有客户端请求的压力，资源比较充足。但是如果出现网络分区，从节点连不上主节点，而主节点又宕机了，就会出现数据丢失产生数据一致性的问题。因此生产环境需要做好网络连通性检测，保证出现问题时能快速修复，除此之外可以再挂一个从节点，这样只要有一个从节点数据同步正常，数据就不会丢失。</p>
<h3 id="1-4-Redis4-0的混合持久化"><a href="#1-4-Redis4-0的混合持久化" class="headerlink" title="1.4 Redis4.0的混合持久化"></a>1.4 Redis4.0的混合持久化</h3><p>Redis重启时，很少使用RDB来恢复数据，因为会丢失最后一次快照之后的数据。但是使用AOF日志重放，效率上又会慢很多。因此Redis4.0提供了混合持久化的策略，就是RDB和AOF同时使用。RDB正常持久化，而AOF不在记录全量指令，而是记录每次RDB快照之后的增量AOF，这样Redis重启时就可以先加载RDB的内容，然后再重放AOF日志，效率大大提升。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说出redis中的数据删除策与略淘汰策略</p>
<p>说出主从复制的概念，工作流程以及场景问题及解决方案</p>
<p>说出哨兵的作用以及工作原理，以及如何启用哨兵</p>
<p>说出集群的架构设计，完成集群的搭建</p>
<p>说出缓存预热，雪崩，击穿，穿透的概念，能说出redis的相关监控指标</p>
<p>说出持久化策略的其中的一些细节</p>
<h1 id="第八章-缓存预热-缓存雪崩-缓存击穿-缓存穿透"><a href="#第八章-缓存预热-缓存雪崩-缓存击穿-缓存穿透" class="headerlink" title="第八章 缓存预热+缓存雪崩+缓存击穿+缓存穿透"></a>第八章 缓存预热+缓存雪崩+缓存击穿+缓存穿透</h1><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>统计热点数据(访问频率高的)提前存入缓存中(数据多 多服务并行写)</p>
<p>具体 nginx + lua 将访问量上报到消息队列(?)</p>
<p>​	要统计出来当前最新的实时的热数据是哪些，我们就得将商品详情页访问的请求对应的流量，日志，实时上报	到kafka中</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>发生: </p>
<p>​	redis主机挂了，Redis 全盘崩溃,</p>
<p>​	比如缓存中有大量数据同时过期</p>
<p>解决: </p>
<p><img src="/2022/10/09/all/5redis/image/74AC6492-9FD2-40C7-B534-CF44D126C49A.png" alt="img"></p>
<p>​	主从+哨兵 </p>
<p>​	集群</p>
<p>​	ehcache本地缓存 + Hystrix或者阿里sentinel限流&amp;降级</p>
<p>​	开启Redis持久化机制aof&#x2F;rdb，尽快恢复缓存集群</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>发生: </p>
<p>​	请求去查询一条记录，先redis后mysql发现都查询不到该条记录，</p>
<p>​	但是请求每次都会打到数据库上面去，导致后台数据库压力暴增，</p>
<p>​	这种现象我们称为缓存穿透，这个redis变成了一个摆设。。。。。。</p>
<p>​	简单说就是本来无一物，既不在Redis缓存中，也不在数据库中</p>
<p>危害:</p>
<p>​	第一次来查询后，一般我们有回写redis机制</p>
<p>​	第二次来查的时候redis就有了，偶尔出现穿透现象一般情况无关紧要</p>
<p>解决: </p>
<ol>
<li><p>方案1：空对象缓存或者缺省值</p>
<ol>
<li><p><img src="/2022/10/09/all/5redis/image/386472E6-67F3-46B2-A713-7872A2C5FCD1.png" alt="img">一般ok</p>
</li>
<li><p>but 黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。</p>
<p>可能会导致你的数据库由于压力过大而宕掉</p>
</li>
</ol>
</li>
<li><p>方案2：Google布隆过滤器Guava解决缓存穿透 只能单机使用</p>
<ol>
<li><p>Guava 中布隆过滤器的实现算是比较权威的，</p>
<p>所以实际项目中我们不需要手动实现一个布隆过滤器</p>
</li>
</ol>
</li>
<li><p>方案3：Redis布隆过滤器解决缓存穿透</p>
<ol>
<li><img src="/2022/10/09/all/5redis/image/565F1E03-01B7-4C67-8E39-991DE5824A07.png" alt="img"></li>
</ol>
</li>
<li><p><img src="/2022/10/09/all/5redis/image/0C61E513-B999-4121-9BB6-0F00E79841A0.png" alt="img"></p>
</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>发生: </p>
<p>​	大量的请求同时查询一个 key 时，</p>
<p>​	此时这个key正好失效了，就会导致大量的请求都打到数据库上面去</p>
<p>​	简单说就是热点key突然失效了，暴打mysql</p>
<p>危害: </p>
<p>​	会造成某一时刻数据库请求量过大，压力剧增。</p>
<p>解决</p>
<ol>
<li><p><img src="/2022/10/09/all/5redis/image/image-20220924104616500.png" alt="image-20220924104616500"></p>
</li>
<li><p>方案2：对于访问频繁的热点key，干脆就不设置过期时间</p>
</li>
<li><p>方案3：互斥独占锁防止击穿</p>
<ol>
<li><p>多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。</p>
<p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p>
<p><img src="/2022/10/09/all/5redis/image/A1B9DBB4-AC20-4F2A-BD92-B9DEE979A71D.png" alt="img"></p>
</li>
</ol>
</li>
</ol>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h1 id="第九章-Redis分布式锁"><a href="#第九章-Redis分布式锁" class="headerlink" title="第九章  Redis分布式锁"></a>第九章  Redis分布式锁</h1><h1 id="第十一-章-经典五种数据类型底层实现"><a href="#第十一-章-经典五种数据类型底层实现" class="headerlink" title="第十一 章 经典五种数据类型底层实现"></a>第十一 章 经典五种数据类型底层实现</h1><h2 id="dictEntry"><a href="#dictEntry" class="headerlink" title="dictEntry"></a>dictEntry</h2><p>启动流程到内部的表:</p>
<p><img src="/2022/10/09/all/5redis/image/image-20220830082938513.png" alt="image-20220830082938513"></p>
<h3 id="源码结构体及解析"><a href="#源码结构体及解析" class="headerlink" title="源码结构体及解析"></a>源码结构体及解析</h3><p><img src="/2022/10/09/all/5redis/image/image-20220830083148998.png" alt="image-20220830083148998"></p>
<blockquote>
<p>将dictEntry理解 &lt;String(sds),redisObject&gt; 不一定全对</p>
<p><strong>key 是字符串</strong>，但是 Redis 没有直接使用 C 的字符数组，而是<strong>存储在redis自定义的 SDS</strong>(简单动态字符串,simple dynimic string)中。</p>
<p><strong>value 既不是直接作为字符串存储，也不是直接存储在 SDS 中，而是存储在redisObject 中。</strong></p>
<p>set hello word为例，因为Redis是KV键值对的数据库，每个键值对都会有一个dictEntry(源码位置：dict.h)，</p>
<p>里面指向了key和value的指针，next 指向下一个 dictEntry。</p>
</blockquote>
<h2 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h2><blockquote>
<p><img src="/2022/10/09/all/5redis/image/image-20220830083356106.png" alt="image-20220830083356106"></p>
<p><img src="/2022/10/09/all/5redis/image/image-20220830091619828.png" alt="image-20220830091619828"></p>
</blockquote>
<p>后面的类型会加深对redisObject的理解</p>
<h2 id="Sring"><a href="#Sring" class="headerlink" title="Sring"></a>Sring</h2><h3 id="String的三种编码格式"><a href="#String的三种编码格式" class="headerlink" title="String的三种编码格式"></a>String的三种编码格式</h3><p><img src="/2022/10/09/all/5redis/image/image-20220830091820158.png" alt="image-20220830091820158"></p>
<h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><p>当字符串键值的内容可以用一个64位有符号整形来表示时，Redis会将键值转化为long型来进行存储，此时即对应 OBJ_ENCODING_INT 编码类型。内部的内存结构表示如下:</p>
<p><img src="/2022/10/09/all/5redis/image/EB49F5C1-B37B-4FDC-9DA7-AB4DCA56415D.png" alt="img"></p>
<p>Redis 启动时会预先建立 10000 个分别存储 0<del>9999 的 redisObject 变量作为共享对象，这就意味着如果 set字符串的键值在 0</del>10000 之间的话，则可以 直接指向共享对象 而不需要再建立新对象，此时键值不占空间！</p>
<p>set k1 123</p>
<p>set k2 123</p>
<p><img src="/2022/10/09/all/5redis/image/1BB8DD45-B847-4AE7-8AC4-0E9FD8300423.png" alt="img"></p>
<p>保存long 型(长整型)的64位(8个字节)有符号整数 	最多19位只能整数浮点数就是字符串值了</p>
<h4 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h4><p>对于长度小于 44的字符串，Redis 对键值采用OBJ_ENCODING_EMBSTR 方式，EMBSTR 顾名思义即：embedded string，表示嵌入式的String。从内存结构上来讲 即字符串 sds结构体与其对应的 redisObject 对象分配在同一块连续的内存空间，字符串sds嵌入在redisObject对象之中一样。</p>
<p><img src="/2022/10/09/all/5redis/image/EDAAEC35-A8BE-4C86-B377-B3EA8942FE19-1663990886033.png" alt="img"></p>
<p>代表 embstr 格式的 <strong>SDS</strong>(Simple Dynamic String 简单动态字符串),保存长度小于44字节的字符串</p>
<p><img src="/2022/10/09/all/5redis/image/FA1BFE29-23FC-4464-B86F-F1424A6BAE5E.png" alt="img"></p>
<p><img src="/2022/10/09/all/5redis/image/8D233473-B933-4927-AE25-D1EAE5C8BD1C.png" alt="img"></p>
<p>Redis中字符串的实现,SDS有多种结构（sds.h）：</p>
<p>sdshdr5、(2^5&#x3D;32byte)</p>
<p>sdshdr8、(2 ^ 8&#x3D;256byte)</p>
<p>sdshdr16、(2 ^ 16&#x3D;65536byte&#x3D;64KB)</p>
<p>sdshdr32、 (2 ^ 32byte&#x3D;4GB)</p>
<p>sdshdr64，2的64次方byte＝17179869184G用于存储不同的长度的字符串。</p>
<p>len 表示 SDS 的长度，使我们在获取字符串长度的时候可以在 O(1)情况下拿到，而不是像 C 那样需要遍历一遍字符串。</p>
<p>alloc 可以用来计算 free 就是字符串已经分配的未使用的空间，有了这个值就可以引入预分配空间的算法了，而不用去考虑内存分配的问题。</p>
<p>buf 表示字符串数组，真存数据的。</p>
<p><img src="/2022/10/09/all/5redis/image/8B511DCE-0900-4B1A-AA2E-2F9C58DE2474.png" alt="img"></p>
<h4 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h4><p>保存长度大于44字节的字符串</p>
<p>当字符串的键值为长度大于44的超长字符串时，Redis 则会将键值的内部编码方式改为OBJ_ENCODING_RAW格式，这与OBJ_ENCODING_EMBSTR编码方式的不同之处在于，此时动态字符串sds的内存与其依赖的redisObject的内存不再连续了</p>
<p><img src="/2022/10/09/all/5redis/image/01FA4358-0BAA-4217-ABCB-37E62D279136.png" alt="img"></p>
<h3 id="set-hello-观察以String为例的redisObject"><a href="#set-hello-观察以String为例的redisObject" class="headerlink" title="set hello 观察以String为例的redisObject"></a>set hello 观察以String为例的redisObject</h3><p>实际上<strong>五种常用的数据类型的任何一种，都是通过 redisObject 来存储</strong>的。</p>
<p><img src="/2022/10/09/all/5redis/image/image-20220830083721256.png" alt="image-20220830083721256"></p>
<p><img src="/2022/10/09/all/5redis/image/image-20220830083929582.png" alt="image-20220830083929582"></p>
<blockquote>
<p>debug指令可能出现异常</p>
<p>(error) ERR DEBUG command not allowed. If the enable-debug-command option is set to “local”, you can run it from a local connection, otherwise you need to set this option in the configuration file, and then restart the server  需要设置参数</p>
<p><img src="/2022/10/09/all/5redis/image/image-20220830090728586.png" alt="image-20220830090728586"></p>
<p>直接加一行</p>
</blockquote>
<p><img src="/2022/10/09/all/5redis/image/image-20220830091507400.png" alt="image-20220830091507400"></p>
<p>raw &gt;&#x3D; 44位</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/2022/10/09/all/5redis/image/ADAEABC8-FD48-4ED4-A9E0-DA96DBECC388.png" alt="img"></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>hash-max-ziplist-entries：使用压缩列表保存时哈希<strong>集合</strong>中的<strong>最大元素个数</strong>。</p>
<p>hash-max-ziplist-value：使用压缩列表保存哈希集合中<strong>单个元素的最大长度</strong>。</p>
<p>结论: </p>
<p>1.哈希对象保存的键值对数量小于 512 个；</p>
<p>2.所有的键值对的健和值的字符串长度都小于等于 64byte（一个英文字母一个字节） 时用ziplist，反之用hashtable</p>
<blockquote>
<p> ziplist升级到hashtable可以，反过来降级不可以</p>
<p>一旦从压缩列表转为了哈希表，Hash类型就会一直用哈希表进行保存而不会再转回压缩列表了。</p>
<p>在节省内存空间方面哈希表就没有压缩列表高效了。</p>
</blockquote>
<p><img src="/2022/10/09/all/5redis/image/81F47EF7-1EA4-499B-88FD-D349B6FD14A9-1663993362952.png" alt="img"></p>
<blockquote>
<p>后面会讲 回来再看</p>
</blockquote>
<h3 id="hash的两种编码格式"><a href="#hash的两种编码格式" class="headerlink" title="hash的两种编码格式"></a>hash的两种编码格式</h3><h4 id="ziplist-压缩列表"><a href="#ziplist-压缩列表" class="headerlink" title="ziplist(压缩列表)"></a>ziplist(压缩列表)</h4><p>Ziplist 压缩列表是一种紧凑编码格式，总体思想是多花时间来换取节约空间，即以部分读写性能为代价，来换取极高的内存空间利用率，</p>
<p>因此只会用于 <strong>字段个数少，且字段值也较小</strong> 的场景。压缩列表内存利用率极高的原因与其<strong>连续内存</strong>的特性是分不开的</p>
<blockquote>
<p> 想想我们的学过的一种GC垃圾回收机制：标记–压缩算法</p>
<p>当一个 hash对象 只包含少量键值对且每个键值对的键和值要么就是小整数要么就是长度比较短的字符串，那么它用 ziplist 作为底层实现</p>
<p>不懂 todo</p>
</blockquote>
<p>ziplist是一个经过特殊编码的<strong>双向链表</strong>，它不存储指向上一个链表节点和指向下一个链表节点的指针，而是<strong>存储上一个节点长度</strong>和<strong>当前节点长度</strong>，通过牺牲部分读写性能，来换取高效的内存空间利用率，节约内存，是一种时间换空间的思想。只用在字段个数少，字段值小的场景里面</p>
<h5 id="ZipList结构"><a href="#ZipList结构" class="headerlink" title="ZipList结构"></a>ZipList结构</h5><p><strong>本质上是字节数组</strong></p>
<p>zlend是一个单字节255(1111 1111)，用做ZipList的结尾标识符。见下：压缩列表结构：由zlbytes、zltail、zllen、entry、zlend这五部分组成</p>
<p><img src="/2022/10/09/all/5redis/image/38BF99E8-A930-409E-841A-25C06B1E4ACD.png" alt="img"></p>
<p><img src="/2022/10/09/all/5redis/image/8BC52DCB-C3A9-44B8-9320-A26F4B178145-1664008064781.png" alt="img"></p>
<p><img src="/2022/10/09/all/5redis/image/29538578-15BB-42D8-94D4-2252774918DF.png" alt="img"></p>
<h5 id="ziplistEntry结构"><a href="#ziplistEntry结构" class="headerlink" title="ziplistEntry结构"></a>ziplistEntry结构</h5><p><img src="/2022/10/09/all/5redis/image/C2FA349E-1B90-4ABC-BA12-7FBA1D362973.png" alt="img"></p>
<p>压缩列表zlentry节点结构：每个zlentry由前一个节点的长度、encoding和entry-data三部分组成</p>
<p><img src="/2022/10/09/all/5redis/image/5686B735-DBE9-4946-98C5-82ED3A01DE8B.png" alt="img"></p>
<p>前节点：(<strong>前节点占用的内存字节数</strong>)表示<strong>前1个zlentry的长度</strong>，prev_len有两种取值情况：1字节或5字节。<strong>取值1字节时</strong>，表示上一个entry的长度<strong>小于254字节</strong>。虽然1字节的值能表示的数值范围是0到255，但是压缩列表中zlend的取值默认是255，因此，就默认用<strong>255表示整个压缩列表的结束</strong>，其他表示长度的<strong>地方</strong>就不能再用255这个值了。所以，当上一个entry长度小于254字节时，prev_len取值为1字节，<strong>否则</strong>，就取值为5字节。</p>
<p>enncoding：记录节点的content保存数据的类型和长度。</p>
<p>content：保存实际数据内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span>   <span class="comment">// 压缩列表节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// prevrawlen是前一个节点的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//prevrawlensize是指prevrawlen的大小，有1字节和5字节两种</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize, prevrawlen;   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// len为当前节点长度 lensize为编码len所需的字节大小</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> lensize, len;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当前节点的header大小</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> headersize;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 节点的编码方式</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> encoding; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向节点的指针</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *p;  </span><br><span class="line"></span><br><span class="line">&#125; zlentry;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h5 id="压缩列表的遍历"><a href="#压缩列表的遍历" class="headerlink" title="压缩列表的遍历"></a>压缩列表的遍历</h5><p>通过指向表<strong>尾节点</strong>的位置指针<strong>p1</strong>, 减去节点的previous_entry_length(<strong>前一个结点的长度</strong>)，得到前一个节点起始地址的指针。如此循环，从表尾遍历到表头节点。从表尾向表头遍历操作就是使用这一原理实现的，只要我们拥有了一个指向某个节点起始地址的指针，那么通过这个指针以及这个节点的previous_entry_length属性程序就可以<strong>一直向前一个节点回溯</strong>，最终到达压缩列表的表头节点。</p>
<h5 id="存取情况"><a href="#存取情况" class="headerlink" title="存取情况"></a>存取情况</h5><p><img src="/2022/10/09/all/5redis/image/68B47FDA-7FE1-4792-ABA8-424E7EF7DA48.png" alt="img"></p>
<h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><p><img src="/2022/10/09/all/5redis/image/41B9E54E-4A98-4D8E-BEFF-A6CA7F756832.png" alt="img"></p>
<p>在 Redis 中，hashtable 被称为字典（dictionary），它是一个数组+链表的结构</p>
<h5 id="OBJ-ENCODING-HT源码分析"><a href="#OBJ-ENCODING-HT源码分析" class="headerlink" title="OBJ_ENCODING_HT源码分析"></a>OBJ_ENCODING_HT源码分析</h5><p>OBJ_ENCODING_HT 这种编码方式内部才是真正的哈希表结构，或称为字典结构，其可以实现O(1)复杂度的读写操作，因此效率很高。</p>
<p>在 Redis内部，从 OBJ_ENCODING_HT类型到底层真正的散列表数据结构是一层层嵌套下去的，组织关系见面图：</p>
<p><img src="/2022/10/09/all/5redis/image/87F8506C-6682-4F9F-9AC3-D5039E276E04.png" alt="img"><img src="/2022/10/09/all/5redis/image/24C4738B-48B8-4F0D-B11F-7486658730E0.png" alt="img"></p>
<p>源代码：dict.h</p>
<p><img src="/2022/10/09/all/5redis/image/73D0CD12-255D-4C62-A4DF-A07F5F5A3EEC.png" alt="img"></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="list的一种编码格式"><a href="#list的一种编码格式" class="headerlink" title="list的一种编码格式"></a>list的一种编码格式</h3><p>list用quicklist来存储，quicklist存储了一个双向链表，每个节点都是一个ziplist</p>
<p><img src="/2022/10/09/all/5redis/image/CD37E2D6-B6BA-4292-98E5-10BCDF5B3A83.png" alt="img"></p>
<p>在低版本的Redis中，list采用的底层数据结构是ziplist+linkedList；</p>
<p>高版本的Redis中底层数据结构是quicklist(它替换了ziplist+linkedList)，而quicklist也用到了ziplist</p>
<p>quicklist 实际上是 zipList 和 linkedList 的混合体，<strong>它将 linkedList按段切分，每一段使用 zipList 来紧凑存储</strong>，多个 zipList 之间使用双向指针串接起来。</p>
<p><img src="/2022/10/09/all/5redis/image/D56ECB2A-26EC-4482-96C9-30D4173027F2.png" alt="img"></p>
<p>案例:</p>
<p><img src="/2022/10/09/all/5redis/image/54456950-0EE2-4D53-9BBB-E3756FD3D4FC.png" alt="img"></p>
<p>(1) ziplist压缩配置：list-compress-depth 0</p>
<p>   表示一个quicklist两端不被压缩的节点个数。这里的<strong>节点是指quicklist双向链表</strong>的节点，而不是指ziplist里面的数据项个数</p>
<p>参数list-compress-depth的取值含义如下：两端各有x个端点不压缩</p>
<p>0: 是个特殊值，<strong>表示都不压缩</strong>。这是<strong>Redis的默认值</strong>。</p>
<p>1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。</p>
<p>2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。</p>
<p>3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。</p>
<p><strong>依此类推</strong>…</p>
<p>(2) ziplist中entry配置：list-max-ziplist-size -2</p>
<p>当取<strong>正值</strong>的时候，表示<strong>按照数据项个数来限定每个quicklist节点上的ziplist长度</strong>。比如，当这个参数配置成5的时候，表示<strong>每个quicklist节点的ziplist最多包含5个数据项</strong>。当取负值的时候，表示按照占用字节数来<strong>限定每个quicklist节点上的ziplist长度</strong>。这时，它只能取-1到-5这五个值，</p>
<p>每个值含义如下：</p>
<p>-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb &#x3D;&gt; 1024 bytes）</p>
<p>-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。</p>
<p>-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。</p>
<p>-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）</p>
<p>-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="/2022/10/09/all/5redis/image/CC16B97A-F516-4D80-B024-4622C6F78CBC.png" alt="img"></p>
<p><img src="/2022/10/09/all/5redis/image/898D6BF5-9E89-409E-8FE3-058C337F0BE2.png" alt="img"></p>
<p><img src="/2022/10/09/all/5redis/image/D744FD08-30F9-4C03-92B7-119F4267D039.png" alt="img"></p>
<p><img src="/2022/10/09/all/5redis/image/2310B211-7916-43B5-A554-A4DC2F2D7372.png" alt="img"></p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set的两种编码格式"><a href="#Set的两种编码格式" class="headerlink" title="Set的两种编码格式"></a>Set的两种编码格式</h3><p>intset</p>
<p>hashtable </p>
<p>案例</p>
<p>Redis用intset或hashtable存储set。<strong>如果元素都是整数类型，就用intset存储</strong>。</p>
<p><strong>如果不是整数类型</strong>，就用hashtable（<strong>数组+链表</strong>的存来储结构）。key就是元素的值，value为null。</p>
<p><img src="/2022/10/09/all/5redis/image/5357375F-894A-48C2-964E-1B81D1F205C1.png" alt="img"></p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="/2022/10/09/all/5redis/image/0F80D612-146A-4231-B12E-F867A7408CB0.png" alt="img"><img src="/2022/10/09/all/5redis/image/1CC0597D-31A6-4931-B64D-DB109564A0DF.png" alt="img"></p>
<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><h3 id="ZSet的两种编码格式"><a href="#ZSet的两种编码格式" class="headerlink" title="ZSet的两种编码格式"></a>ZSet的两种编码格式</h3><p>ziplist</p>
<p>skiplist</p>
<p><strong>案例:</strong> </p>
<p>当有序集合中包含的<strong>元素数量超过服务器属性</strong> server.zset_max_ziplist_entries 的值（默认值为 <strong>128</strong> ），</p>
<p>或者有序集合中<strong>新添加元素的 member 的长度</strong>大于服务器属性 server.zset_max_ziplist_value 的值（默认值为 <strong>64</strong> ）时，</p>
<p><strong>redis会使用跳跃表作为有序集合的底层实现</strong>。</p>
<p><strong>否则会使用ziplist作为有序集合的底层实现</strong></p>
<p><img src="/2022/10/09/all/5redis/image/CE887967-28C8-4BCE-A29A-11ABF3A30B57.png" alt="img"></p>
<p><img src="/2022/10/09/all/5redis/image/121F2016-B5F7-48E4-857E-84014570CFE0.png" alt="img"></p>
<h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="/2022/10/09/all/5redis/image/1EA9E751-2D08-4C60-9B98-40345B45C7DC.png" alt="img"></p>
<p><img src="/2022/10/09/all/5redis/image/A9DE3718-6EB2-4D07-9610-DA526D6A11BF.png" alt="img"></p>
<h2 id="skipList"><a href="#skipList" class="headerlink" title="skipList"></a>skipList</h2><p>跳表是可以实现二分查找的有序链表</p>
<p>skiplist是一种以空间换取时间的结构。</p>
<p>由于链表，无法进行二分查找，因此<strong>借鉴数据库索引的思想，提取出链表中关键节点（索引），先在关键节点上查找，再进入下层链表查找。</strong></p>
<p>提取多层关键节点，就形成了跳跃表</p>
<p><strong>总结来讲 跳表 &#x3D; 链表 + 多级索引</strong></p>
<p><img src="/2022/10/09/all/5redis/image/C031FAC2-0A7A-4DE2-B4B3-A9488A4F7482.png" alt="img"></p>
<p>  解决方法：升维，也叫空间换时间。</p>
<p><img src="/2022/10/09/all/5redis/image/D6DD22E1-22BF-41F7-93D0-247F5A141669.png" alt="img"></p>
<p><img src="/2022/10/09/all/5redis/image/3A3591F0-DD6E-44DF-AC4D-DF6D791B5772.png" alt="img"></p>
<p>跳表查询的时间复杂度分析</p>
<p>首先每一级索引我们提升了2倍的跨度，那就是减少了2倍的步数，所以是n&#x2F;2、n&#x2F;4、n&#x2F;8以此类推；</p>
<p>第 k 级索引结点的个数就是 n&#x2F;(2^k)；</p>
<p>假设索引有 h 级， 最高的索引有2个结点；n&#x2F;(2^h) &#x3D; 2, 从这个公式我们可以求得 h &#x3D; log2(N)-1；</p>
<p>所以最后得出跳表的时间复杂度是O(logN)</p>
<p>跳表查询的空间复杂度分析</p>
<p>首先原始链表长度为n</p>
<p>如果索引是每2个结点有一个索引结点，每层索引的结点数：n&#x2F;2, n&#x2F;4, n&#x2F;8 … , 8, 4, 2 以此类推；</p>
<p>或者所以是每3个结点有一个索引结点，每层索引的结点数：n&#x2F;3, n&#x2F;9, n&#x2F;27 … , 9, 3, 1 以此类推；</p>
<p>所以空间复杂度是O(n)；</p>
<p>跳表是一个最典型的空间换时间解决方案，而且只有在数据量较大的情况下才能体现出来优势。而且应该是读多写少的情况下才能使用，所以它的适用范围应该还是比较有限的</p>
<p>维护成本相对要高 - 新增或者删除时需要把所有索引都更新一遍；</p>
<p>最后在新增和删除的过程中的更新，时间复杂度也是O(log n)</p>
<h1 id="第十二章-Redis与MySQL数据双写一致性工程落地案例"><a href="#第十二章-Redis与MySQL数据双写一致性工程落地案例" class="headerlink" title="第十二章 Redis与MySQL数据双写一致性工程落地案例"></a>第十二章 Redis与MySQL数据双写一致性工程落地案例</h1><h2 id="1-canal"><a href="#1-canal" class="headerlink" title="1. canal"></a>1. canal</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Canal是基于MySQL变更日志增量订阅和消费的组件</p>
<p>canal [kə’næl]，中文翻译为 水道&#x2F;管道&#x2F;沟渠&#x2F;运河，主要用途是用于 MySQL 数据库增量日志数据的订阅、消费和解析，是阿里巴巴开发并开源的，采用Java语言开发；</p>
<p>历史背景是早期阿里巴巴因为杭州和美国双机房部署，存在跨机房数据同步的业务需求，实现方式主要是基于业务 trigger（触发器） 获取增量变更。从2010年开始，阿里巴巴逐步尝试采用解析数据库日志获取增量变更进行同步，由此衍生出了canal项目；</p>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><ol>
<li>数据库镜像</li>
<li>数据库实时备份</li>
<li>索引构建和实时维护(拆分异构索引、倒排索引等)</li>
<li>业务 cache 刷新</li>
<li>带业务逻辑的增量数据处理</li>
</ol>
<h2 id="2-相关面试"><a href="#2-相关面试" class="headerlink" title="2. 相关面试"></a>2. 相关面试</h2><h3 id="2-1-MySQL的主从复制"><a href="#2-1-MySQL的主从复制" class="headerlink" title="2.1 MySQL的主从复制"></a>2.1 MySQL的主从复制</h3><p><img src="/2022/10/09/all/5redis/image/5605B184-C635-4DE6-BC18-BE48030B0601.png" alt="img"></p>
<p>MySQL的主从复制将经过如下步骤：</p>
<p>1、当 master 主服务器上的数据发生改变时，则将其改变写入二进制事件日志文件中；</p>
<p>2、salve 从服务器会在一定时间间隔内对 master 主服务器上的二进制日志进行探测，探测其是否发生过改变，</p>
<p>如果探测到 master 主服务器的二进制事件日志发生了改变，则开始一个 I&#x2F;O Thread 请求 master 二进制事件日志；</p>
<p>3、同时 master 主服务器为每个 I&#x2F;O Thread 启动一个dump Thread，用于向其发送二进制事件日志；</p>
<p>4、slave 从服务器将接收到的二进制事件日志保存至自己本地的中继日志文件中；</p>
<p>5、salve 从服务器将启动 SQL Thread 从中继日志中读取二进制日志，在本地重放，使得其数据和主服务器保持一致；</p>
<p>6、最后 I&#x2F;O Thread 和 SQL Thread 将进入睡眠状态，等待下一次被唤醒；</p>
<h3 id="2-2-canal工作原理"><a href="#2-2-canal工作原理" class="headerlink" title="2.2 canal工作原理"></a>2.2 canal工作原理</h3><p>canal 工作原理</p>
<p>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议</p>
<p>MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</p>
<p>canal 解析 binary log 对象(原始为 byte 流)</p>
<p><img src="/2022/10/09/all/5redis/image/9AEAC489-53C4-48B1-AAB8-49E8CD9C0D93.png" alt="img"></p>
<h2 id="mysql-canal-redis双写一致性Coding"><a href="#mysql-canal-redis双写一致性Coding" class="headerlink" title="mysql-canal-redis双写一致性Coding"></a>mysql-canal-redis双写一致性Coding</h2><h1 id="第十三章-缓存双写一致性之更新策略探讨"><a href="#第十三章-缓存双写一致性之更新策略探讨" class="headerlink" title="第十三章 缓存双写一致性之更新策略探讨"></a>第十三章 缓存双写一致性之更新策略探讨</h1><p>缓存双写一致性，谈谈你的理解</p>
<p>如果redis中有数据 需要和数据库中的值相同</p>
<p>如果redis中无数据 数据库中的值要是最新值</p>
<p>缓存按照操作来分，有细分2种</p>
<p>​	只读缓存</p>
<p>​	读写缓存</p>
<p>​		同步直写策略：写缓存时也同步写数据库，缓存和数据库中的数据⼀致；</p>
<p>​		对于读写缓存来说，要想保证缓存和数据库中的数据⼀致，就要采⽤同步直写策略</p>
<p><strong>数据库和缓存一致性的几种更新策略</strong></p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>给缓存设置过期时间，是保证最终一致性的解决方案。</p>
<p>我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存，达到一致性，切记以mysql的数据库写入库为准。</p>
<p>上述方案和后续落地案例是调研后的主流+成熟的做法，但是考虑到各个公司业务系统的差距，</p>
<p>不是100%绝对正确，不保证绝对适配全部情况，请同学们自行酌情选择打法，合适自己的最好。</p>
<h2 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p> 1 先更新mysql的某商品的库存，当前商品的库存是100，更新为99个。</p>
<p> 2 先更新mysql修改为99成功，然后更新redis。</p>
<p> 3 此时假设异常出现，更新redis失败了，这导致mysql里面的库存是99而redis里面的还是100 。</p>
<p> 4 上述发生，会让数据库里面和缓存redis里面数据不一致，读到脏数据</p>
<h2 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>表示更新数据库可能失败</p>
<p>1 A线程先成功删除了redis里面的数据，然后去更新mysql，此时mysql正在更新中，还没有结束。（比如网络延时）</p>
<p>B突然出现要来读取缓存数据。</p>
<p>异常问题2: </p>
<p>2 此时redis里面的数据是空的，B线程来读取，先去读redis里数据(已经被A线程delete掉了)，此处出来2个问题：</p>
<p>2.1 B从mysql获得了旧值</p>
<p>​    B线程发现redis里没有(缓存缺失)马上去mysql里面读取，从数据库里面读取来的是旧值。</p>
<p>2.2 B会把获得的旧值写回redis </p>
<p>   获得旧值数据后返回前台并回写进redis(刚被A线程删除的旧数据有极大可能又被写回了)。</p>
<p>3</p>
<p>A线程更新完mysql，发现redis里面的缓存是脏数据，A线程直接懵逼了，o(╥﹏╥)o</p>
<p>两个并发操作，一个是更新操作，另一个是查询操作，A更新操作删除缓存后，B查询操作没有命中缓存，B先把老数据读出来后放到缓存中，然后A更新操作更新了数据库。</p>
<p>于是，在缓存中的数据还是老的数据，导致<strong>缓存中的数据是脏</strong>的，而且还一直这样脏下去了。</p>
<p>4 总结流程：</p>
<p>（1）请求A进行写操作，删除缓存后，工作正在进行中……A还么有彻底更新完</p>
<p>（2）请求B开工，查询redis发现缓存不存在</p>
<p>（3）请求B继续，去数据库查询得到了myslq中的旧值</p>
<p>（4）请求B将旧值写入redis缓存</p>
<p>（5）请求A将新值写入mysql数据库 </p>
<p>上述情况就会导致不一致的情形出现。</p>
<p>时间</p>
<p>线程A</p>
<p>线程B</p>
<p>出现的问题</p>
<p>t1</p>
<p>请求A进行写操作，删除缓存后，工作正在进行中……</p>
<p>t2</p>
<p>1 缓存中读取不到，立刻读mysql，由于A还没有对mysql更新完，读到的是旧值。</p>
<p>2 还把从mysql读取的旧值，写回了redis</p>
<p>1 A还更新完mysql，导致B读到了旧值</p>
<p>2 线程B遵守回写机制，把旧值写回redis，导致其它请求读取的还是旧值，A白干了。</p>
<p>t3</p>
<p>更新mysql数据库的值，over</p>
<p>redis是被B写回的旧值，</p>
<p>mysql是被A更新的新值。</p>
<p>出现了，数据不一致问题。</p>
<p><strong>总结</strong></p>
<p>先删除缓存，再更新数据库</p>
<p>如果数据库更新失败，导致B线程请求再次访问缓存时，发现redis里面没数据，缓存缺失，再去读取mysql时，从数据库中读取到旧值</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。</p>
<p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。</p>
<p>后面的线程进来发现已经有缓存了，就直接走缓存。</p>
<h4 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a><strong>延时双删</strong></h4><p><img src="/2022/10/09/all/5redis/image/1DEE5D6C-17D6-4F3C-A1D2-A936797E5694.png" alt="img"></p>
<h4 id="双删方案面试题"><a href="#双删方案面试题" class="headerlink" title="双删方案面试题"></a><strong>双删方案面试题</strong></h4><h5 id="这个删除该休眠多久呢"><a href="#这个删除该休眠多久呢" class="headerlink" title="这个删除该休眠多久呢"></a><strong>这个删除该休眠多久呢</strong></h5><p>线程Asleep的时间，就需要大于线程B读取数据再写入缓存的时间。</p>
<p>这个时间怎么确定呢？</p>
<p>在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，自行评估自己的项目的读数据业务逻辑的耗时，</p>
<p>以此为基础来进行估算。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上加百毫秒即可。</p>
<p>这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<h5 id="当前演示的效果是mysql单机，如果mysql主从读写分离架构如何？"><a href="#当前演示的效果是mysql单机，如果mysql主从读写分离架构如何？" class="headerlink" title="当前演示的效果是mysql单机，如果mysql主从读写分离架构如何？"></a>当前演示的效果是mysql单机，如果mysql主从读写分离架构如何？</h5><p>（1）请求A进行写操作，删除缓存</p>
<p>（2）请求A将数据写入数据库了，</p>
<p>（3）请求B查询缓存发现，缓存没有值</p>
<p>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</p>
<p>（5）请求B将旧值写入缓存</p>
<p>（6）数据库完成主从同步，从库变为新值 上述情形，就是数据不一致的原因。还是使用双删延时策略。</p>
<p>只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms</p>
<h5 id="这种同步淘汰策略，吞吐量降低怎么办？"><a href="#这种同步淘汰策略，吞吐量降低怎么办？" class="headerlink" title="这种同步淘汰策略，吞吐量降低怎么办？"></a>这种同步淘汰策略，吞吐量降低怎么办？</h5><p><img src="/2022/10/09/all/5redis/image/6CC74F9C-701F-487B-ACC4-ECF644D7B0C6.png" alt="img"></p>
<h2 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a><strong>问题</strong></h3><p>时间</p>
<p>线程A</p>
<p>线程B</p>
<p>出现的问题</p>
<p>t1</p>
<p>删除数据库中的值</p>
<p>t2</p>
<p>缓存中立刻命中，此时B读取的是缓存旧值。</p>
<p><strong>A还没有来得及删除缓存的值，导致B缓存命中读到旧值</strong>。</p>
<p>t3</p>
<p>更新缓存的数据，over</p>
<p>先更新数据库，再删除缓存</p>
<p><strong>假如缓存删除失败或者来不及，导致请求再次访问redis时缓存命中，读取到的是缓存旧值</strong></p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p><img src="/2022/10/09/all/5redis/image/61D6022A-9F18-4E20-B002-4F4695E51634.png" alt="img"></p>
<p>1 可以把要删除的缓存值或者是<strong>要更新的数据库值</strong>暂存到消息队列中（例如使用Kafka&#x2F;RabbitMQ等）。</p>
<p>2 当程序没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。</p>
<p>3 如果能够<strong>成功地删除或更新，我们就要把这些值从消息队列中去除</strong>，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了，否则还需要再次进行重试</p>
<p>4 如果重试超过的一定次数后还是没有成功，我们就需要向业务层发送报错信息了，通知运维人员。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="方案2和方案3用那个？利弊如何"><a href="#方案2和方案3用那个？利弊如何" class="headerlink" title="方案2和方案3用那个？利弊如何"></a>方案2和方案3用那个？利弊如何</h3><p>在大多数业务场景下，我们会把Redis作为只读缓存使用。假如定位是只读缓存来说，</p>
<p>理论上我们既可以先删除缓存值再更新数据库，也可以先更新数据库再删除缓存，但是没有完美方案，两害相衡趋其轻的原则</p>
<p>个人建议是，优先使用先更新数据库，再删除缓存的方案。理由如下：</p>
<p>1 先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力，严重导致打满mysql。</p>
<p>2 如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。</p>
<p> 多补充一句：如果使用先更新数据库，再删除缓存的方案</p>
<p>如果业务层要求必须读取一致性的数据，那么我们就需要在更新数据库时，先在Redis缓存客户端暂存并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。</p>
<p><img src="/2022/10/09/all/5redis/image/A7EFEACF-3536-41C1-B11B-10B887038E3E.png" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io">ggq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io/2022/10/09/all/5redis/">https://gouguoqiang.github.io/2022/10/09/all/5redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gouguoqiang.github.io" target="_blank">ggq</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/17/%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">排序算法</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/09/all/4spring/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ggq</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E6%97%A5%E5%B8%B8%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">redis日常基础使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-redis%E5%A4%9A%E7%BA%BF%E7%A8%8BVS%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">第三章 redis多线程VS单线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84-%E6%95%B4%E4%B8%AARedis%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9B"><span class="toc-number">2.1.</span> <span class="toc-text">Redis工作线程是单线程的,整个Redis来说，是多线程的；</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.2.</span> <span class="toc-text">单线程快的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%8A%E7%97%85"><span class="toc-number">2.3.</span> <span class="toc-text">单线程的弊病</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">默认单线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BB%8F%E5%85%B8%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E9%83%BD%E6%98%AF%E9%92%88%E5%AF%B9value-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E8%90%BD%E5%9C%B0%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">第五章 经典五种数据类型(都是针对value)介绍及落地应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-String"><span class="toc-number">3.1.</span> <span class="toc-text">1. String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Hash"><span class="toc-number">3.2.</span> <span class="toc-text">2. Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-List"><span class="toc-number">3.3.</span> <span class="toc-text">3. List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Set"><span class="toc-number">3.4.</span> <span class="toc-text">4. Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.1.</span> <span class="toc-text">4.1 常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.4.2.</span> <span class="toc-text">4.2 应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-sortedSet-Zset"><span class="toc-number">3.5.</span> <span class="toc-text">5. sortedSet(Zset)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1"><span class="toc-number">3.5.1.</span> <span class="toc-text">5.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.5.2.</span> <span class="toc-text">5.2 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98"><span class="toc-number">3.5.3.</span> <span class="toc-text">5.3 案例实战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-redis%E6%96%B0%E7%B1%BB%E5%9E%8Bbitmap-x2F-hyperloglgo-x2F-GEO"><span class="toc-number">4.</span> <span class="toc-text">第六章 redis新类型bitmap&#x2F;hyperloglgo&#x2F;GEO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%BF%E7%BA%A7%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BB%9F%E8%AE%A1%E7%BB%9F%E8%AE%A1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">亿级系统中常见的四种统计统计的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-BitMap"><span class="toc-number">4.2.</span> <span class="toc-text">1. BitMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.1 常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.2.2.</span> <span class="toc-text">1.2应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-HyperLogLog"><span class="toc-number">4.3.</span> <span class="toc-text">2. HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.1.</span> <span class="toc-text">2.1 常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">4.3.2.</span> <span class="toc-text">2.2应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-GEO"><span class="toc-number">4.4.</span> <span class="toc-text">3. GEO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-1"><span class="toc-number">4.4.1.</span> <span class="toc-text">3.1 常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.4.2.</span> <span class="toc-text">3.2应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.5.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83-%E7%AB%A0-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">第七 章 布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E5%AE%89%E8%A3%85%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">linux安装布隆过滤器的两种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.</span> <span class="toc-text">常用指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E9%AB%98%E7%BA%A7"><span class="toc-number">6.</span> <span class="toc-text">Redis高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">6.1.</span> <span class="toc-text">学习目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E4%B8%8E%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">6.2.</span> <span class="toc-text">1.数据删除与淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.1 过期数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-Redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">1.1.1 Redis中的数据特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E6%97%B6%E6%95%88%E6%80%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">1.1.2 时效性数据的存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">6.2.2.</span> <span class="toc-text">1.2 数据删除策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">1.2.1 数据删除策略的目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">1.2.2 定时删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">1.2.3 惰性删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="toc-number">6.2.2.4.</span> <span class="toc-text">1.2.4 定期删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%AF%B9%E6%AF%94"><span class="toc-number">6.2.2.5.</span> <span class="toc-text">1.2.5 删除策略对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%88%E9%80%90%E5%87%BA%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">6.2.3.</span> <span class="toc-text">1.3 数据淘汰策略（逐出算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%A6%82%E8%BF%B0"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">1.3.1 淘汰策略概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">1.3.2 策略配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">6.3.</span> <span class="toc-text">2.主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">6.3.1.</span> <span class="toc-text">2.1 主从复制简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">2.1.1 高可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A6%82%E5%BF%B5"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">2.1.2 主从复制概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.3.1.3.</span> <span class="toc-text">2.1.3 主从复制的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.2 主从复制工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">2.2.1 主从复制的工作流程（三个阶段）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-1-%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.3.2.1.1.</span> <span class="toc-text">2.2.1.1 阶段一：建立连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-2-%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">6.3.2.1.2.</span> <span class="toc-text">2.2.1.2 阶段二：数据同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-3-%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD"><span class="toc-number">6.3.2.1.3.</span> <span class="toc-text">2.2.1.3 阶段三：命令传播</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E6%B5%81%E7%A8%8B%E6%9B%B4%E6%96%B0-%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6-x2F-%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">2.2.2 流程更新(全量复制&#x2F;部分复制)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">6.3.2.3.</span> <span class="toc-text">2.2.3 心跳机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.3.</span> <span class="toc-text">2.3 主从复制常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E9%A2%91%E7%B9%81%E7%9A%84%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">2.3.1 频繁的全量复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E9%A2%91%E7%B9%81%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">2.3.2 频繁的网络中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">2.3.3 数据不一致</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">3.哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%93%A8%E5%85%B5%E7%AE%80%E4%BB%8B"><span class="toc-number">6.4.1.</span> <span class="toc-text">3.1 哨兵简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E5%93%A8%E5%85%B5%E6%A6%82%E5%BF%B5"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">3.1.1 哨兵概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E5%93%A8%E5%85%B5%E4%BD%9C%E7%94%A8"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">3.1.2 哨兵作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%90%AF%E7%94%A8%E5%93%A8%E5%85%B5"><span class="toc-number">6.4.2.</span> <span class="toc-text">3.2 启用哨兵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%93%A8%E5%85%B5%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.3.</span> <span class="toc-text">3.3 哨兵工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E7%9B%91%E6%8E%A7"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">3.3.1 监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E9%80%9A%E7%9F%A5"><span class="toc-number">6.4.3.2.</span> <span class="toc-text">3.3.2 通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">6.4.3.3.</span> <span class="toc-text">3.3.3 故障转移</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9B%86%E7%BE%A4cluster"><span class="toc-number">6.5.</span> <span class="toc-text">4.集群cluster</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%9B%86%E7%BE%A4%E7%AE%80%E4%BB%8B"><span class="toc-number">6.5.1.</span> <span class="toc-text">4.1 集群简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Cluster%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.5.2.</span> <span class="toc-text">4.2 Cluster集群结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Cluster%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E6%90%AD%E5%BB%BA"><span class="toc-number">6.5.3.</span> <span class="toc-text">4.3 Cluster集群结构搭建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">6.6.</span> <span class="toc-text">5.企业级解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">6.6.1.</span> <span class="toc-text">5.1 缓存预热</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">6.6.2.</span> <span class="toc-text">5.2 缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">6.6.3.</span> <span class="toc-text">5.3 缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">6.6.4.</span> <span class="toc-text">5.4 缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7"><span class="toc-number">6.6.5.</span> <span class="toc-text">5.5 性能指标监控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">6.7.</span> <span class="toc-text">6. 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%BF%AB%E7%85%A7%EF%BC%88RDB%EF%BC%89"><span class="toc-number">6.7.1.</span> <span class="toc-text">1.1 快照（RDB）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-AOF%E6%97%A5%E5%BF%97"><span class="toc-number">6.7.2.</span> <span class="toc-text">1.2 AOF日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-AOF%E9%87%8D%E5%86%99"><span class="toc-number">6.7.2.1.</span> <span class="toc-text">1.2.1 AOF重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-fsync"><span class="toc-number">6.7.2.2.</span> <span class="toc-text">1.2.2 fsync</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%8C%81%E4%B9%85%E5%8C%96%E9%80%89%E5%9C%A8%E4%BB%8E%E8%8A%82%E7%82%B9"><span class="toc-number">6.7.3.</span> <span class="toc-text">1.3 持久化选在从节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Redis4-0%E7%9A%84%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">6.7.4.</span> <span class="toc-text">1.4 Redis4.0的混合持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">7.</span> <span class="toc-text">第八章 缓存预热+缓存雪崩+缓存击穿+缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">7.1.</span> <span class="toc-text">缓存预热</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">7.2.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">7.3.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">7.4.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">7.4.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">第九章  Redis分布式锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80-%E7%AB%A0-%E7%BB%8F%E5%85%B8%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.</span> <span class="toc-text">第十一 章 经典五种数据类型底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dictEntry"><span class="toc-number">9.1.</span> <span class="toc-text">dictEntry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E8%A7%A3%E6%9E%90"><span class="toc-number">9.1.1.</span> <span class="toc-text">源码结构体及解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redisObject"><span class="toc-number">9.2.</span> <span class="toc-text">redisObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sring"><span class="toc-number">9.3.</span> <span class="toc-text">Sring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.3.1.</span> <span class="toc-text">String的三种编码格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int"><span class="toc-number">9.3.1.1.</span> <span class="toc-text">int</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#embstr"><span class="toc-number">9.3.1.2.</span> <span class="toc-text">embstr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raw"><span class="toc-number">9.3.1.3.</span> <span class="toc-text">raw</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-hello-%E8%A7%82%E5%AF%9F%E4%BB%A5String%E4%B8%BA%E4%BE%8B%E7%9A%84redisObject"><span class="toc-number">9.3.2.</span> <span class="toc-text">set hello 观察以String为例的redisObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">9.3.3.</span> <span class="toc-text">流程图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash"><span class="toc-number">9.4.</span> <span class="toc-text">Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">9.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.4.2.</span> <span class="toc-text">hash的两种编码格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ziplist-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">9.4.2.1.</span> <span class="toc-text">ziplist(压缩列表)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ZipList%E7%BB%93%E6%9E%84"><span class="toc-number">9.4.2.1.1.</span> <span class="toc-text">ZipList结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ziplistEntry%E7%BB%93%E6%9E%84"><span class="toc-number">9.4.2.1.2.</span> <span class="toc-text">ziplistEntry结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">9.4.2.1.3.</span> <span class="toc-text">压缩列表的遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E6%83%85%E5%86%B5"><span class="toc-number">9.4.2.1.4.</span> <span class="toc-text">存取情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashtable"><span class="toc-number">9.4.2.2.</span> <span class="toc-text">hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#OBJ-ENCODING-HT%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">9.4.2.2.1.</span> <span class="toc-text">OBJ_ENCODING_HT源码分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">9.5.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E7%9A%84%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.5.1.</span> <span class="toc-text">list的一种编码格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">9.5.2.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">9.6.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.6.1.</span> <span class="toc-text">Set的两种编码格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">9.6.2.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zset"><span class="toc-number">9.7.</span> <span class="toc-text">Zset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZSet%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.7.1.</span> <span class="toc-text">ZSet的两种编码格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2"><span class="toc-number">9.7.2.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#skipList"><span class="toc-number">9.8.</span> <span class="toc-text">skipList</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-Redis%E4%B8%8EMySQL%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E5%B7%A5%E7%A8%8B%E8%90%BD%E5%9C%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">10.</span> <span class="toc-text">第十二章 Redis与MySQL数据双写一致性工程落地案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-canal"><span class="toc-number">10.1.</span> <span class="toc-text">1. canal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">10.1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">10.1.2.</span> <span class="toc-text">能干嘛</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95"><span class="toc-number">10.2.</span> <span class="toc-text">2. 相关面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">10.2.1.</span> <span class="toc-text">2.1 MySQL的主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-canal%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">10.2.2.</span> <span class="toc-text">2.2 canal工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql-canal-redis%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7Coding"><span class="toc-number">10.3.</span> <span class="toc-text">mysql-canal-redis双写一致性Coding</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E4%B9%8B%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E6%8E%A2%E8%AE%A8"><span class="toc-number">11.</span> <span class="toc-text">第十三章 缓存双写一致性之更新策略探讨</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-number">11.1.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="toc-number">11.2.</span> <span class="toc-text">先更新数据库，再更新缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">11.2.1.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">11.3.</span> <span class="toc-text">先删除缓存，再更新数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1"><span class="toc-number">11.3.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">11.3.2.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0"><span class="toc-number">11.3.2.1.</span> <span class="toc-text">延时双删</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%88%A0%E6%96%B9%E6%A1%88%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">11.3.2.2.</span> <span class="toc-text">双删方案面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E5%88%A0%E9%99%A4%E8%AF%A5%E4%BC%91%E7%9C%A0%E5%A4%9A%E4%B9%85%E5%91%A2"><span class="toc-number">11.3.2.2.1.</span> <span class="toc-text">这个删除该休眠多久呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E6%BC%94%E7%A4%BA%E7%9A%84%E6%95%88%E6%9E%9C%E6%98%AFmysql%E5%8D%95%E6%9C%BA%EF%BC%8C%E5%A6%82%E6%9E%9Cmysql%E4%B8%BB%E4%BB%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">11.3.2.2.2.</span> <span class="toc-text">当前演示的效果是mysql单机，如果mysql主从读写分离架构如何？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%99%E7%A7%8D%E5%90%8C%E6%AD%A5%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%8C%E5%90%9E%E5%90%90%E9%87%8F%E9%99%8D%E4%BD%8E%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">11.3.2.2.3.</span> <span class="toc-text">这种同步淘汰策略，吞吐量降低怎么办？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="toc-number">11.4.</span> <span class="toc-text">先更新数据库，再删除缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-2"><span class="toc-number">11.4.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">11.4.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">11.5.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%882%E5%92%8C%E6%96%B9%E6%A1%883%E7%94%A8%E9%82%A3%E4%B8%AA%EF%BC%9F%E5%88%A9%E5%BC%8A%E5%A6%82%E4%BD%95"><span class="toc-number">11.5.1.</span> <span class="toc-text">方案2和方案3用那个？利弊如何</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/17/beibao/" title="beibao"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="beibao"/></a><div class="content"><a class="title" href="/2022/10/17/beibao/" title="beibao">beibao</a><time datetime="2022-10-17T09:55:43.000Z" title="发表于 2022-10-17 17:55:43">2022-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/17/beibao/beibao/" title="beibao"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="beibao"/></a><div class="content"><a class="title" href="/2022/10/17/beibao/beibao/" title="beibao">beibao</a><time datetime="2022-10-17T09:55:43.000Z" title="发表于 2022-10-17 17:55:43">2022-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/17/%E7%AE%97%E6%B3%95/" title="排序算法"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序算法"/></a><div class="content"><a class="title" href="/2022/10/17/%E7%AE%97%E6%B3%95/" title="排序算法">排序算法</a><time datetime="2022-10-17T08:09:45.000Z" title="发表于 2022-10-17 16:09:45">2022-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/09/all/5redis/" title="redis"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis"/></a><div class="content"><a class="title" href="/2022/10/09/all/5redis/" title="redis">redis</a><time datetime="2022-10-09T03:36:23.000Z" title="发表于 2022-10-09 11:36:23">2022-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/09/all/4spring/" title="Spring"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring"/></a><div class="content"><a class="title" href="/2022/10/09/all/4spring/" title="Spring">Spring</a><time datetime="2022-10-09T03:36:23.000Z" title="发表于 2022-10-09 11:36:23">2022-10-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By ggq</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>