<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ggq | ggq</title><meta name="author" content="ggq"><meta name="copyright" content="ggq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="title: JUCtags:  多线程categories: 多线程keywords:description: JUC总结。date: 2022-9-01 11:51:56  使用线程线程常用方法1.Thread.currentThread() 类方法  获得当前进程， Java中任何一段代码都是执行在某个线程中的，执行当前代码的线程就是当前线程 ，返回的是在代码实际运行时候的线程 2.thre">
<meta property="og:type" content="article">
<meta property="og:title" content="ggq">
<meta property="og:url" content="https://gouguoqiang.github.io/2022/10/09/8JUC/index.html">
<meta property="og:site_name" content="ggq">
<meta property="og:description" content="title: JUCtags:  多线程categories: 多线程keywords:description: JUC总结。date: 2022-9-01 11:51:56  使用线程线程常用方法1.Thread.currentThread() 类方法  获得当前进程， Java中任何一段代码都是执行在某个线程中的，执行当前代码的线程就是当前线程 ，返回的是在代码实际运行时候的线程 2.thre">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-09T14:12:36.052Z">
<meta property="article:modified_time" content="2023-02-24T14:08:00.088Z">
<meta property="article:author" content="ggq">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://gouguoqiang.github.io/2022/10/09/8JUC/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ggq',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-24 22:08:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ggq</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-09T14:12:36.052Z" title="发表于 2022-10-09 22:12:36">2022-10-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-24T14:08:00.088Z" title="更新于 2023-02-24 22:08:00">2023-02-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>title: JUC<br>tags:</p>
<ul>
<li>多线程<br>categories:</li>
<li>多线程<br>keywords:<br>description: JUC总结。<br>date: 2022-9-01 11:51:56</li>
</ul>
<h1 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h1><h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><p>1.Thread.currentThread() 类方法  获得当前进程， Java中任何一段代码都是执行在某个线程中的，执行当前代码的线程就是当前线程 ，返回的是在代码实际运行时候的线程</p>
<p>2.thread.setName(线程名称） 设置线程名称 对象方法<br>thread.getName() 返回线程名称<br>通过设置线程名称有助于程序调试，提高可读性</p>
<p>3.thread.isAlive() 判断线程是否处于活动状态 活动状态就是线程以启动且尚未终止</p>
<p>4.Thread.sleep(millis) 让当前线程休眠指定的毫秒数（currentThread返回的线程）</p>
<p>5.thread.getId()可以活的线程的唯一标识，某个编号的现成运行结束后，该编号可能被后续创建的线程使用，重启JVM后同一个线程的编号可能不一样</p>
<p>6.Thread.yield()方法的作用是放弃当前的CPU资源</p>
<p>7.thread.setPriority(num) ;设置线程的优先级<br>Java的线程优先级取值范围是1~10 如果超出这个范围会抛出异常<br>8.illegalArgumentException(非法参数异常）<br>线程优先具有继承性，在线程A创建了线程B 则B线程的优先级与A线程是一样的</p>
<p>9.thread.interrupt() &#x2F;&#x2F;仅是给线程标记中断 线程有thread.isInterrupted()方法，该方法返回线程的中断标志 true or false</p>
<p>10.thread.setDaemon()设置守护线程 守护线程是为其他线程提供服务的线程，如GC就是一个典型的守护线程，守护线程不能单独运行，当JVM中没有其他用户线程，只有守护线程，守护线程会自动销毁，JVM会退出 设置守护线程应该在线程启动之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"> 		<span class="type">SubDaemonThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubDaemonThread</span>();</span><br><span class="line"> 		thread.setDaemon(<span class="literal">true</span>); <span class="comment">//设置守护线程的代码应该在线程启动之前否则会报非法线程状态异常</span></span><br><span class="line"> 		thread.start();</span><br><span class="line"> 		<span class="comment">//当main线程结束，守护线程thread也销毁了</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11.Thread.state 枚举类型可通过getState()方法获得</p>
<h2 id="Java中的线程的生命周期"><a href="#Java中的线程的生命周期" class="headerlink" title="Java中的线程的生命周期"></a>Java中的线程的生命周期</h2><p>1 NEW新建状态 在调用start（）启动之前的状态<br>2 RUNNABLE 可运行状态 包含READY和RUNNING yield方法将RUNNABLE转为READY<br>3 BLOCKED 线程发起阻塞的IO操作或者申请由其他线程占用的独占资源 转为阻塞<br>满足条件转换为RUNNABLE<br>4WAITING 等待状态 线程执行了object.wait()(可以使执行当前代码的线程等待，暂停执行，直到接到通知或被中断为止，只能由锁对象调用，调用wait（）方法当前线程会释放锁),thread.join方法（挂起调用线程的执行，直到被调用的对象完成他的执行，T1，T2，T3三个线程怎么保证按一定顺序执行， 按顺序try join 例如1-2-3 则在2中try T1.join,3中try T2.join）然后依次（代码）启动三个线程） 会把看成转为WAITING等待状态，执行object.notify() 方法 或者加入的线程执行完毕，当前线程都会转换为RUNNABLE状态<br>5TIMED_WAITING状态，与WAITING类似 区别在于不会无限等待 如果线程没有在指定的时间范围内完成期望的操作，该线程自动转化为RUNNABLE 如sleep(long)<br>wait(long)</p>
<p>6TERMINATED 终止状态 线程结束处于终止状态 </p>
<h2 id="基础线程机制"><a href="#基础线程机制" class="headerlink" title="基础线程机制"></a>基础线程机制</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor：</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="多线程二"><a href="#多线程二" class="headerlink" title="多线程二"></a>多线程二</h1><p>CPU与磁盘IO速度有差异</p>
<p>多线程时分复用减少CPU空闲</p>
<h2 id="提高效率的方式："><a href="#提高效率的方式：" class="headerlink" title="提高效率的方式："></a>提高效率的方式：</h2><p>（1）CPU增加了缓存<br>（2）操作系统增加了进程，线程以分时复用CPU 进而均衡CPU 与IO设备的速度差异</p>
<p>Java采用抢占式线程调度：如果一个线程申请IO 或者申请一个被其他线程占用的资源 就会进入阻塞状态 让出CPU 待准备完成OS会把这个休眠的线程唤醒，唤醒后就有机会重新获得CPU使用权<br>（3）编译程序优化指令顺序</p>
<p>可见性：工作区和共享区数据更新应该立刻能被看到<br>原子性：该操作要么已经执行完成要么尚未发生，其他线程不能得到操作的中间结果<br>有序性：重排序可能会导致多线程程序出现非预期操作</p>
<p>（重排序）是对内存访问有序操作的一种优化 ：1 指令重排序 ：主要是由JIT编译器，处理器引起的，指程序顺序与执行顺序不一致</p>
<h3 id="2存储子系统重排序："><a href="#2存储子系统重排序：" class="headerlink" title="2存储子系统重排序："></a>2存储子系统重排序：</h3><p>由高速缓存（是CPU中为了匹配与主内存处理速度不匹配而舍设计一个高速缓存），写缓冲器（用来提高高速缓存操作的效率）引起的，感知顺序与执行顺序不一致<br>        重排序要保证单线程程序的正确性（貌似串行语义） 所以有数据依赖关系的指令不会重排<br>        如果两个指令（操作）访问同一个变量，其中一个有写操作这两个指令就存在数据依赖关系</p>
<h2 id="volatile-synchronize"><a href="#volatile-synchronize" class="headerlink" title="volatile  synchronize"></a>volatile  synchronize</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile 修饰变量关键字可以保证可见性与有序性<br>（1）当对volatile变量执行写操作后JMM会把工作内存中的最新变量值强行刷新到主内存，写操作会导致其他线程里的缓存无效（CPU嗅探总线，主存中更改的数据地址与自己缓存对比，若一致则失效）<br>（2） 防止指令重排 在volatile前后加上内存屏障 （各种屏障都是保证同步，简单来说在屏障之后的写操作必须等待屏障之前的写操作完成才可以执行，读操作则不受影响）<br>缺点不具有原子性<br>volatile的实现是轻量级的 性能优于 synchronized </p>
<h3 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h3><p>1 synchronized 隐性锁 依赖monitor<br>2 每个对象会与一个monitor相关联<br>  （1）当监视器被占用时，就会处于锁定状态，监视器的获得过程是排他的。如果某线程已经占用了监视器，则其他线程会进入阻塞状态等待锁的释放<br>  （2）执行完成退出监视器<br>修饰实例方法 修饰类方法 修饰代码块 （注意锁粒度）</p>
<h2 id="同步器AQS"><a href="#同步器AQS" class="headerlink" title="同步器AQS"></a>同步器AQS</h2><p>底层CAS（抽象队列同步器）定义了一套多线程访问共享资源的同步器框架<br>利用CLH队列锁实现 将获取不到线程的进程放入</p>
<h2 id="JMM（Java内存模型"><a href="#JMM（Java内存模型" class="headerlink" title="JMM（Java内存模型)"></a>JMM（Java内存模型)</h2><p>JVM中的共享数据可能被分配到CPU中的寄存器中，主内存RAM中<br>若分配到寄存器中，每个CPU都有自己的 一个CPU不能读取其他CPU上的内容，如果两个线程分别运行在不同CPU上，无法看到数据的变化</p>
<p>CPU不直接从主存读取数据，先把RAM中数据读到Cache缓存中再把Cache的数据读到寄存器中，CPU中线程对数据更新，可能只是更新到写缓冲器，还没有到达Cache更不用说主存 分配到主存中  运行在另一个CPU中的线程无法看到共享数据的更新</p>
<p>CPU具有缓存同步 共享数据的更新必须被写入cache 这个过程就是冲刷处理缓存</p>
<p>JMM对这些进行规定 ：每个线程之间的共享数据都存储在主内存中<br>        每个线程都有一个私有的工作内存（是一个抽象的概念，他涵盖寄存器，写缓冲器，其他硬件的优化）<br>        每个线程从主内存中把数据读取到本地工作内存中，在工作内存中保存共享数据的副本，工作内存仅对当前线程可见</p>
<p>程序、进程、线程的理解</p>
<p>1、程序(programm)<br>概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</p>
<p>2、进程(process)<br>概念：程序的一次执行过程，或是正在运行的一个程序。<br>说明：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</p>
<p>3、线程(thread)<br>概念：进程可进一步细化为线程，是一个程序内部的一条执行路径。<br>说明：线程作为CPU调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc)，线程切换的开销小。</p>
<p>进程可以细化为多个线程。<br>每个线程，拥有自己独立的：栈、程序计数器<br>多个线程，共享同一个进程中的结构：方法区、堆。</p>
<h1 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h1><h2 id="单核CPU与多核CPU的理解"><a href="#单核CPU与多核CPU的理解" class="headerlink" title="单核CPU与多核CPU的理解"></a>单核CPU与多核CPU的理解</h2><ul>
<li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费。）但是因为CPU时间单元特别短，因此感觉不出来。</li>
<li>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li>
<li>一个Java应用程序java.exe，其实至少三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</li>
</ul>
<h2 id="并行与并发的理解"><a href="#并行与并发的理解" class="headerlink" title="并行与并发的理解"></a>并行与并发的理解</h2><p>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。<br>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事</p>
<h3 id="Runnable接口构造线程源码"><a href="#Runnable接口构造线程源码" class="headerlink" title="Runnable接口构造线程源码"></a>Runnable接口构造线程源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="comment">/*下面是Thread类的部分源码*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.用Runnable接口创建线程时会进入这个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">        init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.接着调用这个方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize)</span> &#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.再调用这个方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.addUnstarted();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.group = g;</span><br><span class="line">        <span class="built_in">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="built_in">this</span>.priority = parent.getPriority();</span><br><span class="line">        <span class="keyword">if</span> (security == <span class="literal">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">            <span class="built_in">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">        <span class="built_in">this</span>.inheritedAccessControlContext =</span><br><span class="line">                acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line">        <span class="comment">//4.最后在这里将Runnable接口(target)赋值给Thread自己的target成员属性     </span></span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        setPriority(priority);</span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果你是实现了runnable接口，那么在上面的代码中target便不会为null，那么最终就会通过重写的</span></span><br><span class="line"><span class="comment">规则去调用真正实现了Runnable接口(你之前传进来的那个Runnable接口实现类)的类里的run方法*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>1、多线程的设计之中，使用了代理设计模式的结构，用户自定义的线程主体只是负责项目核心功能的实现，而所有的辅助实现全部交由Thread类来处理。<br>2、在进行Thread启动多线程的时候调用的是start()方法，而后找到的是run()方法，但通过Thread类的构造方法传递了一个Runnable接口对象的时候，那么该接口对象将被Thread类中的target属性所保存，在start()方法执行的时候会调用Thread类中的run()方法。而这个run()方法去调用实现了Runnable接口的那个类所重写过run()方法，进而执行相应的逻辑。多线程开发的本质实质上是在于多个线程可以进行同一资源的抢占，那么Thread主要描述的是线程，而资源的描述是通过Runnable完成的。如下图所示：</p>
<h3 id="Thread类构造线程源码"><a href="#Thread类构造线程源码" class="headerlink" title="Thread类构造线程源码"></a>Thread类构造线程源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(); <span class="comment">//这个构造函数会默认调用Super();也就是Thread类的无参构造</span></span><br><span class="line">JAVA</span><br><span class="line"><span class="comment">//代码从上往下顺序执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">()</span> &#123;</span><br><span class="line">        init(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize)</span> &#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.addUnstarted();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.group = g;</span><br><span class="line">        <span class="built_in">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="built_in">this</span>.priority = parent.getPriority();</span><br><span class="line">        <span class="keyword">if</span> (security == <span class="literal">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">            <span class="built_in">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">        <span class="built_in">this</span>.inheritedAccessControlContext =</span><br><span class="line">                acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        setPriority(priority);</span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*由于这里是通过继承Thread类来实现的线程，那么target这个东西就是Null。但是因为你继承</span></span><br><span class="line"><span class="comment">了Runnable接口并且重写了run()，所以最终还是调用子类的run()*/</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="最直观的代码描述"><a href="#最直观的代码描述" class="headerlink" title="最直观的代码描述"></a>最直观的代码描述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;：卖票，票号为：&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line">        <span class="type">Window</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line">        <span class="type">Window</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">JAVA</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:卖票，票号为：&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window1</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、继承Thread类的方式，new了三个Thread，实际上是有300张票。</p>
<p>2、实现Runnable接口的方式，new了三个Thread，实际上是有100张票。</p>
<p>3、也就是说实现Runnable接口的线程中，成员属性是所有线程共有的。但是继承Thread类的线程中，成员属性是各个线程独有的，其它线程看不到，除非采用static的方式才能使各个线程都能看到。</p>
<p>4、就像上面说的Runnable相当于资源，Thread才是线程。用Runnable创建线程时，new了多个Thread，但是传进去的参数都是同一个Runnable（资源）。用Thread创建线程时，就直接new了多个线程，每个线程都有自己的Runnable（资源）。在Thread源码中就是用target变量（这是一个Runnable类型的变量）来表示这个资源。</p>
<p>5、同时因为这两个的区别，在并发编程中，继承了Thread的子类在进行线程同步时不能将成员变量当做锁，因为多个线程拿到的不是同一把锁，不过用static变量可以解决这个问题。而实现了Runnable接口的类在进行线程同步时没有这个问题。</p>
<h1 id="策略模式在Thread和Runnable中的应用"><a href="#策略模式在Thread和Runnable中的应用" class="headerlink" title="策略模式在Thread和Runnable中的应用"></a>策略模式在Thread和Runnable中的应用</h1><p>Runnable接口最重要的方法—–run方法，使用了<strong>策略者模式</strong>将执行的逻辑(run方法)和程序的执行单元(start0方法)分离出来，使用户可以定义自己的程序处理逻辑，更符合面向对象的思想。</p>
<h1 id="Thread的构造方法"><a href="#Thread的构造方法" class="headerlink" title="Thread的构造方法"></a>Thread的构造方法</h1><ul>
<li>创建线程对象Thread，<code>默认有一个线程名，以Thread-开头，从0开始计数</code>，如“Thread-0、Thread-1、Thread-2 …”</li>
<li>如果没有传递Runnable或者没有覆写Thread的run方法，<code>该Thread不会调用任何方法</code></li>
<li>如果传递Runnable接口的实例或者覆写run方法，则<code>会执行该方法的逻辑单元</code>（逻辑代码）</li>
<li>如果构造线程对象时，未传入ThreadGroup，<code>Thread会默认获取父线程的ThreadGroup作为该线程的ThreadGroup</code>，此时子线程和父线程会在同一个ThreadGroup中</li>
<li>stackSize可以<code>提高线程栈的深度</code>，放更多栈帧，但是会<code>减少能创建的线程数目</code></li>
<li>stackSize默认是0，<code>如果是0，代表着被忽略，该参数会被JNI函数调用</code>，但是注意某些平台可能会失效，<code>可以通过“-Xss10m”设置</code></li>
</ul>
<p>具体的介绍可以看Java的API文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="comment">/*下面是Thread 的部分源码*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">    init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    init(<span class="literal">null</span>, <span class="literal">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">		↓ ↓	↓	</span><br><span class="line">         ↓ ↓	</span><br><span class="line">          ↓	</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize)</span> &#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">		↓ ↓	↓	</span><br><span class="line">         ↓ ↓	</span><br><span class="line">          ↓	</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">    <span class="comment">//中间源码省略</span></span><br><span class="line">    <span class="built_in">this</span>.target = target;<span class="comment">//①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* What will be run. */</span></span><br><span class="line"><span class="keyword">private</span> Runnable target; <span class="comment">//Thread类中的target属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123; <span class="comment">//②</span></span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>源码标记解读：</p>
<p>1、如果Thread类的构造方法传递了一个Runnable接口对象</p>
<p>①那么该接口对象将被Thread类中的target属性所保存。</p>
<p>②在start()方法执行的时候会调用Thread类中的run()方法。因为target不为null， target.run()就去调用实现Runnable接口的子类重写的run()。</p>
<p>2、如果Thread类的构造方传没传Runnable接口对象</p>
<p>①Thread类中的target属性保存的就是null。</p>
<p>②在start()方法执行的时候会调用Thread类中的run()方法。因为target为null，只能去调用继承Thread的子类所重写的run()。</p>
</blockquote>
<p>JVM一旦启动，虚拟机栈的大小已经确定了。但是如果你创建Thread的时候传了stackSize（该线程占用的stack大小），该参数会被JNI函数去使用。如果没传这个参数，就默认为0，表示忽略这个参数。注：stackSize在有一些平台上是无效的。</p>
<h1 id="start-源码"><a href="#start-源码" class="headerlink" title="start()源码"></a>start()源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();<span class="comment">//①</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>源码标记解读：</p>
<p>①当多次调用start()，会抛出throw new IllegalThreadStateException()异常。也就是每一个线程类的对象只允许启动一次，如果重复启动则就抛出此异常。</p>
</blockquote>
<h2 id="为什么线程的启动不直接使用run-而必须使用start-呢"><a href="#为什么线程的启动不直接使用run-而必须使用start-呢" class="headerlink" title="为什么线程的启动不直接使用run()而必须使用start()呢?"></a>为什么线程的启动不直接使用run()而必须使用start()呢?</h2><p>1、如果直接调用run()方法，相当于就是简单的调用一个普通方法。</p>
<p>2、run()的调用是在start0()这个Native C++方法里调用的</p>
<h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态，这几个状态在Java源码中用枚举来表示。</p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示。</p>
<blockquote>
<p>图中 wait到 runnable状态的转换中，<code>join</code>实际上是<code>Thread</code>类的方法，但这里写成了<code>Object</code>。</p>
</blockquote>
<p>1、由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<p>2、操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
<p>3、调用sleep()方法，会进入Blocked状态。sleep()结束之后，Blocked状态首先回到的是Runnable状态中的Ready（也就是可运行状态，但并未运行）。只有拿到了cpu的时间片才会进入Runnable中的Running状态。</p>
<h1 id="一个Java程序有哪些线程？"><a href="#一个Java程序有哪些线程？" class="headerlink" title="一个Java程序有哪些线程？"></a>一个Java程序有哪些线程？</h1><p>1、当你调用一个线程start()方法的时候，此时至少有两个线程，一个是调用你的线程，还有一个是被你创建出来的线程。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面就是一个调用你的线程（main线程），一个被你创建出来的线程（t1，名字可能是Thread-0）</p>
<p>2、当JVM启动后，实际有多个线程，但是至少有一个非守护线程（比如main线程）。</p>
<p><a target="_blank" rel="noopener" href="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/First_stage/0007.png"><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/First_stage/0007.png" alt="img"></a></p>
<ul>
<li>Finalizer：GC守护线程</li>
<li>RMI：Java自带的远程方法调用（秋招面试，有个面试官问过）</li>
<li>Monitor ：是一个守护线程，负责监听一些操作，也在main线程组中</li>
<li>其它：我用的是IDEA，其它的应该是IDEA的线程，比如鼠标监听啥的。</li>
</ul>
<h2 id="守护线程用处-发送心跳"><a href="#守护线程用处-发送心跳" class="headerlink" title="守护线程用处(发送心跳)"></a>守护线程用处(发送心跳)</h2><p>A和B之间有一条网络连接，可以用守护线程来进行发送心跳，一旦A和B连接断开，非守护线程就结束了，守护线程（也就是心跳没有必要再发送了）也刚好断开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">        Thread innerThread = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    System.out.println(&quot;Do some thing for health check.&quot;);</span><br><span class="line">                    Thread.sleep(1_000);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      //  innerThread.setDaemon(true);</span><br><span class="line">        innerThread.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1_000);</span><br><span class="line">            System.out.println(&quot;T thread finish done.&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //t.setDaemon(true);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">设置该线程为守护线程必须在启动它之前。如果t.start()之后，再t.setDaemon(true);</span><br><span class="line">会抛出IllegalThreadStateException</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果：</p>
<p>Do some thing for health check.<br>Do some thing for health check.<br>T thread finish done. &#x2F;&#x2F;此时main线程已经结束，但是由于innerThread还在发送心跳，应用不会关闭<br>Do some thing for health check.<br>Do some thing for health check.<br>Do some thing for health check.<br>Do some thing for health check.</p>
</blockquote>
<blockquote>
<p>守护线程还有其它很多用处，在后面的文章里还会有出现。</p>
</blockquote>
<h1 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h1><p><strong>例子1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        IntStream.range(1, 1000)</span><br><span class="line">                .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i));</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">        IntStream.range(1, 1000)</span><br><span class="line">                .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    Optional.of(&quot;All of tasks finish done.&quot;).ifPresent(System.out::println);</span><br><span class="line">    IntStream.range(1, 1000)</span><br><span class="line">            .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>默认传入的数字为0，这里是在main线程里调用了两个线程的join()，所以main线程会等到Thread-0和Thread-1线程执行完再执行它自己。</p>
</li>
<li><p>join必须在start方法之后，并且join()是对wait()的封装。（源码中可以清楚的看到）</p>
</li>
<li><p>也就是说，t.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING或WAITING 状态。直到线程t完成，此线程再继续。</p>
</li>
<li><p>join也有人理解成插队，比如在main线程中调用t.join()，就是t线程要插main线程的队，main线程要去等待。</p>
</li>
</ul>
<p><strong>例子2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            IntStream.range(1, 1000)</span><br><span class="line">                    .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i));</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            IntStream.range(1, 1000)</span><br><span class="line">                    .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">//        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        Optional.of(&quot;All of tasks finish done.&quot;).ifPresent(System.out::println);</span><br><span class="line">        IntStream.range(1, 1000)</span><br><span class="line">                .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里是在t2（<strong>我们以后就都用变量名来称呼线程了</strong>）线程了。t1.join()了。所以t2线程会等待t1线程打印完，t2自己才会打印。然后t2.join()，main线程也要等待t2线程。总体执行顺序就是t1–&gt;t2–&gt;main</li>
<li>通过上方例子可以用join实现类似于CompletableFuture的异步任务编排。（后面会讲）</li>
</ul>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>1、Java 中的中断和操作系统的中断还不一样，这里就按照<strong>状态</strong>来理解吧，不要和操作系统的中断联系在一起</p>
<p>2、记住中断只是一个状态，Java的方法可以选择对这个中断进行响应，也可以选择不响应。响应的意思就是写相对应的代码执行相对应的操作，不响应的意思就是什么代码都不写。</p>
<h2 id="几个方法"><a href="#几个方法" class="headerlink" title="几个方法"></a>几个方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="comment">// Thread 类中的实例方法，持有线程实例引用即可检测线程中断状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、Thread 中的静态方法，检测调用这个方法的线程是否已经中断</span></span><br><span class="line"><span class="comment">2、注意：这个方法返回中断状态的同时，会将此线程的中断状态重置为 false</span></span><br><span class="line"><span class="comment">如果我们连续调用两次这个方法的话，第二次的返回值肯定就是 false 了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 类中的实例方法，用于设置一个线程的中断状态为 true</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小tip"><a href="#小tip" class="headerlink" title="小tip"></a>小tip</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span><span class="comment">//这个会清除中断状态</span></span><br></pre></td></tr></table></figure>

<p>为什么要这么设置呢？原因在于：</p>
<ul>
<li>interrupted()是一个静态方法，可以在Runnable接口实例中使用</li>
<li>isInterrupted()是一个Thread的实例方法，在重写Thread的run方法时使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.interrupted());</span><br><span class="line">        &#125;);  <span class="comment">//这个new Thread用的是runnable接口那个构造函数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(isInterrupted());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;<span class="comment">//这个new Thread用的就是Thread的空参构造</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说接口中不能调用Thread的实例方法，只能通过静态方法来判断是否发生中断</p>
<h2 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h2><p>当然，中断除了是线程状态外，还有其他含义，否则也不需要专门搞一个这个概念出来了。</p>
<blockquote>
<p>初学者肯定以为 thread.interrupt() 方法是用来暂停线程的，主要是和它对应中文翻译的“中断”有关。中断在并发中是常用的手段，请大家一定好好掌握。可以将中断理解为线程的状态，它的特殊之处在于设置了中断状态为 true 后，这几个方法会感知到：</p>
<ol>
<li><p>wait(), wait(long), wait(long, int), join(), join(long), join(long, int), sleep(long), sleep(long, int)</p>
<p>这些方法都有一个共同之处，方法签名上都有<code>throws InterruptedException</code>，这个就是用来响应中断状态修改的。</p>
</li>
<li><p>如果线程阻塞在 InterruptibleChannel 类的 IO 操作中，那么这个 channel 会被关闭。</p>
</li>
<li><p>如果线程阻塞在一个 Selector 中，那么 select 方法会立即返回。</p>
</li>
</ol>
<p>对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），<strong>并且在做出相应的操作后都会重置中断状态为 false</strong>。然后执行相应的操作（通常就是跳到 catch 异常处）。</p>
<p>如果不是以上3种情况，那么，线程的 interrupt() 方法被调用，会将线程的中断状态设置为 true。</p>
<p>那是不是只有以上 3 种方法能自动感知到中断呢？不是的，如果线程阻塞在 LockSupport.park(Object obj) 方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true。</p>
</blockquote>
<h1 id="并发编程中的三个问题"><a href="#并发编程中的三个问题" class="headerlink" title="并发编程中的三个问题"></a>并发编程中的三个问题</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="可见性概念"><a href="#可见性概念" class="headerlink" title="可见性概念"></a>可见性概念</h3><p>可见性（Visibility）：是指一个线程对共享变量进行修改，另一个先立即得到修改后的新值。</p>
<h3 id="可见性演示"><a href="#可见性演示" class="headerlink" title="可见性演示"></a>可见性演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="comment">/* 笔记</span></span><br><span class="line"><span class="comment"> * 1.当没有加Volatile的时候,while循环会一直在里面循环转圈</span></span><br><span class="line"><span class="comment"> * 2.当加了之后Volatile,由于可见性,一旦num改了之后,就会通知其他线程</span></span><br><span class="line"><span class="comment"> * 3.还有注意的时候不能用if,if不会重新拉回来再判断一次。(也叫做虚假唤醒)</span></span><br><span class="line"><span class="comment"> * 4.案例演示:一个线程对共享变量的修改,另一个线程不能立即得到新值</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Video04_01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//睡3秒之后再修改num,防止A线程先修改了num,那么到while循环的时候就会直接跳出去了</span></span><br><span class="line">            myData.addTo60();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come out&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(myData.num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//只有当num不等于0的时候,才会跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTo60</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面代码可以看出，并发编程时，会出现可见性问题，当一个线程对共享变量进行了修改，另外的线程并没有立即看到修改后的最新值。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="原子性概念"><a href="#原子性概念" class="headerlink" title="原子性概念"></a>原子性概念</h3><p>原子性（Atomicity）：在一次或多次操作中，要么所有的操作都成功执行并且不会受其他因素干扰而中 断，要么所有的操作都不执行或全部执行失败。不会出现中间状态</p>
<h3 id="原子性演示"><a href="#原子性演示" class="headerlink" title="原子性演示"></a>原子性演示</h3><p>案例演示:5个线程各执行1000次 i++;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/23 15:50</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: volatile不保证原子性的代码验证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Video05_01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyData03</span> <span class="variable">myData03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData03</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                     myData03.increment();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;,<span class="string">&quot;线程&quot;</span> + String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要等待上面的20个线程计算完之后再查看计算结果</span></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;20个线程执行完之后num:\t&quot;</span> + myData03.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData03</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、控制台输出：（由于并发不安全，每次执行的结果都可能不一样）</p>
<blockquote>
<p>20个线程执行完之后num: 19706</p>
</blockquote>
<p>正常来说，如果保证原子性的话，20个线程执行完，结果应该是20000。控制台输出的值却不是这个，说明出现了原子性的问题。</p>
<p>2、使用javap反汇编class文件，对于num++可以得到下面的字节码指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CODE</span><br><span class="line"><span class="number">9</span>: getstatic     #<span class="number">12</span>                 <span class="comment">// Field number:I   取值操作</span></span><br><span class="line"><span class="number">12</span>: iconst_1 </span><br><span class="line"><span class="number">13</span>: iadd </span><br><span class="line"><span class="number">14</span>: putstatic     #<span class="number">12</span>                 <span class="comment">// Field number:I  赋值操作</span></span><br></pre></td></tr></table></figure>

<p>由此可见num++是由多条语句组成，以上多条指令在一个线程的情况下是不会出问题的，但是在多线程情况下就可能会出现问题。</p>
<p>比如num刚开始值是7。A线程在执行13: iadd时得到num值是8，B线程又执行9: getstatic得到前一个值是7。马上A线程就把8赋值给了num变量。但是B线程已经拿到了之前的值7，B线程是在A线程真正赋值前拿到的num值。即使A线程最终把值真正的赋给了num变量，但是B线程已经走过了getstaitc取值的这一步，B线程会继续在7的基础上进行++操作，最终的结果依然是8。本来两个线程对7进行分别进行++操作，得到的值应该是9，因为并发问题，导致结果是8。</p>
<p>3、并发编程时，会出现原子性问题，当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共 享变量，干扰了前一个线程的操作。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="有序性概念"><a href="#有序性概念" class="headerlink" title="有序性概念"></a>有序性概念</h3><p>有序性（Ordering）：是指程序中代码的执行顺序，Java在编译时和运行时会对代码进行优化（重排序）来加快速度，会导致程序终的执行顺序不一定就是我们编写代码时的顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JAVA</span></span><br><span class="line"><span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonDemo</span>() 是被分成以下 <span class="number">3</span> 步完成</span><br><span class="line"> memory = allocate();     分配对象内存空间</span><br><span class="line"> instance(memory);        初始化对象</span><br><span class="line"> instance = memory;	   设置 instance 指向刚分配的内存地址，此时 instance != <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>步骤2 和 步骤3 不存在数据依赖关系，重排与否的执行结果单线程中是一样的。这种指令重排是被 Java 允许的。当 3 在前时，instance 不为 null，但实际上初始化工作还没完成，会变成一个返回 null 的getInstance。这时候数据就出现了问题。</p>
<h3 id="有序性演示"><a href="#有序性演示" class="headerlink" title="有序性演示"></a>有序性演示</h3><p>jcstress是java并发压测工具。<a target="_blank" rel="noopener" href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a> 修改pom文件，添加依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">CODE</span><br><span class="line">&lt;dependency&gt;   </span><br><span class="line"> &lt;groupId&gt;org.openjdk.jcstress&lt;/groupId&gt;    </span><br><span class="line">&lt;artifactId&gt;jcstress-core&lt;/artifactId&gt;    </span><br><span class="line">&lt;version&gt;$&#123;jcstress.version&#125;&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">JAVA</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@JCStressTest</span></span><br><span class="line"> <span class="comment">// @Outcome: 如果输出结果是1或4，我们是接受的(ACCEPTABLE)，并打印ok</span></span><br><span class="line"> <span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"> <span class="comment">//如果输出结果是0，我们是接受的并且感兴趣的，并打印danger</span></span><br><span class="line"> <span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)</span></span><br><span class="line"> <span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03Ordering</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 线程1执行的代码</span></span><br><span class="line">    <span class="meta">@Actor</span> <span class="comment">//@Actor：表示会有多个线程来执行这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2执行的代码</span></span><br><span class="line">    <span class="comment">// @Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、实际上上面两个方法会有很多线程来执行，为了讲解方便，我们只提出线程1和线程2来讲解。</p>
<p>2、I_Result 是一个保存int类型数据的对象，有一个属性 r1 用来保存结果，在多线程情况下可能出现几种结果？</p>
<p>情况1：线 程1先执行actor1，这时ready &#x3D; false，所以进入else分支结果为1。</p>
<p>情况2：线程2执行到actor2，执行了num &#x3D; 2;和ready &#x3D; true，线程1执行，这回进入 if 分支，结果为 4。</p>
<p>情况3：线程2先执行actor2，只执行num &#x3D; 2；但没来得及执行 ready &#x3D; true，线程1执行，还是进入 else分支，结果为1。</p>
<p>情况4：0，发生了指令重排</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="comment">// 线程2执行的代码</span></span><br><span class="line">   <span class="comment">// @Actor</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">       num = <span class="number">2</span>;    <span class="comment">//pos_1</span></span><br><span class="line">       ready = <span class="literal">true</span>;<span class="comment">//pos_2</span></span><br><span class="line">   &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>pos_1处代码和pos_2处代码没有什么数据依赖关系，或者说没有因果关系。Java可能对其进行指令重排，排成下面的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="comment">// 线程2执行的代码</span></span><br><span class="line">   <span class="comment">// @Actor</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">   	ready = <span class="literal">true</span>;<span class="comment">//pos_2</span></span><br><span class="line">       num = <span class="number">2</span>;    <span class="comment">//pos_1</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此时如果线程2先执行到<code>ready = true;</code>还没来得及执行 <code>num = 2;</code> 。线程1执行，直接进入if分支，此时num默认值为0。 得到的结果也就是0。</p>
<h1 id="volatile-1"><a href="#volatile-1" class="headerlink" title="volatile"></a>volatile</h1><blockquote>
<p>1、关于可见性，重排序等等的硬件原理，MESI缓存一致性，内存屏障，JMM等等这些，请看我的后面文章。第一阶段只是介绍下用法，不涉及原理。</p>
<p>2、如果你在第一篇文章没有找到你想要的内容，请看我后面的内容。并发的体系，我自认为讲的还是比较全面的。</p>
</blockquote>
<h2 id="volatile保证可见性代码"><a href="#volatile保证可见性代码" class="headerlink" title="volatile保证可见性代码"></a>volatile保证可见性代码</h2><blockquote>
<p>读者可以把两个代码运行一下，就能明显看到不加volatile的死循环（就是程序一直显示没结束）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="comment">/* 笔记</span></span><br><span class="line"><span class="comment"> * 1.当没有加Volatile的时候,while循环会一直在里面转圈</span></span><br><span class="line"><span class="comment"> * 2.当加了之后Volatile,由于可见性,一旦num改了之后,就会通知其他线程</span></span><br><span class="line"><span class="comment"> * 3.还有注意的时候不能用if,if不会重新拉回来再判断一次</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Video04_02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyData2</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//睡3秒之后再修改num,防止A线程先修改了num,那么到while循环的时候就会直接跳出去了</span></span><br><span class="line">            myData.addTo60();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come out&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(myData.num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//只有当num不等于0的时候,才会跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData2</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTo60</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="volatile保证有序性代码"><a href="#volatile保证有序性代码" class="headerlink" title="volatile保证有序性代码"></a>volatile保证有序性代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@JCStressTest</span></span><br><span class="line"> <span class="comment">// @Outcome: 如果输出结果是1或4，我们是接受的(ACCEPTABLE)，并打印ok</span></span><br><span class="line"> <span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"> <span class="comment">//如果输出结果是0，我们是接受的并且感兴趣的，并打印danger</span></span><br><span class="line"> <span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)</span></span><br><span class="line"> <span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03Ordering</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 线程1执行的代码</span></span><br><span class="line">    <span class="meta">@Actor</span> <span class="comment">//@Actor：表示会有多个线程来执行这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2执行的代码</span></span><br><span class="line">    <span class="comment">// @Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读者可以将运行结果对比着来看，就能发现区别。</p>
<p>volatile只能保证可见性和有序性（禁止指令重排），无法保证原子性。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>volatile自己虽然不能保证原子性，但是和CAS结合起来就可以保证原子性了。CAS+volatile一起用就可以同时解决<strong>并发编程中的三个问题</strong>了，保证并发安全。</p>
<h2 id="CAS-是什么？"><a href="#CAS-是什么？" class="headerlink" title="CAS 是什么？"></a>CAS 是什么？</h2><ul>
<li><p>CAS：比较并交换compareAndSet,它是一条 CPU 并发原语，它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子性的。</p>
</li>
<li><p>例: AtomicInteger 的 compareAndSet(‘期望值’,’设置值’) 方法，期望值与目标值一致时，修改目标变量为设置值，期望值与目标值不一致时，返回 false 和最新主存的变量值</p>
</li>
<li><p>CAS 的底层原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例: AtomicInteger.getAndIncrement()</span><br><span class="line">  调用 Unsafe 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令</span><br><span class="line">      这是一种完全依赖于硬件的功能，通过它实现原子操作。</span><br><span class="line">      原语的执行必须是连续的，在执行过程中不允许被中断，CAS 是 CPU 的一条原子指令。</span><br></pre></td></tr></table></figure>


</li>
<li><p>CAS的思想就是乐观锁的思想</p>
</li>
</ul>
<h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>在JUC并发包中，CAS和AtomicInteger（原子类的value值都被volatile修饰了）一起保证了并发安全。下面我们以AtomicInteger.getAndIncrement() 方法讲一下。</p>
<p><a target="_blank" rel="noopener" href="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/First_stage/0009.png"><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/First_stage/0009.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line"> * unsafe: rt.jar/sun/misc/Unsafe.class</span><br><span class="line"> *   Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地&lt;native&gt;方法来访问</span><br><span class="line"> *	 Unsafe 相当于一个后门，基于该类可以直接操作特定内存的数据</span><br><span class="line"> *	 Unsafe 其内部方法都是 native 修饰的，可以像 C 的指针一样直接操作内存</span><br><span class="line"> *	 Java 中的 CAS 操作执行依赖于 Unsafe 的方法，直接调用操作系统底层资源执行程序</span><br><span class="line"> *</span><br><span class="line"> * this: 当前对象</span><br><span class="line"> *	 变量 value 由 volatile 修饰，保证了多线程之间的内存可见性、禁止重排序</span><br><span class="line"> *</span><br><span class="line"> * valueOffset: 内存地址</span><br><span class="line"> *	 表示该变量值在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据</span><br><span class="line"> *</span><br><span class="line"> * 1: 固定写死，原值加1</span><br><span class="line"> */</span><br><span class="line">public final int getAndIncrement()&#123;</span><br><span class="line">    return unsafe.getAndAddInt(this,valueOffset,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Unsafe.getAndAddInt()</span><br><span class="line"> * getIntVolatile: 通过内存地址去主存中取对应数据</span><br><span class="line"> * </span><br><span class="line"> * while(!this.compareAndSwapInt(var1,var2,var5,var5 + var4)):</span><br><span class="line"> * 	 将本地 value 与主存中取出的数据对比，如果相同，对其作运算，</span><br><span class="line"> * 		此时返回 true，取反后 while 结束，返回最终值。</span><br><span class="line"> * 	 如果不相同，此时返回 false，取反后 while 循环继续运行，此时为自旋锁&lt;重复尝试&gt;</span><br><span class="line"> *		由于 value 是被 volatile 修饰的，所以拿到主存中最新值，再循环直至成功。</span><br><span class="line"> */</span><br><span class="line">public final int getAndAddInt(Object var1,long var2,int var4)&#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do&#123;</span><br><span class="line">        var5 = this.getIntVolatile(var1,var2); // 从主存中拷贝变量到本地内存</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1,var2,var5,var5 + var4));</span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CAS-代码演示"><a href="#CAS-代码演示" class="headerlink" title="CAS 代码演示"></a>CAS 代码演示</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class CASDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger num = new AtomicInteger(5);</span><br><span class="line">        // TODO</span><br><span class="line">        System.out.println(num.compareAndSet(5, 1024) + &quot;\t current num&quot; + num.get());</span><br><span class="line">        System.out.println(num.compareAndSet(5, 2019) + &quot;\t current num&quot; + num.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="CAS三大问题"><a href="#CAS三大问题" class="headerlink" title="CAS三大问题"></a>CAS三大问题</h2><ul>
<li>如果 CAS 长时间一直不成功，会给 CPU 带来很大的开销，在Java的实现中是一直通过while循环自旋CAS获取锁。</li>
<li>只能保证一个共享变量的原子操作</li>
<li>引出了 ABA 问题</li>
</ul>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><h3 id="什么是ABA问题？"><a href="#什么是ABA问题？" class="headerlink" title="什么是ABA问题？"></a>什么是ABA问题？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line"> * @Author: 吕</span><br><span class="line"> * @Date: 2019/9/24 16:43</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 功能描述: CAS引发的ABA问题</span><br><span class="line"> */</span><br><span class="line">public class Video19_01 &#123;</span><br><span class="line">    static AtomicReference&lt;Integer&gt; num = new AtomicReference&lt;&gt;(100);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">        new Thread(() -&gt;&#123;</span><br><span class="line">            num.compareAndSet(100, 101);</span><br><span class="line">            num.compareAndSet(101,100);</span><br><span class="line">        &#125;,&quot;线程A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt;&#123;</span><br><span class="line">            //保证A线程已经修改完</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            boolean b = num.compareAndSet(100, 2019);</span><br><span class="line">            System.out.println(b + &quot;\t 当前最新值&quot; + num.get().toString());</span><br><span class="line">        &#125;,&quot;线程B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CAS 会导致 ABA 问题：</strong></p>
<p>例: A、B线程从主存取出变量 value</p>
<p>-&gt; A 在 N次计算中改变 value 的值<br>-&gt; A 最终计算结果还原 value 最初的值<br>-&gt; B 计算后，比较主存值与自身 value 值一致，修改成功</p>
<p>尽管各个线程的 CAS 都操作成功，但是并不代表这个过程就是没有问题的。</p>
<h3 id="ABA问题的解决"><a href="#ABA问题的解决" class="headerlink" title="ABA问题的解决"></a>ABA问题的解决</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line"> * @Author: 吕</span><br><span class="line"> * @Date: 2019/9/24 16:49</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 功能描述: ABA问题的解决</span><br><span class="line"> */</span><br><span class="line">public class Video19_02 &#123;</span><br><span class="line">    static AtomicStampedReference&lt;Integer&gt; num = new AtomicStampedReference&lt;&gt;(100,1);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int stamp = num.getStamp();//初始版本号</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt;&#123;</span><br><span class="line">            num.compareAndSet(100,101,num.getStamp(),num.getStamp() + 1);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 版本号&quot; + num.getStamp());</span><br><span class="line">            num.compareAndSet(101,100,num.getStamp(),num.getStamp() + 1);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 版本号&quot; + num.getStamp());</span><br><span class="line">        &#125;,&quot;线程A&quot;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            boolean b = num.compareAndSet(100, 209, stamp, num.getStamp() + 1);</span><br><span class="line">            System.out.println(b + &quot;\t 当前版本号: \t&quot; + num.getStamp());</span><br><span class="line">            System.out.println(&quot;当前最新值 \t&quot; + num.getReference().toString());</span><br><span class="line">        &#125;,&quot;线程B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思想很简单，可以很明显的看出来用版本号的方式解决了ABA的问题。</p>
<ul>
<li>除了对象值，AtomicStampedReference内部还维护了一个“状态戳”。</li>
<li>状态戳可类比为时间戳，是一个整数值，每一次修改对象值的同时，也要修改状态戳，从而区分相同对象值的不同状态。</li>
<li>当AtomicStampedReference设置对象值时，对象值以及状态戳都必须满足期望值，写入才会成功。</li>
</ul>
<h2 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h2><ul>
<li>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个方法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i&#x3D;2,j&#x3D;a合并一下ij&#x3D;2a，然后用CAS来操作ij。从java1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</li>
<li>所以一般来说为了同时解决ABA问题和只能保证一个共享变量，原子类使用时大部分使用的是<code>AtomicStampedReference</code></li>
</ul>
<h1 id="UnSafe"><a href="#UnSafe" class="headerlink" title="UnSafe"></a>UnSafe</h1><p>Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Cassandra、Hadoop、Kafka等。Unsafe类在提升Java运行效率，增强Java语言底层操作能力方面起了很大的作用。</p>
<p>Java和C++语言的一个重要区别就是Java中我们无法直接操作一块内存区域，不能像C++中那样可以自己申请内存和释放内存。 <strong>Java中的Unsafe类为我们提供了类似C++手动管理内存的能力，同时也有了指针的问题。</strong></p>
<p>首先，Unsafe类是”final”的，不允许继承。且构造函数是private的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public final class Unsafe &#123;</span><br><span class="line">    private static final Unsafe theUnsafe;</span><br><span class="line">    public static final int INVALID_FIELD_OFFSET = -1;</span><br><span class="line"></span><br><span class="line">    private static native void registerNatives();</span><br><span class="line"></span><br><span class="line">    private Unsafe() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>因此我们无法在外部对Unsafe进行实例化。</strong></p>
<h2 id="获取Unsafe"><a href="#获取Unsafe" class="headerlink" title="获取Unsafe"></a>获取Unsafe</h2><p>Unsafe无法实例化，那么怎么获取Unsafe呢？答案就是通过反射来获取Unsafe：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public Unsafe getUnsafe() throws IllegalAccessException &#123;</span><br><span class="line">    Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">    unsafeField.setAccessible(true);</span><br><span class="line">    Unsafe unsafe = (Unsafe) unsafeField.get(null);</span><br><span class="line">    return unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unsafe的功能如下图：</p>
<p><a target="_blank" rel="noopener" href="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/First_stage/0008.png"><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/First_stage/0008.png" alt="img"></a></p>
<h2 id="CAS相关"><a href="#CAS相关" class="headerlink" title="CAS相关"></a>CAS相关</h2><p>JUC中大量运用了CAS操作，可以说CAS操作是JUC的基础，因此CAS操作是非常重要的。Unsafe中提供了int,long和Object的CAS操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);</span><br></pre></td></tr></table></figure>

<h2 id="偏移量相关"><a href="#偏移量相关" class="headerlink" title="偏移量相关"></a>偏移量相关</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public native long staticFieldOffset(Field var1);</span><br><span class="line"></span><br><span class="line">public native long objectFieldOffset(Field var1);</span><br></pre></td></tr></table></figure>

<ul>
<li>staticFieldOffset方法用于获取静态属性Field在对象中的偏移量，读写静态属性时必须获取其偏移量。</li>
<li>objectFieldOffset方法用于获取非静态属性Field在对象实例中的偏移量，读写对象的非静态属性时会用到这个偏移量</li>
</ul>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public native Class&lt;?&gt; defineClass(String var1, byte[] var2, int var3, int var4, ClassLoader var5, ProtectionDomain var6);</span><br><span class="line"></span><br><span class="line">public native Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; var1, byte[] var2, Object[] var3);</span><br><span class="line"></span><br><span class="line">public native Object allocateInstance(Class&lt;?&gt; var1) throws InstantiationException;</span><br><span class="line"></span><br><span class="line">public native boolean shouldBeInitialized(Class&lt;?&gt; var1);</span><br><span class="line"></span><br><span class="line">public native void ensureClassInitialized(Class&lt;?&gt; var1);</span><br></pre></td></tr></table></figure>

<ul>
<li>defineClass方法定义一个类，用于动态地创建类。</li>
<li>defineAnonymousClass用于动态的创建一个匿名内部类。</li>
<li><code>allocateInstance</code>方法用于创建一个类的实例，但是不会调用这个实例的构造方法，如果这个类还未被初始化，则初始化这个类。</li>
<li>shouldBeInitialized方法用于判断是否需要初始化一个类。</li>
<li>ensureClassInitialized方法用于保证已经初始化过一个类。</li>
</ul>
<p><strong>举例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class UnsafeFooTest &#123;</span><br><span class="line">    private static Unsafe geUnsafe() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            return (Unsafe) f.get(null);</span><br><span class="line">        &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Simple &#123;</span><br><span class="line">        private long l = 0;</span><br><span class="line"></span><br><span class="line">        public Simple() &#123;</span><br><span class="line">            this.l = 1;</span><br><span class="line">            System.out.println(&quot;我被初始化了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public long getL() &#123;</span><br><span class="line">            return l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Unsafe unsafe = geUnsafe();</span><br><span class="line"></span><br><span class="line">        Simple s = (Simple) unsafe.allocateInstance(Simple.class);</span><br><span class="line">        System.out.println(s.getL());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<blockquote>
<p>0</p>
</blockquote>
<ul>
<li>可以发现，利用Unsafe获取实例，不会调用构造方法</li>
</ul>
<h2 id="普通读写"><a href="#普通读写" class="headerlink" title="普通读写"></a>普通读写</h2><p>通过Unsafe可以读写一个类的属性，即使这个属性是私有的，也可以对这个属性进行读写。</p>
<p>读写一个Object属性的相关方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public native int getInt(Object var1, long var2);</span><br><span class="line"></span><br><span class="line">public native void putInt(Object var1, long var2, int var4);</span><br></pre></td></tr></table></figure>

<ul>
<li>getInt用于从对象的指定偏移地址处读取一个int。</li>
<li>putInt用于在对象指定偏移地址处写入一个int。其他的primitive type也有对应的方法。</li>
</ul>
<p><strong>举例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class UnsafeFooTest &#123;</span><br><span class="line">    private static Unsafe geUnsafe() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            return (Unsafe) f.get(null);</span><br><span class="line">        &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Guard&#123;</span><br><span class="line">        private int ACCESS_ALLOWED = 1;</span><br><span class="line">        private boolean allow()&#123;</span><br><span class="line">            return 50 == ACCESS_ALLOWED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void work()&#123;</span><br><span class="line">            if (allow())&#123;</span><br><span class="line">                System.out.println(&quot;我被允许工作....&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Unsafe unsafe = geUnsafe();</span><br><span class="line">        Guard guard = new Guard();</span><br><span class="line"></span><br><span class="line">        Field f = guard.getClass().getDeclaredField(&quot;ACCESS_ALLOWED&quot;);</span><br><span class="line"></span><br><span class="line">        unsafe.putInt(guard,unsafe.objectFieldOffset(f),50);</span><br><span class="line">        System.out.println(&quot;强行赋值...&quot;);</span><br><span class="line">        guard.work();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<blockquote>
<p>强行赋值…</p>
</blockquote>
<p>我被允许工作…</p>
<h2 id="类加载-1"><a href="#类加载-1" class="headerlink" title="类加载"></a>类加载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public native Class&lt;?&gt; defineClass(String var1, byte[] var2, int var3, int var4, ClassLoader var5, ProtectionDomain var6);</span><br><span class="line"></span><br><span class="line">public native Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; var1, byte[] var2, Object[] var3);</span><br><span class="line"></span><br><span class="line">public native Object allocateInstance(Class&lt;?&gt; var1) throws InstantiationException;</span><br><span class="line"></span><br><span class="line">public native boolean shouldBeInitialized(Class&lt;?&gt; var1);</span><br><span class="line"></span><br><span class="line">public native void ensureClassInitialized(Class&lt;?&gt; var1);</span><br></pre></td></tr></table></figure>

<ul>
<li>defineClass方法定义一个类，用于动态地创建类。</li>
<li>defineAnonymousClass用于动态的创建一个匿名内部类。</li>
<li>allocateInstance方法用于创建一个类的实例，但是不会调用这个实例的构造方法，如果这个类还未被初始化，则初始化这个类。</li>
<li>shouldBeInitialized方法用于判断是否需要初始化一个类。</li>
<li>ensureClassInitialized方法用于保证已经初始化过一个类。</li>
</ul>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public native void loadFence();</span><br><span class="line"></span><br><span class="line">public native void storeFence();</span><br><span class="line"></span><br><span class="line">public native void fullFence();</span><br></pre></td></tr></table></figure>

<ul>
<li>loadFence：保证在这个屏障之前的所有读操作都已经完成。</li>
<li>storeFence：保证在这个屏障之前的所有写操作都已经完成。</li>
<li>fullFence：保证在这个屏障之前的所有读写操作都已经完成。</li>
</ul>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public native void unpark(Object var1);</span><br><span class="line"></span><br><span class="line">public native void park(boolean var1, long var2);</span><br><span class="line"></span><br><span class="line">public native void monitorEnter(Object var1);</span><br><span class="line"></span><br><span class="line">public native void monitorExit(Object var1);</span><br><span class="line"></span><br><span class="line">public native boolean tryMonitorEnter(Object var1);</span><br></pre></td></tr></table></figure>

<ul>
<li>park方法和unpark方法相信看过LockSupport类的都不会陌生，这两个方法主要用来挂起和唤醒线程。</li>
<li>LockSupport中的park和unpark方法正是通过Unsafe来实现的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(false, 0L);</span><br><span class="line">    setBlocker(t, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void unpark(Thread thread) &#123;</span><br><span class="line">    if (thread != null)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>monitorEnter方法和monitorExit方法用于加锁，Java中的synchronized锁就是通过这两个指令来实现的。</strong></p>
<h1 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h1><blockquote>
<p>synchronized可以同时保证可见性，有序性，原子性。这个东西就不讲了</p>
</blockquote>
<p>从JDk 1.6开始，JVM就对synchronized锁进行了很多的优化。synchronized说是锁，但是他的底层加锁的方式可能不同，偏向锁的方式来加锁，自旋锁的方式来加锁，轻量级锁的方式来加锁</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是JIT编译器对synchronized锁做的优化，在编译的时候，JIT会通过逃逸分析技术，来分析synchronized锁对象，是不是只可能被一个线程来加锁，没有其他的线程来竞争加锁，这个时候编译就不用加入monitorenter和monitorexit的指令。这就是，仅仅一个线程争用锁的时候，就可以消除这个锁了，提升这段代码的执行的效率，因为可能就只有一个线程会来加锁，不涉及到多个线程竞争锁</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">synchronized(this) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">synchronized(this) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">synchronized(this) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个意思就是，JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁，就是锁粗化，把一个锁给搞粗了，避免频繁多次加锁释放锁</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>这个意思就是说，monitorenter和monitorexit是要使用CAS操作加锁和释放锁的，开销较大，因此如果发现大概率只有一个线程会主要竞争一个锁，那么会给这个锁维护一个偏好（Bias），后面他加锁和释放锁，基于Bias来执行，不需要通过CAS，性能会提升很多。但是如果有偏好之外的线程来竞争锁，就要收回之前分配的偏好。可能只有一个线程会来竞争一个锁，但是也有可能会有其他的线程来竞争这个锁，但是其他线程唉竞争锁的概率很小。如果有其他的线程来竞争这个锁，此时就会收回之前那个线程分配的那个Bias偏好</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>如果偏向锁没能成功实现，就是因为不同线程竞争锁太频繁了，此时就会尝试采用轻量级锁的方式来加锁，就是将对象头的Mark Word里有一个轻量级锁指针，尝试指向持有锁的线程，然后判断一下是不是自己加的锁，如果是自己加的锁，那就执行代码就好了。如果不是自己加的锁，那就是加锁失败，说明有其他人加了锁，这个时候就是升级为重量级锁</p>
<h2 id="适应性锁"><a href="#适应性锁" class="headerlink" title="适应性锁"></a>适应性锁</h2><p>这是JIT编译器对锁做的另外一个优化，如果各个线程持有锁的时间很短，那么一个线程竞争锁不到，就会暂停，发生上下文切换，让其他线程来执行。但是其他线程很快释放锁了，然后暂停的线程再次被唤醒。也就是说在这种情况下，线程会频繁的上下文切换，导致开销过大。所以对这种线程持有锁时间很短的情况，是可以采取忙等策略的，也就是一个线程没竞争到锁，进入一个while循环不停等待，不会暂停不会发生线程上下文切换，等到机会获取锁就继续执行好了</p>
<h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p>
<h2 id="为什么指令重排序可以提高性能？"><a href="#为什么指令重排序可以提高性能？" class="headerlink" title="为什么指令重排序可以提高性能？"></a>为什么指令重排序可以提高性能？</h2><p>简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，<strong>流水线技术</strong>产生了，它的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率。</p>
<p>但是，流水线技术最害怕<strong>中断</strong>，恢复中断的代价是比较大的，所以我们要想尽办法不让流水线中断。指令重排就是减少中断的一种技术。</p>
<p>我们分析一下下面这个代码的执行情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">a = b + c;</span><br><span class="line">d = e - f ;</span><br></pre></td></tr></table></figure>

<p>先加载b、c（<strong>注意，即有可能先加载b，也有可能先加载c</strong>），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。</p>
<p>为了减少这个停顿，我们可以先加载e和f,然后再去加载add(b,c),这样做对程序（串行）是没有影响的,但却减少了停顿。既然add(b,c)需要停顿，那还不如去做一些有意义的事情。</p>
<p>综上所述，<strong>指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。</strong></p>
<p>指令重排一般分为以下三种：</p>
<ul>
<li><p><strong>编译器优化重排</strong></p>
<p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p><strong>指令并行重排</strong></p>
<p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</p>
</li>
<li><p><strong>内存系统重排</strong></p>
<p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p>
</li>
</ul>
<p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p>
<h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><p>as-if-serial语义的意思是：不管编译器和CPU如何重排序，必须保证在单线程情况下程序的结果是正确的。 以下数据有依赖关系，不能重排序。</p>
<p>写后读：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CODE</span><br><span class="line">int a = 1; </span><br><span class="line">int b = a;</span><br></pre></td></tr></table></figure>

<p>写后写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CODE</span><br><span class="line">int a = 1; </span><br><span class="line">int a = 2;</span><br></pre></td></tr></table></figure>

<p>读后写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CODE</span><br><span class="line">int a = 1; </span><br><span class="line">int b = a; </span><br><span class="line">int a = 2;</span><br></pre></td></tr></table></figure>

<p>编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CODE</span><br><span class="line">int a = 1; </span><br><span class="line">int b = 2; </span><br><span class="line">int c = a + b;</span><br></pre></td></tr></table></figure>

<h1 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型(JMM)"></a>Java内存模型(JMM)</h1><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型。</p>
<h2 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h2><h3 id="计算机结构简介"><a href="#计算机结构简介" class="headerlink" title="计算机结构简介"></a>计算机结构简介</h3><p>冯诺依曼，提出计算机由五大组成部分，输入设备，输出设备存储器，控制器，运算器。</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>中央处理器，是计算机的控制和运算的核心，我们的程序终都会变成指令让CPU去执行，处理程序中 的数据。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>我们的程序都是在内存中运行的，内存会保存程序运行时的数据，供CPU处理。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>CPU的运算速度和内存的访问速度相差比较大。这就导致CPU每次操作内存都要耗费很多等待时间。内 存的读写速度成为了计算机运行的瓶颈。于是就有了在CPU和主内存之间增加缓存的设计。靠近CPU 的缓存称为L1，然后依次是 L2，L3和主内存，CPU缓存模型如图下图所示。</p>
<p>CPU Cache分成了三个级别: L1， L2， L3。级别越小越接近CPU，速度也更快，同时也代表着容量越小。速度越快的价格越贵。</p>
<p>1、L1是接近CPU的，它容量小，例如32K，速度快，每个核上都有一个L1 Cache。</p>
<p>2、L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下每个核上都有一个独立的L2 Cache。</p>
<p>3、L3 Cache是三级缓存中大的一级，例如12MB，同时也是缓存中慢的一级，在同一个CPU插槽 之间的核共享一个L3 Cache。</p>
<p>[</p>
<p>上面的图中有一个Latency指标。比如Memory这个指标为59.4ns，表示CPU在操作内存的时候有59.4ns的延迟，一级缓存最快只有1.2ns。</p>
<p><strong>CPU处理数据的流程</strong></p>
<p>Cache的出现是为了解决CPU直接访问内存效率低下问题的。</p>
<p>1、程序在运行的过程中，CPU接收到指令 后，它会先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，如果命中缓存，CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写人，当运算结束之后，再将CPUCache中的新数据刷新 到主内存当中，CPU通过直接访问Cache的方式替代直接访问主存的方式极大地提高了CPU 的吞吐能 力。</p>
<p>2、但是由于一级缓存（L1 Cache）容量较小，所以不可能每次都命中。这时CPU会继续向下一级的二 级缓存（L2 Cache）寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向L3 Cache、内存(主存)和硬盘。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>1、Java Memory Molde (Java内存模型&#x2F;JMM)，千万不要和Java内存结构（JVM划分的那个堆，栈，方法区）混淆。关于“Java内存模型”的权威解释，参考 <a target="_blank" rel="noopener" href="https://download.oracle.com/otn-pub/jcp/memory_model1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf%E3%80%82">https://download.oracle.com/otn-pub/jcp/memory_model1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf。</a></p>
<p>2、 Java内存模型，是Java虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。 Java内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节，具体如下。</p>
<p>3、Java内存模型根据官方的解释，主要是在说两个关键字，一个是<code>volatile</code>，一个是<code>synchronized</code>。</p>
<p><strong>主内存</strong></p>
<p>主内存是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。</p>
<p><strong>工作内存</strong></p>
<p>每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的副本。线程对变量的所有的操 作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接 访问对方工作内存中的变量。</p>
<p>Java的线程不能直接在主内存中操作共享变量。而是首先将主内存中的共享变量赋值到自己的工作内存中，再进行操作，操作完成之后，刷回主内存。</p>
<p><strong>Java内存模型的作用</strong></p>
<p>Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。 synchronized,volatile</p>
<h2 id="CPU缓存，内存与Java内存模型的关系"><a href="#CPU缓存，内存与Java内存模型的关系" class="headerlink" title="CPU缓存，内存与Java内存模型的关系"></a>CPU缓存，内存与Java内存模型的关系</h2><ul>
<li>通过对前面的CPU硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行终都会映射到硬件处理器上进行执行。 但Java内存模型和硬件内存架构并不完全一致。</li>
<li>对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存和主内存之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响， 因为JMM只是一种抽象的概念，是一组规则，不管是工作内存的数据还是主内存的数据，对于计算机硬 件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说， Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。</li>
</ul>
<p>JMM内存模型与CPU硬件内存架构的关系：</p>
<p>工作内存：可能对应CPU寄存器，也可能对应CPU缓存，也可能对应内存。</p>
<ul>
<li>Java内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量 存储到内存和从内存中读取变量这样的底层细节，Java内存模型是对共享数据的可见性、有序性、和原子性的规则和保障。</li>
</ul>
<h2 id="再谈可见性"><a href="#再谈可见性" class="headerlink" title="再谈可见性"></a>再谈可见性</h2><p><a target="_blank" rel="noopener" href="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0007.png"><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0007.png" alt="img"></a><a target="_blank" rel="noopener" href="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0008.png"><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0008.png" alt="img"></a></p>
<p>1、图中所示是 个双核 CPU 系统架构 ，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的1级缓存，在有些架构里面还有1个所有 CPU 共享的2级缓存。 那么 Java 内存模型里面的工作内存，就对应这里的 Ll 或者 L2 存或者 CPU 寄存器。</p>
<p>2、一个线程操作共享变量时，它首先从主内存复制共享变量到自己的工作内存，然后对工作内存里的变量进行处理，处理完后将变量值更新到主内存。 </p>
<p>3、那么假如线程A和线程B同时处理一个共享变量，会出现什么情况?我们使用图所示CPU架构，假设线程A和线程B使用不同CPU执行，并且当前两级Cache都为空，那么这时候由于Cache的存在，将会导致内存不可见问题，具体看下面的分析。</p>
<ul>
<li>线程A首先获取共享变量X的值，由于两级Cache都没有命中，所以加载主内存中X的值，假如为0。然后把X&#x3D;0的值缓存到两级缓存，线程A修改X的值为1，然后将其写入两级Cache，并且刷新到主内存。线程A操作完毕后，线程A所在的CPU的两级Cache 内和主内存里面的X的值都是1。</li>
<li>线程B获取X的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命中了，所以返回X&#x3D;1;到这里一切都是正常的，因为这时候主内存中也是X&#x3D;1。然后线程B修改X的值为2，并将其存放到线程2所在的一级Cache和共享二级Cache中，最后更新主内存中X 的值为2;到这里一切都是好的。</li>
<li>线程A 这次又需要修改X的值，获取时一级缓存命中，并且X&#x3D;1，到这里问题就出现了，明明线程B已经把X的值修改为了2，为何线程A获取的还是1呢?这就是共享变量的内存不可见问题，也就是线程B写入的值对线程A不可见。那么如何解决共享变量内存不可见问题?使用Java中的volatile和synchronized关键字就可以解决这个问题，下面会有讲解。</li>
</ul>
<h1 id="主内存与工作内存之间的交互"><a href="#主内存与工作内存之间的交互" class="headerlink" title="主内存与工作内存之间的交互"></a>主内存与工作内存之间的交互</h1><p>为了保证数据交互时数据的正确性，Java内存模型中定义了8种操作来完成这个交互过程，这8种操作本身都是原子性的。虚拟机实现时必须保证下面 提及的每一种操作都是原子的、不可再分的。</p>
<p><a target="_blank" rel="noopener" href="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0009.png"><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0009.png" alt="img"></a></p>
<blockquote>
<p>(1)lock:作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</p>
<p>(2)unlock:作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。</p>
<p>(3)read:作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</p>
<p>(4)load:作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
<p>(5)use:作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时都会执行这个操作。</p>
<p>(6)assign:作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
<p>(7)store:作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write使用。</p>
<p>(8)write:作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</p>
</blockquote>
<p>注意:</p>
<ol>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中</li>
<li>lock和unlock操作只有加锁才会有。synchronized就是通过这样来保证可见性的。</li>
</ol>
<p>如果没有synchronized，那就是下面这样的</p>
<p><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0010.png" alt="img"></p>
<h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h1><h2 id="什么是happens-before"><a href="#什么是happens-before" class="headerlink" title="什么是happens-before?"></a>什么是happens-before?</h2><p>一方面，程序员需要JMM提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望JMM对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。</p>
<p>JMM考虑了这两种需求，并且找到了平衡点，对编译器和处理器来说，<strong>只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。</strong></p>
<p>而对于程序员，JMM提供了<strong>happens-before规则</strong>（JSR-133规范），满足了程序员的需求——<strong>简单易懂，并且提供了足够强的内存可见性保证。</strong>换言之，程序员只要遵循happens-before规则，那他写的程序就能保证在JMM中具有强的内存可见性。</p>
<p>JMM使用happens-before的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证。</p>
<p>happens-before关系的定义如下：</p>
<ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li><strong>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。</strong></li>
</ol>
<p>happens-before关系本质上和as-if-serial语义是一回事。</p>
<p>as-if-serial语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before关系保证正确同步的多线程程序的执行结果不被重排序改变。</p>
<p>总之，<strong>如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。</strong></p>
<h2 id="天然的happens-before关系"><a href="#天然的happens-before关系" class="headerlink" title="天然的happens-before关系"></a>天然的happens-before关系</h2><p>在Java中，有以下天然的happens-before关系：</p>
<ul>
<li>1、程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>2、锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作，比如说在代码里有先对一个lock.lock()，lock.unlock()，lock.lock()</li>
<li>3、volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个volatile变量的读操作，volatile变量写，再是读，必须保证是先写，再读</li>
<li>4、传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>5、线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作，thread.start()，thread.interrupt()</li>
<li>6、线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>7、线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>8、对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>
<p>上面这8条原则的意思很显而易见，就是程序中的代码如果满足这个条件，就一定会按照这个规则来保证指令的顺序。</p>
<p><strong>举例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">int a = 1; // A操作</span><br><span class="line">int b = 2; // B操作</span><br><span class="line">int sum = a + b;// C 操作</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>

<p>上面这8条原则的意思很显而易见，就是程序中的代码如果满足这个条件，就一定会按照这个规则来保证指令的顺序。</p>
<p><strong>举例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">int a = 1; // A操作</span><br><span class="line">int b = 2; // B操作</span><br><span class="line">int sum = a + b;// C 操作</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>

<p>根据以上介绍的happens-before规则，假如只有一个线程，那么不难得出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CODE</span><br><span class="line">1&gt; A happens-before B </span><br><span class="line">2&gt; B happens-before C </span><br><span class="line">3&gt; A happens-before C</span><br></pre></td></tr></table></figure>

<p>注意，真正在执行指令的时候，其实JVM有可能对操作A &amp; B进行重排序，因为无论先执行A还是B，他们都对对方是可见的，并且不影响执行结果。</p>
<p>如果这里发生了重排序，这在视觉上违背了happens-before原则，但是JMM是允许这样的重排序的。</p>
<p>所以，我们只关心happens-before规则，不用关心JVM到底是怎样执行的。只要确定操作A happens-before操作B就行了。</p>
<p>重排序有两类，JMM对这两类重排序有不同的策略：</p>
<ul>
<li>会改变程序执行结果的重排序，比如 A -&gt; C，JMM要求编译器和处理器都禁止这种重排序。</li>
<li>不会改变程序执行结果的重排序，比如 A -&gt; B，JMM对编译器和处理器不做要求，允许这种重排序。</li>
</ul>
<p><strong>举例2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">//伪代码</span><br><span class="line">volatile boolean flag = false;</span><br><span class="line">    //线程1</span><br><span class="line">    prepare();</span><br><span class="line"></span><br><span class="line">    flag = false;</span><br><span class="line"></span><br><span class="line">    //线程2</span><br><span class="line">    while(!flag)&#123;</span><br><span class="line">        sleep();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //基于准备好的资源进行操作</span><br><span class="line">    execute();</span><br></pre></td></tr></table></figure>

<p>这8条原则是避免说出现乱七八糟扰乱秩序的指令重排，要求是这几个重要的场景下，比如是按照顺序来，但是8条规则之外，可以随意重排指令。</p>
<p>比如这个例子，如果用volatile来修饰flag变量，一定可以让prepare()指令在flag &#x3D; true之前先执行，这就禁止了指令重排。</p>
<p>因为volatile要求的是，volatile前面的代码一定不能指令重排到volatile变量操作后面，volatile后面的代码也不能指令重排到volatile前面。</p>
<h1 id="volatile-2"><a href="#volatile-2" class="headerlink" title="volatile"></a>volatile</h1><p>volatile不保证原子性，只保证可见性和禁止指令重排</p>
<h2 id="CPU术语介绍"><a href="#CPU术语介绍" class="headerlink" title="CPU术语介绍"></a>CPU术语介绍</h2><p><a target="_blank" rel="noopener" href="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0011.png"><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0011.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private static volatile SingletonDemo instance = null;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 执行单例构造函数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo getInstance()&#123;</span><br><span class="line"></span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            synchronized (SingletonDemo.class)&#123;</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                    instance = new SingletonDemo(); //pos_1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>pos_1处的代码转换成汇编代码如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">0x01a3de1d: movb $0×0,0×1104800(%esi);</span><br><span class="line">0x01a3de24: lock addl $0×0,(%esp);</span><br></pre></td></tr></table></figure>

<h2 id="volatile保证可见性原理"><a href="#volatile保证可见性原理" class="headerlink" title="volatile保证可见性原理"></a>volatile保证可见性原理</h2><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架 构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情。</p>
<p>1）将当前处理器缓存行的数据写回到系统内存。</p>
<p>2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</p>
<p> 为了提高处理速度，处理器不直接和主内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的 变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现MESI缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<blockquote>
<p>注意：lock前缀指令是同时保证可见性和有序性（也就是禁止指令重排）的</p>
</blockquote>
<blockquote>
<p>注意：lock前缀指令相当于一个内存屏障【后文讲】</p>
</blockquote>
<h2 id="volatile禁止指令重排的原理"><a href="#volatile禁止指令重排的原理" class="headerlink" title="volatile禁止指令重排的原理"></a>volatile禁止指令重排的原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class VolatileExample &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    volatile boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a = 1; // step 1</span><br><span class="line">        flag = true; // step 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        if (flag) &#123; // step 3</span><br><span class="line">            System.out.println(a); // step 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JSR-133之前的旧的Java内存模型中，是允许volatile变量与普通变量重排序的。那上面的案例中，可能就会被重排序成下列时序来执行：</p>
<ol>
<li>线程A写volatile变量，step 2，设置flag为true；</li>
<li>线程B读同一个volatile，step 3，读取到flag为true；</li>
<li>线程B读普通变量，step 4，读取到 a &#x3D; 0；</li>
<li>线程A修改普通变量，step 1，设置 a &#x3D; 1；</li>
</ol>
<p>可见，如果volatile变量与普通变量发生了重排序，虽然volatile变量能保证内存可见性，也可能导致普通变量读取错误。</p>
<p>所以在旧的内存模型中，volatile的写-读就不能与锁的释放-获取具有相同的内存语义了。为了提供一种比锁更轻量级的<strong>线程间的通信机制</strong>，<strong>JSR-133</strong>专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序。</p>
<p>编译器还好说，JVM是怎么还能限制处理器的重排序的呢？它是通过<strong>内存屏障</strong>来实现的。</p>
<p>什么是内存屏障？硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：</p>
<ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区&#x2F;高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。</li>
</ol>
<blockquote>
<p>注意这里的缓存主要指的是上文说的CPU缓存，如L1，L2等</p>
</blockquote>
<h3 id="保守策略下"><a href="#保守策略下" class="headerlink" title="保守策略下"></a>保守策略下</h3><ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的前面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p>编译器在<strong>生成字节码时</strong>，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个<strong>比较保守的JMM内存屏障插入策略</strong>，但它可以保证在任意处理器平台，任意的程序中都能 得到正确的volatile内存语义。</p>
<blockquote>
<p>再逐个解释一下这几个屏障。注：下述Load代表读操作，Store代表写操作</p>
<p><strong>LoadLoad屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br><strong>StoreStore屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，这个屏障会吧Store1强制刷新到内存，保证Store1的写入操作对其它处理器可见。<br><strong>LoadStore屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br><strong>StoreLoad屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</p>
</blockquote>
<p>对于连续多个volatile变量读或者连续多个volatile变量写，编译器做了一定的优化来提高性能，比如：</p>
<blockquote>
<p>第一个volatile读;</p>
<p>LoadLoad屏障；</p>
<p>第二个volatile读；</p>
<p>LoadStore屏障</p>
</blockquote>
<p><strong>1、下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图</strong></p>
<p><a target="_blank" rel="noopener" href="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0012.png"><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0012.png" alt="img"></a></p>
<blockquote>
<p>图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任 意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。这里比较有意思的是，volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与 后面可能有的volatile读&#x2F;写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面 是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确 实现volatile的内存语义，JMM在采取了保守策略：在每个volatile写的后面，或者在每个volatile 读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM最终选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个 写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时， 选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率</p>
</blockquote>
<p><strong>2、下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图</strong></p>
<p><a target="_blank" rel="noopener" href="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0013.png"><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0013.png" alt="img"></a></p>
<blockquote>
<p>图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。 LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。 上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p>
</blockquote>
<p><strong>优化举例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">class VolatileBarrierExample &#123;</span><br><span class="line">        int a;</span><br><span class="line">        volatile int v1 = 1;</span><br><span class="line">        volatile int v2 = 2;</span><br><span class="line"></span><br><span class="line">        void readAndWrite() &#123;</span><br><span class="line">            int i = v1; // 第一个volatile读</span><br><span class="line">            int j = v2; // 第二个volatile读</span><br><span class="line">            a = i + j; // 普通写</span><br><span class="line">            v1 = i + 1; // 第一个volatile写</span><br><span class="line">            v2 = j * 2; // 第二个 volatile写</span><br><span class="line">        &#125;</span><br><span class="line">        // 其他方法 &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化</p>
<p><a target="_blank" rel="noopener" href="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0014.png"><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0014.png" alt="img"></a></p>
<p> 注意，最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。此时编译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器通常会在这里插入一个StoreLoad屏障。</p>
<p> 上面的优化针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以X86处理器为例，图中除最后的StoreLoad屏障外，其他的屏障都会被省略。</p>
<h3 id="X86处理器优化"><a href="#X86处理器优化" class="headerlink" title="X86处理器优化"></a>X86处理器优化</h3><p>前面保守策略下的volatile读和写，在X86处理器平台可以优化成如下图所示。</p>
<p>X86处理器仅会对写-读操作做重排序。X86不会对读-读、读-写和写-写操作 做重排序，因此在X86处理器中会省略掉这3种操作类型对应的内存屏障。在X86中，JMM仅需在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在X86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。</p>
<p><a target="_blank" rel="noopener" href="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0015.png"><img src="https://upyunimg.imlql.cn/youthlql@1.0.8/Java_concurrency/Source_code/Second_stage/0015.png" alt="img"></a></p>
<h2 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h2><blockquote>
<p>下面的代码在前面可能已经写过了，这里总结一下</p>
</blockquote>
<p>从volatile的内存语义上来看，volatile可以保证内存可见性且禁止重排序。</p>
<p>在保证内存可见性这一点上，volatile有着与锁相同的内存语义，所以可以作为一个“轻量级”的锁来使用。但由于volatile仅仅保证对单个volatile变量的读&#x2F;写具有原子性，而锁可以保证整个<strong>临界区代码</strong>的执行具有原子性。所以<strong>在功能上，锁比volatile更强大；在性能上，volatile更有优势</strong>。</p>
<p>在禁止重排序这一点上，volatile也是非常有用的。比如我们熟悉的单例模式，其中有一种实现方式是“双重锁检查”，比如这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance; // 不使用volatile关键字</span><br><span class="line"></span><br><span class="line">    // 双重锁检验</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123; // 第7行</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton(); // 第10行</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这里的变量声明不使用volatile关键字，是可能会发生错误的。它可能会被重排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">instance = new Singleton(); // 第10行</span><br><span class="line"></span><br><span class="line">// 可以分解为以下三个步骤</span><br><span class="line">1 memory=allocate();// 分配内存 相当于c的malloc</span><br><span class="line">2 ctorInstanc(memory) //初始化对象</span><br><span class="line">3 s=memory //设置s指向刚分配的地址</span><br><span class="line"></span><br><span class="line">// 上述三个步骤可能会被重排序为 1-3-2，也就是：</span><br><span class="line">1 memory=allocate();// 分配内存 相当于c的malloc</span><br><span class="line">3 s=memory //设置s指向刚分配的地址</span><br><span class="line">2 ctorInstanc(memory) //初始化对象</span><br></pre></td></tr></table></figure>

<p>而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候另一个线程B执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！</p>
<p>所以JSR-133对volatile做了增强后，volatile的禁止重排序功能还是非常有用的。</p>
<h1 id="中断-1"><a href="#中断-1" class="headerlink" title="中断"></a>中断</h1><h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><p>首先<br>一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。<br>所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。</p>
<p>其次<br>在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。<br>因此，Java提供了一种用于停止线程的机制——中断。</p>
<p>中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。<br>若要中断一个线程，你需要手动调用该线程的interrupt方法，该方法也仅仅是将线程对象的中断标识设成true；<br>接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，<br>此时究竟该做什么需要你自己写代码实现。</p>
<p>每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；<br>通过调用线程对象的interrupt方法将该线程的标识位设为true；可以在别的线程中调用，也可以在自己的线程中调用。</p>
<h2 id="中断API"><a href="#中断API" class="headerlink" title="中断API"></a>中断API</h2><p><img src="/../images/image-20220801225150940.png" alt="image-20220801225150940"></p>
<h2 id="如何停止线程"><a href="#如何停止线程" class="headerlink" title="如何停止线程"></a>如何停止线程</h2><h3 id="使用中断标志位"><a href="#使用中断标志位" class="headerlink" title="使用中断标志位"></a>使用中断标志位</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.ggq.juc.interrupt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreeApi</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//                System.out.println(&quot;线程执行&quot;);</span></span><br><span class="line">                <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;   <span class="comment">// 线程自己实现中断</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程中断&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程执行&quot;</span>);</span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    TimeUnit.SECONDS.sleep(1);</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line">               	  	<span class="comment">//Thread.currentThread().interrupt();  错误1 不加这行, 错误2 加</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();// 抛出(注意这里代码是catch 异常已抛出过了)这个异常时 标志位变为false了 </span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;*************&quot;</span>+t1.isInterrupted());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;*************&quot;</span>+t1.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">正常结果</span><br><span class="line">*************<span class="literal">false</span></span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br><span class="line">*************<span class="literal">true</span></span><br><span class="line">线程中断</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 错误结果1(如果线程被block) + sleep</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抛出异常后 线程会一直执行</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20220801232842328.png" alt="image-20220801232842328"></p>
<blockquote>
<p> 错误结果2 抛出异常 但线程关闭 添加捕获异常时的中断</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部分源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>); <span class="comment">// 返回当前 状态 并设为 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法 若线程被处于阻塞 会抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>interrupt方法源码注释</p>
<p><img src="/../images/image-20220801232118710.png" alt="image-20220801232118710"></p>
<p>sleep</p>
<p><img src="/../images/image-20220801232929385.png" alt="image-20220801232929385"></p>
<h2 id="优雅的关闭-使用-volatile-Boolean"><a href="#优雅的关闭-使用-volatile-Boolean" class="headerlink" title="(优雅的关闭)使用 volatile Boolean"></a>(优雅的关闭)使用 volatile Boolean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vol</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">    			<span class="comment">//do</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="使用AutomaticBoolean"><a href="#使用AutomaticBoolean" class="headerlink" title="使用AutomaticBoolean"></a>使用AutomaticBoolean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ato</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(flag.get()) &#123;</span><br><span class="line">                <span class="comment">//do</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        flag.set(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p>
<p>下面这句话，后面详细说<br>LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程</p>
<h2 id="3种让线程等待和唤醒的方法"><a href="#3种让线程等待和唤醒的方法" class="headerlink" title="3种让线程等待和唤醒的方法"></a>3种让线程等待和唤醒的方法</h2><p>方式1：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</p>
<blockquote>
<p>创建一个对象作为锁对象 </p>
<p>Object类中的wait、notify、notifyAll用于线程等待和唤醒的方法，都必须在synchronized内部执行（必须用到关键字synchronized）。</p>
<p>先wait后notify才OK</p>
</blockquote>
<p>方式2：使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</p>
<blockquote>
<p>Lock lock &#x3D; new ReentrantLock(); </p>
<p>lock.lock(); lock.unlock();</p>
<p>线程先要获得并持有锁，必须在锁块(synchronized或lock)中 </p>
<p>必须要先等待后唤醒，线程才能够被唤醒</p>
</blockquote>
<p>以上两种 使用不当 会有非法monitor状态异常</p>
<p>方式3：LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</p>
<blockquote>
<p>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能， 每个线程都有一个许可(permit)，<br>permit只有两个值1和零，默认是零。<br>可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1。默认0</p>
</blockquote>
<p>park 把什么搁置 设为0 不许可 阻塞当前线程</p>
<p>unpark(t) 设为1 可执行 唤醒 t 不会抛什么异常	\</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            LockSupport.park(); <span class="comment">//执行park无效</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+System.currentTimeMillis()+<span class="string">&quot;---被叫醒&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(t1); <span class="comment">// 先执行</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+System.currentTimeMillis()+<span class="string">&quot;---unpark over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20220802001433244.png" alt="image-20220802001433244"></p>
<h1 id="聊聊ThreadLocal"><a href="#聊聊ThreadLocal" class="headerlink" title="聊聊ThreadLocal"></a>聊聊ThreadLocal</h1><p>ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。</p>
<p> 实现每一个线程都有自己专属的本地变量副本(自己用自己的变量不麻烦别人，不和其他人共享，人人有份，人各一份)，</p>
<p>主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。</p>
<p><img src="/../images/EFEED11B-FD2D-48A5-B8C6-256F5C64A354.png" alt="img"></p>
<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><p>1 群雄逐鹿起纷争</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovieTicket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">saleTicket</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span>(number &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;号售票员卖出第： &quot;</span>+(number--));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------卖完了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-03-23 15:03</span></span><br><span class="line"><span class="comment"> * 三个售票员卖完50张票务，总量完成即可，吃大锅饭，售票员每个月固定月薪</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MovieTicket</span> <span class="variable">movieTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MovieTicket</span>();</span><br><span class="line">		<span class="comment">//新建三个线程.start</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i <span class="number">3</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j <span class="number">20</span>; j++) &#123;</span><br><span class="line">                    movieTicket.saleTicket();</span><br><span class="line">                    <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>); &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>2 凭本事拿提成(人手一份天下安)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc.tl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovieTicket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">saleTicket</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(number &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;号售票员卖出第： &quot;</span>+(number--));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------卖完了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">House</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saleHouse</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        value++;</span><br><span class="line">		threadLocal.set(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-03-23 15:03</span></span><br><span class="line"><span class="comment"> * 1  三个售票员卖完50张票务，总量完成即可，吃大锅饭，售票员每个月固定月薪</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"> * 2  分灶吃饭，各个销售自己动手，丰衣足食</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/*MovieTicket movieTicket = new MovieTicket();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (int i = 1; i             new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">                for (int j = 0; j                     movieTicket.saleTicket();</span></span><br><span class="line"><span class="comment">                    try &#123; TimeUnit.MILLISECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;,String.valueOf(i)).start();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===========================================</span></span><br><span class="line"><span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i <span class="number">3</span>; i++) &#123;</span><br><span class="line">		house.saleHouse();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---&quot;</span>+house.threadLocal.get());</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">house.threadLocal.remove();<span class="comment">//如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">house.saleHouse();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---&quot;</span>+house.threadLocal.get());</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">				house.threadLocal.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">house.saleHouse();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---&quot;</span>+house.threadLocal.get());</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">house.threadLocal.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---&quot;</span>+house.threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结</p>
<p>统一设置初始值，但是每个线程对这个值的修改都是各自线程互相独立的</p>
<p>如何才能不争抢</p>
<p>​	1 加入synchronized或者Lock控制资源的访问顺序</p>
<p>​	2 人手一份，大家各自安好，没必要抢夺</p>
<p>​	</p>
<h1 id="由浅入深Java多线程"><a href="#由浅入深Java多线程" class="headerlink" title="由浅入深Java多线程"></a>由浅入深Java多线程</h1><h2 id="第一章-进程与线程的基本概念"><a href="#第一章-进程与线程的基本概念" class="headerlink" title="第一章 进程与线程的基本概念"></a>第一章 进程与线程的基本概念</h2><p>程序有时会由于I&#x2F;O操作、网络等原因阻塞，所以批处理操作效率也不高。</p>
<p>进程解决了批处理系统时只能存在一个程序问题(单核并发)</p>
<p>线程解决了进程在一段时间只能做一件事情(如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率。)</p>
<p>进程让操作系统的并发性成为了可能,线程让进程的并发成为了可能</p>
<p><strong>多进程也可以实现并发,为什么我们要使用多线程</strong></p>
<ul>
<li>进程间通信比较复杂,通常我们需要共享资源,这些资源在线程间通信比较简单</li>
<li>进程是重量级</li>
</ul>
<p>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。上下文切换通常是计算密集型的，意味着此操作会消耗大量的 CPU 时间，故线程也不是越多越好。如何减少系统中上下文切换次数，是提升多线程性能的一个重点课题。</p>
<p><strong>区别</strong></p>
<p>是否单独占有内存地址空间及其它系统资源（比如I&#x2F;O）</p>
<p>进程间内存隔离,数据共享复杂,但是同步简单 线程则相反</p>
<p>一个进程出现问题不会影响其他进程,而线程则不同</p>
<p>进程创建不仅需要寄存器和栈信息,还需要资源的分配回收以及页调度,线程只需要保存寄存器和栈信息</p>
<p>另外一个重要区别是进程是操作系统进行资源分配的基本单位,而线程是os进行调度的基本单位即cpu分配时间的单位</p>
<h2 id="第二章-Java多线程入门类和接口"><a href="#第二章-Java多线程入门类和接口" class="headerlink" title="第二章 Java多线程入门类和接口"></a>第二章 Java多线程入门类和接口</h2><h3 id="2-1-Thread类和Runnable接口"><a href="#2-1-Thread类和Runnable接口" class="headerlink" title="2.1 Thread类和Runnable接口"></a>2.1 Thread类和Runnable接口</h3><blockquote>
<p>我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。</p>
<p>注意不可多次调用start()方法。在第一次调用start()方法后，再次调用start()方法会抛出异常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runable可函数式编程</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(<span class="string">&quot;Java 8 匿名内部类&quot;</span>);        &#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Thread类构造⽅法"><a href="#Thread类构造⽅法" class="headerlink" title="Thread类构造⽅法"></a>Thread类构造⽅法</h3><p>查看 Thread 类的构造⽅法，发现其实是简单调⽤⼀个私有的 init ⽅法来实现初 始化。 init 的⽅法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread类源码</span></span><br><span class="line"><span class="comment">// ⽚段1 - init⽅法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params"> <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params"><span class="type">boolean</span> inheritThreadLocals)</span></span><br><span class="line"><span class="comment">// ⽚段2 - 构造函数调⽤init⽅法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line"> init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ⽚段3 - 使⽤在init⽅法⾥初始化AccessControlContext类型的私有属性</span></span><br><span class="line"><span class="built_in">this</span>.inheritedAccessControlContext =</span><br><span class="line"> acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line"><span class="comment">// ⽚段4 - 两个对⽤于⽀持ThreadLocal的私有属性</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>inheritThreadLocals：可继承的 ThreadLocal ，⻅⽚段4， Thread 类⾥⾯有两 个私有属性来⽀持 ThreadLocal ，我们会在后⾯的章节介绍 ThreadLocal 的概 念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable target)</span><br><span class="line">Thread(Runnable target, String name)</span><br></pre></td></tr></table></figure>



<h3 id="Thread类的⼏个常⽤⽅法"><a href="#Thread类的⼏个常⽤⽅法" class="headerlink" title="Thread类的⼏个常⽤⽅法"></a>Thread类的⼏个常⽤⽅法</h3><p>这⾥介绍⼀下Thread类的⼏个常⽤的⽅法：</p>
<ul>
<li><p>currentThread()：静态⽅法，返回对当前正在执⾏的线程对象的引⽤； </p>
</li>
<li><p>start()：开始执⾏线程的⽅法，java虚拟机会调⽤线程内的run()⽅法； </p>
</li>
<li><p>yield()：yield在英语⾥有放弃的意思，同样，这⾥的yield()指的是当前线程愿 意让出对当前处理器的占⽤。这⾥需要注意的是，就算当前线程调⽤了yield() ⽅法，程序在调度的时候，也还有可能继续运⾏这个线程的； </p>
</li>
<li><p>sleep()：静态⽅法，使当前线程睡眠⼀段时间；</p>
</li>
<li><p>join()：使当前线程等待另⼀个线程执⾏完毕之后再继续执⾏，内部调⽤的是 Object类的wait⽅法实现的；</p>
</li>
</ul>
<h3 id="Thread类与Runnable接⼝的⽐较"><a href="#Thread类与Runnable接⼝的⽐较" class="headerlink" title="Thread类与Runnable接⼝的⽐较"></a>Thread类与Runnable接⼝的⽐较</h3><ul>
<li>由于Java“单继承，多实现”的特性，Runnable接⼝使⽤起来⽐Thread更灵活。</li>
<li>Runnable接⼝出现更符合⾯向对象，将线程单独进⾏对象的封装</li>
<li>Runnable接⼝出现，降低了线程对象和线程任务的耦合性。 </li>
<li>如果使⽤线程时不需要使⽤Thread类的诸多⽅法，显然使⽤Runnable接⼝更 为轻量。 </li>
<li>所以，我们通常优先使⽤“实现 Runnable 接⼝”这种⽅式来⾃定义线程类。</li>
</ul>
<h3 id="Callable、Future与FutureTask-异步模型"><a href="#Callable、Future与FutureTask-异步模型" class="headerlink" title="Callable、Future与FutureTask 异步模型"></a>Callable、Future与FutureTask 异步模型</h3><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line"> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那⼀般是怎么使⽤ Callable 的呢？ Callable ⼀般是配合线程池⼯ 具 ExecutorService 来使⽤的。我们会在后续章节解释线程池的使⽤。这⾥只介 绍 ExecutorService 可以使⽤ submit ⽅法来让⼀个 Callable 接⼝执⾏。它会返回 ⼀个 Future ，我们后续的程序可以通过这个 Future 的 get ⽅法得到结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⾃定义Callable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="comment">// 模拟计算需要⼀秒</span></span><br><span class="line"> Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"> <span class="comment">// 使⽤</span></span><br><span class="line"> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"> <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"> Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line"> <span class="comment">// 注意调⽤get⽅法会阻塞当前线程，直到得到结果。</span></span><br><span class="line"> <span class="comment">// 所以实际编码中建议使⽤可以设置超时时间的重载get⽅法。</span></span><br><span class="line"> System.out.println(result.get());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> paramBoolean)</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title function_">get</span><span class="params">(<span class="type">long</span> paramLong, TimeUnit paramTimeUnit)</span></span><br><span class="line"> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cancel ⽅法是试图取消⼀个线程的执⾏。 注意是试图取消，并不⼀定能取消成功。因为任务可能已完成、已取消、或者⼀些 其它因素不能取消，存在取消失败的可能。 boolean 类型的返回值是“是否取消成 功”的意思。参数 paramBoolean 表示是否采⽤中断的⽅式取消线程执⾏。 所以有时候，为了让任务有能够取消的功能，就使⽤ Callable 来代替 Runnable 。 如果为了可取消性⽽使⽤ Future 但⼜不提供可⽤的结果，则可以声明 Future 形式类型、并返回 null 作为底层任务的结果。</p>
<h4 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h4><p>上⾯介绍了 Future 接⼝。这个接⼝有⼀个实现类叫 FutureTask 。 FutureTask 是 实现的 RunnableFuture 接⼝的，⽽ RunnableFuture 接⼝同时继承了 Runnable 接⼝ 和 Future 接⼝：</p>
<p>在很多⾼并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能 够在⾼并发环境下确保任务只执⾏⼀次</p>
<h2 id="第三章-线程组和线程优先级"><a href="#第三章-线程组和线程优先级" class="headerlink" title="第三章 线程组和线程优先级"></a>第三章 线程组和线程优先级</h2><p>Java中的优先级来说不是特别的可靠，Java程序中对线程所设置的优先级只是给 操作系统⼀个建议，操作系统不⼀定会采纳。⽽真正的调⽤顺序，是由操作系统的 线程调度算法决定的</p>
<p>Java提供⼀个线程调度器来监视和控制处于RUNNABLE状态的线程。线程的调度 策略采⽤抢占式，优先级⾼的线程⽐优先级低的线程会有更⼤的⼏率优先执⾏。在 优先级相同的情况下，按照“先到先得”的原则。每个Java程序都有⼀个默认的主线 程，就是通过JVM启动的第⼀个线程main线程。</p>
<p>所以，如果某个线程优先级⼤于线程所在线程组的最⼤优先级，那么该线程的优先 级将会失效，取⽽代之的是线程组的最⼤优先级。</p>
<blockquote>
<p>Thread.currentThread().getThreadGroup().getName()</p>
</blockquote>
<blockquote>
<p>todo </p>
</blockquote>
<h2 id="第四章-Java线程的状态及主要转换方法"><a href="#第四章-Java线程的状态及主要转换方法" class="headerlink" title="第四章 Java线程的状态及主要转换方法"></a>第四章 Java线程的状态及主要转换方法</h2><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><h4 id="os"><a href="#os" class="headerlink" title="os"></a>os</h4><p>五状态<br>    新建 就绪 运行 等待 终止</p>
<p><img src="/../images/image-20220922112957488.png" alt="image-20220922112957488"></p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><p>6状态</p>
<pre><code>1. NEW 还未调用start方法
2. RUNABLE表示当前线程正在运行中. 线程在JVM运行,也有可能在等待其他系统资源如IO 包含了os的就绪与运行
3. BLOCKED 阻塞状态 等待锁的释放以进入同步区
4. WAITING 等待状态 被唤醒进入RUNABLE
5. TIMEED_WAITING 限定时间的等待,自动唤醒
6. 终止状态 线程执行完毕
</code></pre>
<p><img src="/../images/image-20220922113059252.png" alt="image-20220922113059252"></p>
<h4 id="4-3-4线程中断"><a href="#4-3-4线程中断" class="headerlink" title="4.3.4线程中断"></a>4.3.4线程中断</h4><h2 id="第五章-Java线程间的通信"><a href="#第五章-Java线程间的通信" class="headerlink" title="第五章 Java线程间的通信"></a>第五章 Java线程间的通信</h2><h2 id="第六章-Java内存模型基础知识"><a href="#第六章-Java内存模型基础知识" class="headerlink" title="第六章 Java内存模型基础知识"></a>第六章 Java内存模型基础知识</h2><h2 id="第七章-重排序与happens-before"><a href="#第七章-重排序与happens-before" class="headerlink" title="第七章 重排序与happens-before"></a>第七章 重排序与happens-before</h2><h2 id="第八章-volatile"><a href="#第八章-volatile" class="headerlink" title="第八章 volatile"></a>第八章 volatile</h2><h2 id="第九章-synchronized与锁"><a href="#第九章-synchronized与锁" class="headerlink" title="第九章 synchronized与锁"></a>第九章 synchronized与锁</h2><p>synchronized为什么是重量级锁</p>
<h2 id="第十章-乐观锁和悲观锁"><a href="#第十章-乐观锁和悲观锁" class="headerlink" title="第十章 乐观锁和悲观锁"></a>第十章 乐观锁和悲观锁</h2><h2 id="第十一章-AQS"><a href="#第十一章-AQS" class="headerlink" title="第十一章 AQS"></a>第十一章 AQS</h2><h2 id="第十二章-线程池原理"><a href="#第十二章-线程池原理" class="headerlink" title="第十二章 线程池原理"></a>第十二章 线程池原理</h2><h3 id="12-1为什么要使用线程池"><a href="#12-1为什么要使用线程池" class="headerlink" title="12.1为什么要使用线程池"></a>12.1为什么要使用线程池</h3><ol>
<li>创建&#x2F;销毁线程需要消耗系统资源,线程池可复用已创建的线程</li>
<li>控制并发数量(主要原因),并发数量过多可能会导致资源消耗过多导致服务器崩溃</li>
<li>可以对线程做统一管理</li>
</ol>
<h3 id="12-2-线程池原理"><a href="#12-2-线程池原理" class="headerlink" title="12.2 线程池原理"></a>12.2 线程池原理</h3><p>线程池顶层接口是Executor,TreadPoolExecutor是实现类</p>
<h4 id="12-2-1-ThreadPoolExecutor提供的构造方法"><a href="#12-2-1-ThreadPoolExecutor提供的构造方法" class="headerlink" title="12.2.1 ThreadPoolExecutor提供的构造方法"></a>12.2.1 ThreadPoolExecutor提供的构造方法</h4><p>一共四个构造方法 </p>
<p>涉及到5~7个参数</p>
<p>都有的 5 个</p>
<ol>
<li>核心线程数</li>
<li>最大线程数</li>
<li>非核心线程闲置超时时长</li>
<li>时长单位</li>
<li>阻塞队列,维护等待执行的Runnable任务对象</li>
</ol>
<p>两个非必须参数</p>
<ol>
<li>指定线程工厂<ol>
<li>默认defaultThreadFactory</li>
</ol>
</li>
<li>拒绝处理策略<ol>
<li>线程数量大于最大线程数就会采用拒绝处理策略<ol>
<li>默认AbortPolicy 丢弃任务并抛出异常</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="第十三章-阻塞队列"><a href="#第十三章-阻塞队列" class="headerlink" title="第十三章 阻塞队列"></a>第十三章 阻塞队列</h2><h2 id="第十四章-锁接口和类"><a href="#第十四章-锁接口和类" class="headerlink" title="第十四章 锁接口和类"></a>第十四章 锁接口和类</h2><h2 id="第十五章-并发集合容器简介"><a href="#第十五章-并发集合容器简介" class="headerlink" title="第十五章 并发集合容器简介"></a>第十五章 并发集合容器简介</h2><h2 id="第十六章-CopyOnwrite"><a href="#第十六章-CopyOnwrite" class="headerlink" title="第十六章 CopyOnwrite"></a>第十六章 CopyOnwrite</h2><h2 id="第十七章-通信工具类"><a href="#第十七章-通信工具类" class="headerlink" title="第十七章 通信工具类"></a>第十七章 通信工具类</h2><h2 id="第十八章-Fork-x2F-Join框架"><a href="#第十八章-Fork-x2F-Join框架" class="headerlink" title="第十八章 Fork&#x2F;Join框架"></a>第十八章 Fork&#x2F;Join框架</h2><h2 id="第十九章-Java8-Stream并行计算原理"><a href="#第十九章-Java8-Stream并行计算原理" class="headerlink" title="第十九章 Java8 Stream并行计算原理"></a>第十九章 Java8 Stream并行计算原理</h2><h2 id="第二十章-计划任务"><a href="#第二十章-计划任务" class="headerlink" title="第二十章 计划任务"></a>第二十章 计划任务</h2><h2 id><a href="#" class="headerlink" title></a></h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io">ggq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io/2022/10/09/8JUC/">https://gouguoqiang.github.io/2022/10/09/8JUC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gouguoqiang.github.io" target="_blank">ggq</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6java%E6%A8%A1%E6%9D%BF/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一. 基础知识Java模板</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ggq</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">使用线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">线程常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.</span> <span class="toc-text">Java中的线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">基础线程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor"><span class="toc-number">1.3.1.</span> <span class="toc-text">Executor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8C"><span class="toc-number">2.</span> <span class="toc-text">多线程二</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">提高效率的方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%AD%98%E5%82%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">2.1.1.</span> <span class="toc-text">2存储子系统重排序：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-synchronize"><span class="toc-number">2.2.</span> <span class="toc-text">volatile  synchronize</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">2.2.1.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronize"><span class="toc-number">2.2.2.</span> <span class="toc-text">synchronize</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%99%A8AQS"><span class="toc-number">2.3.</span> <span class="toc-text">同步器AQS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM%EF%BC%88Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">JMM（Java内存模型)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%A0%B8CPU%E4%B8%8E%E5%A4%9A%E6%A0%B8CPU%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.1.</span> <span class="toc-text">单核CPU与多核CPU的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">并行与并发的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Runnable%E6%8E%A5%E5%8F%A3%E6%9E%84%E9%80%A0%E7%BA%BF%E7%A8%8B%E6%BA%90%E7%A0%81"><span class="toc-number">3.2.1.</span> <span class="toc-text">Runnable接口构造线程源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E7%B1%BB%E6%9E%84%E9%80%A0%E7%BA%BF%E7%A8%8B%E6%BA%90%E7%A0%81"><span class="toc-number">3.2.2.</span> <span class="toc-text">Thread类构造线程源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9B%B4%E8%A7%82%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">最直观的代码描述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%9C%A8Thread%E5%92%8CRunnable%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">策略模式在Thread和Runnable中的应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Thread%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">Thread的构造方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#start-%E6%BA%90%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">start()源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8D%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8run-%E8%80%8C%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8start-%E5%91%A2"><span class="toc-number">6.1.</span> <span class="toc-text">为什么线程的启动不直接使用run()而必须使用start()呢?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">7.</span> <span class="toc-text">线程生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">一个Java程序有哪些线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%94%A8%E5%A4%84-%E5%8F%91%E9%80%81%E5%BF%83%E8%B7%B3"><span class="toc-number">8.1.</span> <span class="toc-text">守护线程用处(发送心跳)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#join%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">join方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">10.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">几个方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8Ftip"><span class="toc-number">10.2.</span> <span class="toc-text">小tip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E9%9A%BE%E7%82%B9"><span class="toc-number">10.3.</span> <span class="toc-text">重难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">并发编程中的三个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">11.1.</span> <span class="toc-text">可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.1.</span> <span class="toc-text">可见性概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E6%BC%94%E7%A4%BA"><span class="toc-number">11.1.2.</span> <span class="toc-text">可见性演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">11.2.</span> <span class="toc-text">原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E6%A6%82%E5%BF%B5"><span class="toc-number">11.2.1.</span> <span class="toc-text">原子性概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E6%BC%94%E7%A4%BA"><span class="toc-number">11.2.2.</span> <span class="toc-text">原子性演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">11.3.</span> <span class="toc-text">有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7%E6%A6%82%E5%BF%B5"><span class="toc-number">11.3.1.</span> <span class="toc-text">有序性概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7%E6%BC%94%E7%A4%BA"><span class="toc-number">11.3.2.</span> <span class="toc-text">有序性演示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#volatile-1"><span class="toc-number">12.</span> <span class="toc-text">volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BB%A3%E7%A0%81"><span class="toc-number">12.1.</span> <span class="toc-text">volatile保证可见性代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%E4%BB%A3%E7%A0%81"><span class="toc-number">12.2.</span> <span class="toc-text">volatile保证有序性代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS"><span class="toc-number">13.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">CAS 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AtomicInteger"><span class="toc-number">13.2.</span> <span class="toc-text">AtomicInteger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">13.3.</span> <span class="toc-text">CAS 代码演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="toc-number">13.4.</span> <span class="toc-text">CAS三大问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="toc-number">13.5.</span> <span class="toc-text">ABA问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFABA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">13.5.1.</span> <span class="toc-text">什么是ABA问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">13.5.2.</span> <span class="toc-text">ABA问题的解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">13.6.</span> <span class="toc-text">只能保证一个共享变量的原子操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UnSafe"><span class="toc-number">14.</span> <span class="toc-text">UnSafe</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Unsafe"><span class="toc-number">14.1.</span> <span class="toc-text">获取Unsafe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E7%9B%B8%E5%85%B3"><span class="toc-number">14.2.</span> <span class="toc-text">CAS相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E9%87%8F%E7%9B%B8%E5%85%B3"><span class="toc-number">14.3.</span> <span class="toc-text">偏移量相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">14.4.</span> <span class="toc-text">类加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%AF%BB%E5%86%99"><span class="toc-number">14.5.</span> <span class="toc-text">普通读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD-1"><span class="toc-number">14.6.</span> <span class="toc-text">类加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">14.7.</span> <span class="toc-text">内存屏障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">14.8.</span> <span class="toc-text">线程调度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized%E4%BC%98%E5%8C%96"><span class="toc-number">15.</span> <span class="toc-text">synchronized优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">15.1.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">15.2.</span> <span class="toc-text">锁粗化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">15.3.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">15.4.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E6%80%A7%E9%94%81"><span class="toc-number">15.5.</span> <span class="toc-text">适应性锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">16.</span> <span class="toc-text">指令重排</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">16.1.</span> <span class="toc-text">为什么指令重排序可以提高性能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#as-if-serial%E8%AF%AD%E4%B9%89"><span class="toc-number">16.2.</span> <span class="toc-text">as-if-serial语义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM"><span class="toc-number">17.</span> <span class="toc-text">Java内存模型(JMM)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84"><span class="toc-number">17.1.</span> <span class="toc-text">计算机结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B"><span class="toc-number">17.1.1.</span> <span class="toc-text">计算机结构简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU"><span class="toc-number">17.1.2.</span> <span class="toc-text">CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">17.1.3.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">17.1.4.</span> <span class="toc-text">缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.2.</span> <span class="toc-text">Java内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%85%E5%AD%98%E4%B8%8EJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">17.3.</span> <span class="toc-text">CPU缓存，内存与Java内存模型的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">17.4.</span> <span class="toc-text">再谈可见性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">18.</span> <span class="toc-text">主内存与工作内存之间的交互</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#happens-before"><span class="toc-number">19.</span> <span class="toc-text">happens-before</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFhappens-before"><span class="toc-number">19.1.</span> <span class="toc-text">什么是happens-before?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A9%E7%84%B6%E7%9A%84happens-before%E5%85%B3%E7%B3%BB"><span class="toc-number">19.2.</span> <span class="toc-text">天然的happens-before关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#volatile-2"><span class="toc-number">20.</span> <span class="toc-text">volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E6%9C%AF%E8%AF%AD%E4%BB%8B%E7%BB%8D"><span class="toc-number">20.1.</span> <span class="toc-text">CPU术语介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">20.2.</span> <span class="toc-text">volatile保证可见性原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">20.3.</span> <span class="toc-text">volatile禁止指令重排的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AE%88%E7%AD%96%E7%95%A5%E4%B8%8B"><span class="toc-number">20.3.1.</span> <span class="toc-text">保守策略下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X86%E5%A4%84%E7%90%86%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-number">20.3.2.</span> <span class="toc-text">X86处理器优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">20.4.</span> <span class="toc-text">volatile的用途</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD-1"><span class="toc-number">21.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">21.1.</span> <span class="toc-text">什么是中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%ADAPI"><span class="toc-number">21.2.</span> <span class="toc-text">中断API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.3.</span> <span class="toc-text">如何停止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%AD%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">21.3.1.</span> <span class="toc-text">使用中断标志位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E7%9A%84%E5%85%B3%E9%97%AD-%E4%BD%BF%E7%94%A8-volatile-Boolean"><span class="toc-number">21.4.</span> <span class="toc-text">(优雅的关闭)使用 volatile Boolean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8AutomaticBoolean"><span class="toc-number">21.5.</span> <span class="toc-text">使用AutomaticBoolean</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LockSupport"><span class="toc-number">22.</span> <span class="toc-text">LockSupport</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">22.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E7%A7%8D%E8%AE%A9%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">22.2.</span> <span class="toc-text">3种让线程等待和唤醒的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%81%8A%E8%81%8AThreadLocal"><span class="toc-number">23.</span> <span class="toc-text">聊聊ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">23.1.</span> <span class="toc-text">使用例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1Java%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">24.</span> <span class="toc-text">由浅入深Java多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">24.1.</span> <span class="toc-text">第一章 进程与线程的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">24.2.</span> <span class="toc-text">第二章 Java多线程入门类和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Thread%E7%B1%BB%E5%92%8CRunnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">24.2.1.</span> <span class="toc-text">2.1 Thread类和Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E7%B1%BB%E6%9E%84%E9%80%A0%E2%BD%85%E6%B3%95"><span class="toc-number">24.2.2.</span> <span class="toc-text">Thread类构造⽅法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E7%B1%BB%E7%9A%84%E2%BC%8F%E4%B8%AA%E5%B8%B8%E2%BD%A4%E2%BD%85%E6%B3%95"><span class="toc-number">24.2.3.</span> <span class="toc-text">Thread类的⼏个常⽤⽅法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E7%B1%BB%E4%B8%8ERunnable%E6%8E%A5%E2%BC%9D%E7%9A%84%E2%BD%90%E8%BE%83"><span class="toc-number">24.2.4.</span> <span class="toc-text">Thread类与Runnable接⼝的⽐较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable%E3%80%81Future%E4%B8%8EFutureTask-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">24.2.5.</span> <span class="toc-text">Callable、Future与FutureTask 异步模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable"><span class="toc-number">24.2.5.1.</span> <span class="toc-text">Callable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future%E6%8E%A5%E5%8F%A3"><span class="toc-number">24.2.5.2.</span> <span class="toc-text">Future接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FutureTask%E7%B1%BB"><span class="toc-number">24.2.5.3.</span> <span class="toc-text">FutureTask类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">24.3.</span> <span class="toc-text">第三章 线程组和线程优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E4%B8%BB%E8%A6%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">24.4.</span> <span class="toc-text">第四章 Java线程的状态及主要转换方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">24.4.1.</span> <span class="toc-text">线程的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#os"><span class="toc-number">24.4.1.1.</span> <span class="toc-text">os</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java"><span class="toc-number">24.4.1.2.</span> <span class="toc-text">java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="toc-number">24.4.1.3.</span> <span class="toc-text">4.3.4线程中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-Java%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">24.5.</span> <span class="toc-text">第五章 Java线程间的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">24.6.</span> <span class="toc-text">第六章 Java内存模型基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%8Ehappens-before"><span class="toc-number">24.7.</span> <span class="toc-text">第七章 重排序与happens-before</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-volatile"><span class="toc-number">24.8.</span> <span class="toc-text">第八章 volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-synchronized%E4%B8%8E%E9%94%81"><span class="toc-number">24.9.</span> <span class="toc-text">第九章 synchronized与锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">24.10.</span> <span class="toc-text">第十章 乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-AQS"><span class="toc-number">24.11.</span> <span class="toc-text">第十一章 AQS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86"><span class="toc-number">24.12.</span> <span class="toc-text">第十二章 线程池原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">24.12.1.</span> <span class="toc-text">12.1为什么要使用线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86"><span class="toc-number">24.12.2.</span> <span class="toc-text">12.2 线程池原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-1-ThreadPoolExecutor%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">24.12.2.1.</span> <span class="toc-text">12.2.1 ThreadPoolExecutor提供的构造方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">24.13.</span> <span class="toc-text">第十三章 阻塞队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%94%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB"><span class="toc-number">24.14.</span> <span class="toc-text">第十四章 锁接口和类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">24.15.</span> <span class="toc-text">第十五章 并发集合容器简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-CopyOnwrite"><span class="toc-number">24.16.</span> <span class="toc-text">第十六章 CopyOnwrite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">24.17.</span> <span class="toc-text">第十七章 通信工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-Fork-x2F-Join%E6%A1%86%E6%9E%B6"><span class="toc-number">24.18.</span> <span class="toc-text">第十八章 Fork&#x2F;Join框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-Java8-Stream%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86"><span class="toc-number">24.19.</span> <span class="toc-text">第十九章 Java8 Stream并行计算原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">24.20.</span> <span class="toc-text">第二十章 计划任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">24.21.</span> <span class="toc-text"></span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/09/8JUC/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/10/09/8JUC/" title="无题">无题</a><time datetime="2022-10-09T14:12:36.052Z" title="发表于 2022-10-09 22:12:36">2022-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6java%E6%A8%A1%E6%9D%BF/" title="一. 基础知识Java模板"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一. 基础知识Java模板"/></a><div class="content"><a class="title" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6java%E6%A8%A1%E6%9D%BF/" title="一. 基础知识Java模板">一. 基础知识Java模板</a><time datetime="2022-09-02T03:51:56.000Z" title="发表于 2022-09-02 11:51:56">2022-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/AcWing/" title="一. 基础知识AcWing题目"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一. 基础知识AcWing题目"/></a><div class="content"><a class="title" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/AcWing/" title="一. 基础知识AcWing题目">一. 基础知识AcWing题目</a><time datetime="2022-09-02T03:51:56.000Z" title="发表于 2022-09-02 11:51:56">2022-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5%E4%BD%8D%E8%BF%90%E7%AE%97/" title="基础知识-位运算"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础知识-位运算"/></a><div class="content"><a class="title" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5%E4%BD%8D%E8%BF%90%E7%AE%97/" title="基础知识-位运算">基础知识-位运算</a><time datetime="2022-09-02T03:51:56.000Z" title="发表于 2022-09-02 11:51:56">2022-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/LeetCode/" title="一  . 基础知识LeetCode"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一  . 基础知识LeetCode"/></a><div class="content"><a class="title" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/LeetCode/" title="一  . 基础知识LeetCode">一  . 基础知识LeetCode</a><time datetime="2022-09-02T03:51:56.000Z" title="发表于 2022-09-02 11:51:56">2022-09-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By ggq</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>