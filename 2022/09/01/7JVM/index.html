<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>jvm | ggq</title><meta name="keywords" content="JVM，虚拟机。"><meta name="author" content="ggq"><meta name="copyright" content="ggq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="jvm总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm">
<meta property="og:url" content="https://gouguoqiang.github.io/2022/09/01/7JVM/index.html">
<meta property="og:site_name" content="ggq">
<meta property="og:description" content="jvm总结。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-01T03:51:56.000Z">
<meta property="article:modified_time" content="2022-10-17T13:35:24.485Z">
<meta property="article:author" content="ggq">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="虚拟机">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://gouguoqiang.github.io/2022/09/01/7JVM/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'jvm',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-17 21:35:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ggq</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">jvm</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-01T03:51:56.000Z" title="发表于 2022-09-01 11:51:56">2022-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-17T13:35:24.485Z" title="更新于 2022-10-17 21:35:24">2022-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="jvm"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-字节码篇"><a href="#第一章-字节码篇" class="headerlink" title="第一章 字节码篇"></a>第一章 字节码篇</h1><h2 id="分析一个对象的创建字节码"><a href="#分析一个对象的创建字节码" class="headerlink" title="分析一个对象的创建字节码"></a>分析一个对象的创建字节码</h2><p>D:\IDEA\projects\Pinduo&gt;javap -verbose -p out&#x2F;production&#x2F;Pinduo&#x2F;P1&#x2F;djp1&#x2F;Main.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> P1.djp1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">D:\IDEA\projects\Pinduo&gt;javap -verbose -p out/production/Pinduo/P1/djp1/Main.class</span><br><span class="line">Classfile /D:/IDEA/projects/Pinduo/out/production/Pinduo/P1/djp1/Main.class</span><br><span class="line">  Last modified 2022年9月23日; size 418 bytes</span><br><span class="line">  MD5 checksum 339314e49862fe3b31f3c66703efb5ca</span><br><span class="line">  Compiled from &quot;Main.java&quot;</span><br><span class="line">public class P1.djp1.Main</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #3                          // P1/djp1/Main</span><br><span class="line">  super_class: #2                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #2.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #20            // java/lang/Object</span><br><span class="line">   #3 = Class              #21            // P1/djp1/Main</span><br><span class="line">   #4 = Utf8               &lt;init&gt;</span><br><span class="line">   #5 = Utf8               ()V</span><br><span class="line">   #6 = Utf8               Code</span><br><span class="line">   #7 = Utf8               LineNumberTable</span><br><span class="line">   #8 = Utf8               LocalVariableTable</span><br><span class="line">   #9 = Utf8               this</span><br><span class="line">  #10 = Utf8               LP1/djp1/Main;</span><br><span class="line">  #11 = Utf8               main</span><br><span class="line">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #13 = Utf8               args</span><br><span class="line">  #14 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #15 = Utf8               o</span><br><span class="line">  #16 = Utf8               Ljava/lang/Object;</span><br><span class="line">  #17 = Utf8               SourceFile</span><br><span class="line">  #18 = Utf8               Main.java</span><br><span class="line">  #19 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #20 = Utf8               java/lang/Object</span><br><span class="line">  #21 = Utf8               P1/djp1/Main</span><br><span class="line">&#123;</span><br><span class="line">  public P1.djp1.Main();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   LP1/djp1/Main;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           #2                  // class java/lang/Object</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">        line 13: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">            8       1     1     o   Ljava/lang/Object;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Main.java&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">D:\IDEA\projects\Pinduo&gt;javap -c out/production/Pinduo/P1/djp1/Main.class</span><br><span class="line">Compiled from &quot;Main.java&quot;</span><br><span class="line">public class P1.djp1.Main &#123;</span><br><span class="line">  public P1.djp1.Main();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class java/lang/Object</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>NEW ：如果找不到Class对象，则进行类加载。加载成功后，则在堆中分配内存，从Object 开始到本类路径上的所有属性值都要分配内存。分配完毕之后，进行零值初始化。在分配过程中，注意引用是占据存储空间的，它是一个变量，占用4个字节。这个指令完毕后，将指向实例对象的引用变量压入虚拟机栈顶。<br>DUP ：在栈顶复制该引用变量，这时的栈顶有两个指向堆内实例对象的引用变量。如果 方法有参数，还需要把参数压人操作栈中。两个引用变量的目的不同，其中压至底下的引用用于赋值，或者保存到局部变量表，另一个栈顶的引用变量作为句柄调用相关方法。<br>INVOKESPECIAL ：调用对象实例方法，通过栈顶的引用变量调用＜init&gt; 方法。</p>
</blockquote>
<h1 id="第二章-类的加载"><a href="#第二章-类的加载" class="headerlink" title="第二章 类的加载"></a>第二章 类的加载</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>注意：方法区只有HotSpot虚拟机有，J9，JRockit都没有</p>
<p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p>
<ol>
<li>类加载器</li>
<li>执行引擎</li>
</ol>
<blockquote>
<p>Bootstrap -&gt; Ext -&gt; App(也叫系统) 组合关系 但是 有一个GetParent方法</p>
</blockquote>
<blockquote>
<p>URLcl -&gt;  Ext -&gt; App </p>
</blockquote>
<h3 id="1-1-类加载器子系统"><a href="#1-1-类加载器子系统" class="headerlink" title="1.1 类加载器子系统"></a>1.1 类加载器子系统</h3><p><strong>类加载器子系统作用：</strong></p>
<ol start="2">
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li>
<li><strong>加载的类信息存放于一块称为方法区的内存空间</strong>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li>
</ol>
<h3 id="1-2-类加载器ClassLoader角色"><a href="#1-2-类加载器ClassLoader角色" class="headerlink" title="1.2 类加载器ClassLoader角色"></a>1.2 类加载器ClassLoader角色</h3><ol>
<li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li>
<li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li>
<li>在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li>
</ol>
<h2 id="2-类加载过程-生命周期"><a href="#2-类加载过程-生命周期" class="headerlink" title="2. 类加载过程(生命周期)"></a>2. 类加载过程(生命周期)</h2><p><strong>面试题</strong></p>
<ul>
<li><p>Java 类加载过程?（苏宁）</p>
</li>
<li><p>描述一下 JVM 加载 Class 文件的原理机制?（国美）</p>
</li>
<li><p>JVM底层怎么加载class文件的？（蚂蚁金服）</p>
</li>
<li><p>类加载过程 （蚂蚁金服）</p>
</li>
<li><p>Java 类加载过程? （百度）</p>
</li>
<li><p>描述一下 JVM 加载 Class 文件的原理机制? （蚂蚁金服）</p>
</li>
<li><p>Java类加载过程 （美团）</p>
</li>
<li><p>描述一下JVM加载class文件的原理机制 （美团）</p>
</li>
<li><p>什么是类的加载？ （京东）</p>
</li>
<li><p>讲一下JVM加载一个类的过程 （京东）</p>
</li>
</ul>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;谢谢ClassLoader加载我....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它加载(与对象创建区分)是怎么样的呢?</p>
<ul>
<li><p>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</p>
</li>
<li><p>加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</p>
</li>
<li><p>加载失败则抛出异常</p>
</li>
<li><p>&#96;&#96;&#96;java<br>class A {<br>static {<br>    System.out.println(“1”);<br>}<br>A() {<br>    System.out.println(“a”);<br>}<br>}<br>class B extends A {<br>static {<br>    System.out.println(“2”);<br>}<br>B() {<br>    System.out.println(“b”);<br>}<br>}<br>public class Main {</p>
<pre><code>public static void main(String[] args) &#123;
    B b = new B();
    A a = new A();
    
    
    
    
    
    
    // 12aba
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.1. 加载阶段</span><br><span class="line"></span><br><span class="line">**加载：**</span><br><span class="line"></span><br><span class="line">1. 通过一个类的全限定名获取定义此类的二进制字节流</span><br><span class="line">2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</span><br><span class="line">3. **在内存中生成一个代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口</span><br><span class="line"></span><br><span class="line">**加载class文件的方式：**</span><br><span class="line"></span><br><span class="line">1. 从本地系统中直接加载</span><br><span class="line">2. 通过网络获取，典型场景：Web Applet</span><br><span class="line">3. 从zip压缩包中读取，成为日后jar、war格式的基础</span><br><span class="line">4. 运行时计算生成，使用最多的是：动态代理技术</span><br><span class="line">5. 由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</span><br><span class="line">6. 从加密文件中获取，典型的防Class文件被反编译的保护措施</span><br><span class="line"></span><br><span class="line">**数组类的加载**</span><br><span class="line"></span><br><span class="line">创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称A）的过程：</span><br><span class="line"></span><br><span class="line">1. 如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型；</span><br><span class="line"></span><br><span class="line">2. JVM使用指定的元素类型和数组维度来创建新的数组类。</span><br><span class="line"></span><br><span class="line">3. 如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public。</span><br><span class="line"></span><br><span class="line">int[] arr</span><br><span class="line"></span><br><span class="line">String[] arr</span><br><span class="line"></span><br><span class="line">Object[] arr</span><br><span class="line"></span><br><span class="line">#### 2.2. 链接阶段</span><br><span class="line"></span><br><span class="line">链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</span><br><span class="line"></span><br><span class="line">##### 验证(Verify)</span><br><span class="line"></span><br><span class="line">1. 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</span><br><span class="line">2. 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</span><br><span class="line"></span><br><span class="line">链接过程之验证阶段(Verification)</span><br><span class="line"></span><br><span class="line">当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</span><br><span class="line"></span><br><span class="line">它的目的是保证加载的字节码是合法、合理并符合规范的。</span><br><span class="line"></span><br><span class="line">验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检査，如图所示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">整体说明：</span><br><span class="line"></span><br><span class="line">验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</span><br><span class="line"></span><br><span class="line">- 其中格式验证会和装载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</span><br><span class="line"></span><br><span class="line">- 格式验证之外的验证操作将会在方法区中进行。</span><br><span class="line"></span><br><span class="line">**举例**</span><br><span class="line"></span><br><span class="line">使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</span><br><span class="line"></span><br><span class="line">##### 准备(Prepare)</span><br><span class="line"></span><br><span class="line">1. 为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值</span><br><span class="line">2. 这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</span><br><span class="line">3. 注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</span><br><span class="line"></span><br><span class="line">链接过程之准备阶段(Preparation)</span><br><span class="line"></span><br><span class="line">简言之，为类的静态变量分配内存，并将其初始化为默认值。</span><br><span class="line"></span><br><span class="line">在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java虚拟机为各类型变量默认的初始值如表所示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：Java并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false。</span><br><span class="line"></span><br><span class="line">**举例**</span><br><span class="line"></span><br><span class="line">代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">JAVA</span><br><span class="line">public class HelloApp &#123;</span><br><span class="line">    private static int a = 1;//prepare：a = 0 ---&gt; initial : a = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve)"></a>解析(Resolve)</h5><ol>
<li><strong>将常量池内的符号引用转换为直接引用的过程</strong></li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</li>
</ol>
<p><strong>符号引用</strong></p>
<ul>
<li>反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</li>
</ul>
<p><img src="/../images/image-20220826091924004-1666013422542.png" alt="image-20220826091924004"></p>
<p>链接过程之解析阶段(Resolution)</p>
<p>简言之，将类、接口、字段和方法的符号引用转为直接引用。</p>
<p>1.具体描述:</p>
<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println()方法被调用时，系统需要明确知道该方法的位置。</p>
<p>举例：输出操作System.out.println()对应的字节码：</p>
<p>invokevirtual #24 </p>
<p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</p>
<p>2.小结： </p>
<p>所谓解析就是将符号引用转为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。</p>
<p>不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>
<h4 id="2-3-初始化阶段"><a href="#2-3-初始化阶段" class="headerlink" title="2.3. 初始化阶段"></a>2.3. 初始化阶段</h4><h5 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h5><ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如：Class.forName(“com.atguigu.Test”)）</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ol>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p>
<h5 id="clinit"><a href="#clinit" class="headerlink" title="clinit()"></a>clinit()</h5><ol>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li>
<li>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li>
<li><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</li>
<li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li>
<li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li>
</ol>
<blockquote>
<p>IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码。安装过程可以自行百度</p>
</blockquote>
<p><strong>Java编译器并不会为所有的类都产生clinit()初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含()方法？</strong></p>
<ul>
<li><p>一个类中并没有声明任何的类变量，也没有静态代码块时</p>
</li>
<li><p>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</p>
</li>
<li><p>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式</p>
</li>
</ul>
<p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassInitTest</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。即在定义之前使用</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line"><span class="comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span></span><br><span class="line"><span class="comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁 </p>
<h5 id="类的初始化情况：主动使用vs被动使用"><a href="#类的初始化情况：主动使用vs被动使用" class="headerlink" title="类的初始化情况：主动使用vs被动使用"></a><strong>类的初始化情况：主动使用vs被动使用</strong></h5><p>Java程序对类的使用分为两种：主动使用 和 被动使用。</p>
<h5 id="主动使用的说明："><a href="#主动使用的说明：" class="headerlink" title="主动使用的说明："></a><strong>主动使用的说明：</strong></h5><p>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。</p>
<p>主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）</p>
<ol>
<li><p>当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。</p>
</li>
<li><p>当调用类的静态方法时，即当使用了字节码invokestatic指令。</p>
</li>
<li><p>当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。</p>
</li>
<li><p>当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”)</p>
<ol>
<li><blockquote>
<p>todo</p>
</blockquote>
</li>
</ol>
</li>
<li><p>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
</li>
<li><p>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p>
<ol>
<li><blockquote>
<p>todo</p>
</blockquote>
</li>
</ol>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
</li>
<li><p>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）</p>
<ol>
<li><blockquote>
<p>todo</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h5 id="被动使用的情况"><a href="#被动使用的情况" class="headerlink" title="被动使用的情况"></a><strong>被动使用的情况</strong></h5><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。</p>
<p>也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</p>
<ol>
<li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。</li>
</ol>
<ul>
<li>当通过子类引用父类的静态变量，不会导致子类初始化</li>
</ul>
<ol start="2">
<li><p>通过数组定义类引用，不会触发此类的初始化</p>
</li>
<li><p>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</p>
</li>
<li><p>调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
</li>
</ol>
<blockquote>
<p>被动的使用，意味着不需要执行初始化环节，意味着没有()的调用。</p>
</blockquote>
<h4 id="2-4-类的使用"><a href="#2-4-类的使用" class="headerlink" title="2.4. 类的使用"></a>2.4. 类的使用</h4><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“万事俱备，只欠东风”，就等着开发者使用了。</p>
<p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用new关键字为其创建对象实例。</p>
<h4 id="2-5-类的卸载"><a href="#2-5-类的卸载" class="headerlink" title="2.5. 类的卸载"></a>2.5. 类的卸载</h4><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“万事俱备，只欠东风”，就等着开发者使用了。</p>
<p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用new关键字为其创建对象实例。</p>
<p>当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。(因为双向引用所以除非类加载器被卸载)</p>
<p>类的卸载</p>
<p>(1) 启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范)</p>
<p>(2) 被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。</p>
<p>(3) 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中(比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。</p>
<p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件： </p>
<ul>
<li>该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。 </li>
<li>加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 </li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>
<h4 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6. 总结"></a>2.6. 总结</h4><pre><code>1. 加载:将字节码静态数据装载到JVM中成为运行时数据

   2. 链接阶段
              1. 验证
            1. 验证一些信息
              2. 准备
            1. 为类的静态变量分配内存，并将其初始化为默认值,final static 在编译时就初始化默认值了 在准备阶段直接赋予真正的值
              3. 解析
            1. 将符号引用转化为直接引用
   3. 初始化
      4. clinit()初始化.class
                  2. init()只是new时进行调用的方法与类加载无关
</code></pre>
<h2 id="3-类的加载器"><a href="#3-类的加载器" class="headerlink" title="3. 类的加载器"></a>3. 类的加载器</h2><p><strong>面试题</strong></p>
<ul>
<li><p>什么是类加载器，类加载器有哪些?（苏宁）</p>
</li>
<li><p>简单说说你了解的类加载器（拼多多）</p>
</li>
<li><p>类加载器都有哪些？（百度） </p>
</li>
<li><p>类加载器有哪些？ （腾讯）</p>
</li>
<li><p>什么是类加载器，类加载器有哪些？（字节跳动）</p>
</li>
</ul>
<h3 id="1-类的加载分类：显式加载-vs-隐式加载"><a href="#1-类的加载分类：显式加载-vs-隐式加载" class="headerlink" title="1. 类的加载分类：显式加载 vs 隐式加载"></a>1. 类的加载分类：显式加载 vs 隐式加载</h3><p>class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。</p>
<ul>
<li><p>显式加载：指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。</p>
</li>
<li><p>隐式加载：则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</p>
</li>
</ul>
<p>在日常开发以上两种方式一般会混合使用。</p>
<h3 id="2-类加载机制的必要性"><a href="#2-类加载机制的必要性" class="headerlink" title="2. 类加载机制的必要性"></a>2. 类加载机制的必要性</h3><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li><p>避免在开发中遇到 java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</p>
</li>
<li><p>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</p>
</li>
<li><p>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p>
</li>
</ul>
<h3 id="3-加载的类是唯一的吗"><a href="#3-加载的类是唯一的吗" class="headerlink" title="3. 加载的类是唯一的吗?"></a>3. 加载的类是唯一的吗?</h3><p>1.何为类的唯一性？</p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p>2.命名空间</p>
<ul>
<li><p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</p>
</li>
<li><p>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</p>
</li>
<li><p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</p>
</li>
</ul>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<h3 id="4-类加载的特性"><a href="#4-类加载的特性" class="headerlink" title="4. 类加载的特性"></a>4. 类加载的特性</h3><p>通常类加载机制有三个基本特征：</p>
<ul>
<li><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider&#x2F;ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java 中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</p>
<ul>
<li><blockquote>
<p>todo</p>
</blockquote>
</li>
</ul>
</li>
<li><p>可见性。子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</p>
<ul>
<li><blockquote>
<p>todo</p>
</blockquote>
</li>
</ul>
</li>
<li><p>单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</p>
<ul>
<li><blockquote>
<p>todo</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="5-类加载器的分类说明"><a href="#5-类加载器的分类说明" class="headerlink" title="5. 类加载器的分类说明"></a>5. 类加载器的分类说明</h3><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p>
<h4 id="子父类的关系"><a href="#子父类的关系" class="headerlink" title="子父类的关系"></a><strong>子父类的关系</strong></h4><ul>
<li><p>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。 </p>
</li>
<li><p>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</p>
</li>
</ul>
<h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></h4><ul>
<li><p>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。</p>
</li>
<li><p>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</p>
</li>
<li><p>并不继承自java.lang.ClassLoader，没有父加载器。</p>
</li>
<li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
</li>
<li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
</li>
</ul>
<h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul>
<li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p>
</li>
<li><p>继承于ClassLoader类</p>
</li>
<li><p>父类加载器为启动类加载器</p>
</li>
<li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p>
</li>
</ul>
<h4 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h4><ul>
<li><p>java语言编写，由sun.misc.Launcher$AppClassLoader实现</p>
</li>
<li><p>继承于ClassLoader类</p>
</li>
<li><p>父类加载器为扩展类加载器</p>
</li>
<li><p>它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库 </p>
</li>
<li><p>应用程序中的类加载器默认是系统类加载器。</p>
</li>
<li><p>它是用户自定义类加载器的默认父加载器</p>
</li>
<li><p>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</p>
</li>
</ul>
<h4 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h4><ul>
<li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>体现Java语言强大生命力和巨大魅力的关键因素之一便是,Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li>
<li>通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li>
<li>同时，自定义加载器能够实现应用隔离，例如 Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li>
<li>所有用户自定义类加载器通常需要继承于抽象类java.lang.ClassLoader。</li>
</ul>
<blockquote>
<p>待复习tomcat机制</p>
</blockquote>
<h2 id="4-cl源码剖析及相关机制"><a href="#4-cl源码剖析及相关机制" class="headerlink" title="4. cl源码剖析及相关机制"></a>4. cl源码剖析及相关机制</h2><h1 id="第三章-运行时数据区"><a href="#第三章-运行时数据区" class="headerlink" title="第三章 运行时数据区"></a>第三章 运行时数据区</h1><p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/image-20220923172113441.png" alt="image-20220923172113441"></p>
<p><strong>面试题</strong></p>
<ul>
<li><p>说一说JVM的内存结构是什么样子的,每个区域放什么，各有什么特点？（快手、搜狐）</p>
</li>
<li><p>JVM的内存结构，及各个结构的内容。（vivo）</p>
</li>
<li><p>详细介绍一下内存结构（墨迹天气）</p>
</li>
<li><p>JVM内存模型有哪些？（龙湖地产）</p>
</li>
<li><p>Java虚拟机中内存划分为哪些区域（高德地图）</p>
</li>
<li><p>JVM内存模型（中国计算机研究院、亚信）</p>
</li>
<li><p>JVM内存结构（花旗银行）</p>
</li>
<li><p>JVM 内存分哪几个区，每个区的作用是什么?（唯品会）</p>
</li>
<li><p>详解JVM内存模型（360）</p>
</li>
<li><p>JVM有那些组成，堆，栈各放了什么东西？（搜狐、万达集团）</p>
</li>
<li><p>JVM的内存模型，线程独有的放在哪里？哪些是线程共享的？哪些是线程独占的？（万达集团）</p>
</li>
<li><p>讲一下为什么JVM要分为堆、方法区等？原理是什么？（小米、搜狐）</p>
</li>
<li><p>JVM的内存模型，线程独有的放在哪里？哪些是线程共享的？哪些是线程独占的？（菜鸟）</p>
</li>
<li><p>简单说一下JVM内存结构（浪潮）</p>
</li>
<li><p>说一下JVM内存模型吧，有哪些区？分别干什么的？ (百度)</p>
</li>
<li><p>JVM的内存结构划分是什么样子的？ (支付宝)</p>
</li>
<li><p>JVM 内存分哪几个区，每个区的作用是什么? (蚂蚁金服)</p>
</li>
<li><p>Java虚拟机内存模型能说说吗？ (蚂蚁金服)</p>
</li>
<li><p>JVM内存分布&#x2F;内存结构？ (蚂蚁金服)</p>
</li>
<li><p>讲讲JVM分区 (携程)</p>
</li>
<li><p>讲一下JVM内存布局 (滴滴)</p>
</li>
<li><p>Java的内存分区 (字节跳动)</p>
</li>
<li><p>讲讲JVM运行时数据库区 (字节跳动)</p>
</li>
<li><p>JVM内存模型以及分区，需要详细到每个区放什么。 (天猫)</p>
</li>
<li><p>JVM 内存分哪几个区，每个区的作用是什么? (拼多多)</p>
</li>
<li><p>JVM的内存布局以及垃圾回收原理及过程讲一下 (京东)</p>
</li>
</ul>
<h2 id="1-程序计数寄存器（Program-Counter-Register）"><a href="#1-程序计数寄存器（Program-Counter-Register）" class="headerlink" title="1. 程序计数寄存器（Program Counter Register）"></a>1. 程序计数寄存器（Program Counter Register）</h2><p>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。<br>它是唯一一个在Java 虚拟机规范中没有规定任何OutOtMemoryError 情况的区域。</p>
<p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong></p>
<p>（为什么使用PC寄存器记录当前线程的执行地址呢？）线程切换</p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><strong>PC寄存器为什么会被设定为线程私有？</strong></p>
<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<h2 id="2-JVM栈"><a href="#2-JVM栈" class="headerlink" title="2. JVM栈"></a>2. JVM栈</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>不存在GC ; 存在OOM</p>
<p><strong>StackOverFlowError？OutOfMemoryError？</strong></p>
<ul>
<li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</li>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常。</li>
</ul>
<p><strong>如何设置栈内存的大小？ -Xss size (即：-XX:ThreadStackSize)</strong> </p>
<ul>
<li>一般默认为512k-1024k，取决于操作系统。</li>
<li>栈的大小直接决定了函数调用的最大可达深度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(count++);</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">SOF</span><br></pre></td></tr></table></figure>

<p>OOM: 死循环创建线程</p>
<p><strong>方法和栈桢之间存在怎样的关系？</strong></p>
<ul>
<li><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p>
</li>
<li><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
</li>
</ul>
<h3 id="栈帧内部结构"><a href="#栈帧内部结构" class="headerlink" title="栈帧内部结构"></a>栈帧内部结构</h3><h4 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h4><p>每个栈帧中存储着：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）（或表达式栈）</li>
<li>动态链接(Dynamic Linking) （或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/53BA4F99-EA72-4192-B3B8-44BDE74899EF.png" alt="img"></p>
<h4 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1. 局部变量表"></a>1. 局部变量表</h4><p>局部变量表（local variables)</p>
<ul>
<li><p>局部变量表也被称之为局部变量数组或本地变量表</p>
</li>
<li><p><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型(8种)、对象引用（reference），以及returnAddress类型。</p>
</li>
<li><p>局部变量表所需的<strong>容量大小</strong>是在编译期确定下来的，并保存在<strong>方法的Code属性的maximum local variables数据项</strong>中。在方法<strong>运行期间是不会改变</strong>局部变量表的大小的。</p>
</li>
<li><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<strong>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大</strong>，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
</li>
<li><p><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
</li>
</ul>
<h5 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h5><p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/21B382E1-9BE4-473A-BD01-1DC2BC7FD4AA.png" alt="img"></p>
<ul>
<li><p>参数值的存放总是在局部变量数组的index为0开始，到数组长度-1的索引结束。</p>
</li>
<li><p><strong>局部变量表，最基本的存储单元是Slot</strong>（变量槽）</p>
</li>
<li><p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double)占用两个slot。</p>
</li>
<li><p>byte 、short 、char 在存储前被转换为int，boolean 也被转换为int，0 表示false ，非0 表示true。</p>
</li>
<li><p>long 和double 则占据两个Slot。</p>
</li>
<li><p><strong>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</strong></p>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上</p>
</li>
<li><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。(比如：访问long或double类型变量）</p>
</li>
<li><p><strong>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。</p>
</li>
</ul>
<p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<ul>
<li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li>
<li>我们知道类<strong>变量</strong>表有两次初始化的机会，第一次是在<strong>“准备阶段</strong>”，执行系统初始化，对<strong>类变量设置零值</strong>，另一次则是在“<strong>初始化</strong>”阶段，<strong>赋予程序员在代码中定义的初始值</strong>。</li>
<li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li>
</ul>
<p> public void test() {<br>int i;<br>   System.<em>out</em>.println(i);<br> }</p>
<p>这样的代码是错误的，没有赋值不能够使用。</p>
<p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</strong></p>
<h4 id="2-操作数栈"><a href="#2-操作数栈" class="headerlink" title="2. 操作数栈"></a>2. 操作数栈</h4><p>操作数栈（Operand Stack）</p>
<ul>
<li>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</li>
<li>每一个独立的<strong>栈帧中</strong>除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）。</li>
<li>操作数栈就是<strong>JVM执行引擎的一个工作区</strong>，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其<strong>所需的最大深度在编译期就定义好</strong>了，保存在<strong>方法的Code</strong>属性中，为<strong>max_stack</strong>的值。</li>
<li>栈中的任何一个元素都是可以任意的Java数据类型。</li>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
<li>操作数栈，<strong>在方法执行过程中，根据字节码指令</strong>，并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和<strong>出栈（pop）操作，往栈中写入数据或提取数据来完成一次数据访问。</strong></li>
<li><strong>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作</strong></li>
<li>如果被调用的方法带有返回值的话，其<strong>返回值将会被压入当前栈帧的操作数栈</strong>中，并<strong>更新PC寄存器中下一条需要执行的字节码指令</strong>。</li>
</ul>
<p><strong>栈顶缓存技术</strong></p>
<p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在<strong>物理CPU的寄存器</strong>中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</p>
<h4 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3. 动态链接"></a>3. 动态链接</h4><p>动态链接（或指向运行时常量池的方法引用）</p>
<ul>
<li><p>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接（Dynamic Linking）</strong>。比如：<strong>invokedynamic</strong>指令</p>
</li>
<li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong>。</p>
</li>
</ul>
<p>public void testGetSum(){*<br>*int i &#x3D; getSum();<br>int j &#x3D; 10;<br>}</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/F0A4DA2A-8338-4D9D-8050-79B8F8D43DC2.png" alt="img"></p>
<h4 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4. 方法返回地址"></a>4. 方法返回地址</h4><ul>
<li><p>存放调用该方法的pc寄存器的值。</p>
</li>
<li><p>一个方法的结束，有两种方式：</p>
</li>
<li><p>正常执行完成</p>
</li>
<li><p>出现未处理的异常，非正常退出</p>
</li>
<li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
</li>
</ul>
<h4 id="5-一些附加信息"><a href="#5-一些附加信息" class="headerlink" title="5. 一些附加信息"></a>5. 一些附加信息</h4><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>
<h3 id="面试扩展问题"><a href="#面试扩展问题" class="headerlink" title="面试扩展问题"></a>面试扩展问题</h3><p>问题一：栈溢出的情况?</p>
<p>栈溢出:StackOverflowError;</p>
<p>举个简单的例子:在main方法中调用main方法,就会不断压栈执行,直到栈溢出;</p>
<p>栈的大小可以是固定大小的,也可以是动态变化（动态扩展）的。</p>
<p>如果是固定的,可以通过-Xss设置栈的大小;</p>
<p>如果是动态变化的,当栈大小到达了整个内存空间不足了,就是抛出OutOfMemory异常(java.lang.OutOfMemoryError)</p>
<p>问题二：调整栈大小,就能保证不出现溢出吗?</p>
<p>不能。因为调整栈大小,只会减少出现溢出的可能,栈大小不是可以无限扩大的,所以不能保证不出现溢出</p>
<p>问题三：分配的栈内存越大越好吗?</p>
<p>不是,因为增加栈大小，会造成每个线程的栈都变的很大,使得一定的栈空间下,能创建的线程数量会变小</p>
<p>问题四：垃圾回收是否会涉及到虚拟机栈?</p>
<p>不会;垃圾回收只会涉及到方法区和堆中,方法区和堆也会存在溢出的可能;</p>
<p>程序计数器,只记录运行下一行的地址,不存在溢出和垃圾回收;</p>
<p>虚拟机栈和本地方法栈,都是只涉及压栈和出栈,可能存在栈溢出,不存在垃圾回收。</p>
<p>问题五：方法中定义的局部变量是否线程安全?</p>
<p>具体问题具体分析,见分析代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**方法中定义的局部变量是否线程安全?   具体问题具体分析</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 15:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariableThreadSafe</span> &#123;</span><br><span class="line"><span class="comment">//s1的声明方式是线程安全的,因为线程私有，在线程内创建的s1 ，不会被其它线程调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stringBuilder的操作过程：是线程不安全的，</span></span><br><span class="line">    <span class="comment">// 因为stringBuilder是外面传进来的，有可能被多个线程调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stringBuilder的操作：是线程不安全的；因为返回了一个stringBuilder，</span></span><br><span class="line">    <span class="comment">// stringBuilder有可能被其他线程共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> stringBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stringBuilder的操作：是线程安全的；因为返回了一个stringBuilder.toString()相当于new了一个String，</span></span><br><span class="line">    <span class="comment">// 所以stringBuilder没有被其他线程共享的可能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 结论：如果局部变量在内部产生并在内部消亡的，那就是线程安全的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-本地方法接口与本地方法栈"><a href="#3-本地方法接口与本地方法栈" class="headerlink" title="3. 本地方法接口与本地方法栈"></a>3. 本地方法接口与本地方法栈</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li>与Java环境外交互：</li>
</ul>
<p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p>
<ul>
<li>与操作系统交互：</li>
</ul>
<p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p>
<ul>
<li>Sun’s Java</li>
</ul>
<p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread 的 setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</p>
<h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>《Java虚拟机规范》中对Java堆的描述是：所有的<strong>对象实例以及数组</strong>都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated ) 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
</li>
<li><p>我要说的是：“几乎”所有的对象实例都在这里分配内存。——从实际使用角度看的。</p>
</li>
</ul>
<p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer, TLAB)。</p>
<h3 id="堆的内部结构"><a href="#堆的内部结构" class="headerlink" title="堆的内部结构"></a>堆的内部结构</h3><p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/34DC8A34-8FC1-4410-AAD6-421A3CE7010B.png" alt="img"></p>
<ul>
<li>几乎所有的Java对象都是在Eden区被new出来的。</li>
<li>绝大部分的Java对象的销毁都在新生代进行了。</li>
<li>IBM 公司的专门研究表明，新生代中 80% 的对象都是“朝生夕死”的。</li>
</ul>
<h3 id="如何设置堆内存大小？"><a href="#如何设置堆内存大小？" class="headerlink" title="如何设置堆内存大小？"></a>如何设置堆内存大小？</h3><h4 id="如何设置新生代与老年代比例？"><a href="#如何设置新生代与老年代比例？" class="headerlink" title="如何设置新生代与老年代比例？"></a>如何设置新生代与老年代比例？</h4><ul>
<li><p>下面这参数开发中一般不会调：</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/3361B78F-4E9C-47DF-AA94-C10367777ECE.png" alt="img"></p>
<ul>
<li><p>配置新生代与老年代在堆结构的占比。</p>
</li>
<li><p>默认**-XX:NewRatio&#x3D;2**，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p>
</li>
<li><p>可以修改-XX:NewRatio&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p>
</li>
<li><p>可以使用选项”**-Xmn**”设置新生代最大内存大小</p>
</li>
<li><p>这个参数一般使用默认值就可以了。</p>
</li>
</ul>
</li>
</ul>
<h4 id="如何设置Eden、幸存者区比例？"><a href="#如何设置Eden、幸存者区比例？" class="headerlink" title="如何设置Eden、幸存者区比例？"></a>如何设置Eden、幸存者区比例？</h4><ul>
<li>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1</li>
<li>当然开发人员可以通过选项“**-XX:SurvivorRatio<strong>”调整这个空间比例。比如</strong>-XX:SurvivorRatio&#x3D;8**</li>
</ul>
<h4 id="OOM举例"><a href="#OOM举例" class="headerlink" title="OOM举例"></a>OOM举例</h4><p>​	</p>
<h4 id="参数设置小结"><a href="#参数设置小结" class="headerlink" title="参数设置小结"></a>参数设置小结</h4><ul>
<li>什么是空间分配担保策略？（渣打银行）</li>
<li>什么是空间分配担保策略？（顺丰）</li>
<li>什么是空间分配担保策略？（腾讯、百度）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试堆空间常用的jvm参数：</span><br><span class="line"> * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值</span><br><span class="line"> * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）</span><br><span class="line"> *      具体查看某个参数的指令： jps：查看当前运行中的进程</span><br><span class="line"> *                             jinfo -flag SurvivorRatio 进程id</span><br><span class="line"> *</span><br><span class="line"> * -Xms：初始堆空间内存 （默认为物理内存的1/64）</span><br><span class="line"> * -Xmx：最大堆空间内存（默认为物理内存的1/4）</span><br><span class="line"> * -Xmn：设置新生代的大小。(初始值及最大值)</span><br><span class="line"> * -XX:NewRatio：配置新生代与老年代在堆结构的占比</span><br><span class="line"> * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</span><br><span class="line"> * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</span><br><span class="line"> * -XX:+PrintGCDetails：输出详细的GC处理日志</span><br><span class="line"> * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc</span><br><span class="line"> * -XX:HandlePromotionFailure：是否设置空间分配担保</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h3 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h3><p>1.new的对象先放伊甸园区。此区有大小限制。</p>
<p>2.<strong>当伊甸园的空间填满时，程序又需要创建对象</strong>，JVM的垃圾回收器将对伊甸园区进行垃圾回收(<strong>Minor GC&#x2F;YGC</strong>)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p>
<p>3.<strong>然后将伊甸园中的剩余对象移动到幸存者0区</strong>。</p>
<p>4**.如果再次触发垃圾回收<strong>，</strong>此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区**。</p>
<p>5.<strong>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区</strong>。</p>
<p>6.啥时候能去养老区呢？<strong>可以设置次数。默认是15次。</strong></p>
<ul>
<li>可以设置参数：**-XX:MaxTenuringThreshold&#x3D;** 设置对象晋升老年代的年龄阈值。</li>
</ul>
<p>7.在养老区，相对悠闲。<strong>当养老区内存不足时，再次触发GC：Major GC</strong>，进行养老区的内存清理。</p>
<p>8.若养老区执行了Major GC之后发现依然<strong>无法进行对象的保存</strong>，就会产生OOM异常</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/DECE7018-508C-44E0-85D4-849137D4116F.png" alt="img"></p>
<h5 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h5><p>1、在发生<strong>Minor GC</strong>之前，虚拟机会检查老年代最大可用的连续空间是否大于<strong>新生代</strong>所有对象的总空间。</p>
<ul>
<li><p>如果大于，则此次Minor GC是安全的</p>
</li>
<li><p>如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。</p>
<ul>
<li><p>如果HandlePromotionFailure&#x3D;true，那么会继续检查</p>
<p><strong>老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong></p>
<p>。</p>
<ul>
<li>如果大于，<strong>则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</strong></li>
<li>如果小于，<strong>则进行一次Full GC</strong>。</li>
</ul>
</li>
<li><p>如果HandlePromotionFailure&#x3D;<strong>false</strong>，<strong>则进行一次Full GC</strong>。</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><h3 id="1-栈、堆、方法区的关系"><a href="#1-栈、堆、方法区的关系" class="headerlink" title="1. 栈、堆、方法区的关系"></a>1. 栈、堆、方法区的关系</h3><p><img src="/../images/image-20220907234524335-1666013464730.png" alt="image-20220907234524335"></p>
<p><img src="/../images/image-20220907234534652-1666013469029.png" alt="image-20220907234534652"></p>
<h3 id="2-什么是TLAB？"><a href="#2-什么是TLAB？" class="headerlink" title="2. 什么是TLAB？"></a>2. 什么是TLAB？</h3><ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</li>
<li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ul>
<h3 id="3-方法区在哪里"><a href="#3-方法区在哪里" class="headerlink" title="3. 方法区在哪里"></a>3. 方法区在哪里</h3><p>《Java虚拟机规范》中明确说明: “尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。” 但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。</p>
<p>所以，方法区看作是一块独立于Java 堆的内存空间。</p>
<h3 id="4-方法区的理解"><a href="#4-方法区的理解" class="headerlink" title="4. 方法区的理解"></a>4. 方法区的理解</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。<br>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。<br>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。<br>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError: PermGen space 或者 java.lang.OutOfMemoryError: Metaspace<br>加载大量的第三方的jar包；Tomcat部署的工程过多（30-50个）；大量动态的生成反射类<br>关闭JVM就会释放这个区域的内存。</p>
<h3 id="5-方法区的演进"><a href="#5-方法区的演进" class="headerlink" title="5. 方法区的演进"></a>5. 方法区的演进</h3><p>到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替<br>￼<br>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。<br>永久代、元空间二者并不只是名字变了，内部结构也调整了。<br>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</p>
<h3 id="6-设置方法区内存的大小"><a href="#6-设置方法区内存的大小" class="headerlink" title="6. 设置方法区内存的大小"></a>6. 设置方法区内存的大小</h3><ul>
<li><p>方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。</p>
</li>
<li><p>jdk7及以前：</p>
</li>
<li><p>通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M</p>
</li>
<li><p>-XX:MaxPermSize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</p>
</li>
<li><p>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space 。</p>
</li>
<li><p>jdk8及以后：</p>
</li>
<li><p>元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定,替代上述原有的两个参数。</p>
</li>
<li><p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize 的值是-1，即没有限制。</p>
</li>
<li><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError: Metaspace</p>
</li>
<li><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
</li>
<li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC ，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p>
</li>
</ul>
<p>在JDK8 及以上版本中，设定MaxPermSize 参数， JVM在启动时并不会报错，但是会提示：</p>
<p>Java HotSpot 64Bit Server VM warning:</p>
<p>ignoring option MaxPermSize&#x3D;2560m; support was removed in 8.0 。</p>
<h1 id="第四章-对象的内存布局"><a href="#第四章-对象的内存布局" class="headerlink" title="第四章 对象的内存布局"></a>第四章 对象的内存布局</h1><h2 id="1-对象的实例化"><a href="#1-对象的实例化" class="headerlink" title="1. 对象的实例化"></a>1. 对象的实例化</h2><h3 id="1-1-有几种创建对象的方式"><a href="#1-1-有几种创建对象的方式" class="headerlink" title="1.1 有几种创建对象的方式"></a>1.1 有几种创建对象的方式</h3><blockquote>
<p>实操 todo</p>
</blockquote>
<ol>
<li><p>new</p>
<ol>
<li>变形1: Xxx静态方法的new</li>
<li>变形2: XxxBuilder&#x2F;XxxFactory的静态方法</li>
</ol>
</li>
<li><p>Class的newInstance()</p>
</li>
<li><p>Constructor的newInstance()</p>
</li>
<li><p>clone()</p>
</li>
<li><p>反序列化</p>
</li>
<li><p>第三发库Objenesis,利用了asm字节码技术,动态生成Constructor</p>
<ol>
<li><p>典型用途：</p>
<p>需要在不调用构造函数的情况下实例化对象是一项相当特殊的任务，但是在某些情况下这是有用的：</p>
<ul>
<li><p>序列化，远程调用和持久化-对象需要被实例化并恢复到特定的状态，而不需要调用代码</p>
</li>
<li><p>代理、 AOP 库和 mock 对象-类可以被子类继承而子类不用担心父类的构造器</p>
</li>
<li><p>容器框架-对象可以以非标准的方式动态地实例化</p>
</li>
</ul>
</li>
<li><p>Spring中的封装的元数据读取器等就是利用了asm,需要注意的是，SimpleMetadataReader去解析类时，使用的<strong>ASM技术</strong>。</p>
<blockquote>
<p>并不是等Java类加载到JVM在解析,而是直接读取字节码文件</p>
</blockquote>
<p>为什么要使用ASM技术，Spring启动的时候需要去扫描，如果指定的包路径比较宽泛，那么扫描的类是非常多的，那如果在Spring启动时就把这些类全部加载进JVM了，这样不太好，所以使用了ASM技术。</p>
</li>
</ol>
</li>
</ol>
<h3 id="1-2-创建对象的过程"><a href="#1-2-创建对象的过程" class="headerlink" title="1.2 创建对象的过程"></a>1.2 创建对象的过程</h3><h4 id="1-2-1-从字节码角度看待对象创建过程-见字节码篇"><a href="#1-2-1-从字节码角度看待对象创建过程-见字节码篇" class="headerlink" title="1.2.1 从字节码角度看待对象创建过程 : 见字节码篇"></a>1.2.1 从字节码角度看待对象创建过程 : 见字节码篇</h4><h4 id="1-2-2-从执行步骤角度分析"><a href="#1-2-2-从执行步骤角度分析" class="headerlink" title="1.2.2 从执行步骤角度分析"></a>1.2.2 从执行步骤角度分析</h4><ol>
<li><p>判断对象对应的类是否加载,链接,初始化</p>
<ol>
<li><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（即判断类元信息是否存在）。</p>
<ul>
<li><p>如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class 文件。</p>
</li>
<li><p>如果没有找到文件，则抛出ClassNotFoundException 异常。</p>
</li>
<li><p>如果找到，则进行类加载，并生成对应的Class类对象。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>为对象分配内存</p>
<ol>
<li><p>指针碰撞</p>
<ol>
<li>如果内存规整，使用指针碰撞</li>
</ol>
<p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。 如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。 一般使用带有compact（整理）过程的收集器时，使用指针碰撞。</p>
</li>
<li><p>空闲列表</p>
<ol>
<li>如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配</li>
</ol>
<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为“空闲列表（Free List）”。</p>
</li>
</ol>
</li>
<li><p>处理并发安全问题</p>
<ol>
<li>在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。 虚拟机采用了两种方式解决并发问题:<ul>
<li>CAS ( Compare And Swap ）失败重试、区域加锁：保证指针更新操作的原子性;</li>
<li>TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer）虚拟机是否使用TLAB，可以通过-XX:+&#x2F;-UseTLAB参数来设定。</li>
</ul>
</li>
</ol>
</li>
<li><p>初始化分配到的空间</p>
<ol>
<li>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
</ol>
</li>
<li><p>设置对象的对象头</p>
<ol>
<li>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</li>
</ol>
</li>
<li><p>执行init方法进行初始化</p>
<ol>
<li><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p>
<p>因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p>
</li>
</ol>
</li>
</ol>
<h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h2><ol>
<li><p>对象头</p>
<ol>
<li><p>对象头：它主要包括两部分。</p>
<ul>
<li><p>一个是对象自身的运行时元数据(mark word)。</p>
</li>
<li><p>哈希值(hashcode)：对象在堆空间中都有一个首地址值，栈空间的引用根据这个地址指向堆中的对象，这就是哈希值起的作用</p>
</li>
<li><p>GC分代年龄：对象首先是在Eden中创建的，在经过多次GC后，如果没有被进行回收，就会在survivor中来回移动，其对应的年龄计数器会发生变化，达到阈值后会进入养老区</p>
</li>
<li><p>锁状态标志，在同步中判断该对象是否是锁</p>
</li>
<li><p>线程持有的锁</p>
</li>
<li><p>线程偏向ID</p>
</li>
<li><p>偏向时间戳</p>
</li>
<li><p>另一个是类型指针，指向元数据区的类元数据InstanceKlass，确定该对象所属的类型</p>
</li>
<li><p>此外，如果对象是一个数组，对象头中还必须有一块用于记录数组的长度的数据。</p>
</li>
<li><p>因为正常对象元数据就知道对象的确切大小。所以数组必须得知道长度。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>实例数据</p>
<ol>
<li><p>作用：</p>
<p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）。</p>
<p>这里需要遵循的一些规则：</p>
<p>相同宽度的字段总是被分配在一起</p>
<p>父类中定义的变量会出现在子类之前（因为父类的加载是优先于子类加载的）</p>
<p>如果CompactFields参数为true(默认为true)：子类的窄变量可能插入到父类变量的空隙</p>
</li>
</ol>
</li>
<li><p>对齐填充</p>
<ol>
<li>对齐填充：不是必须的，也没特别含义，仅仅起到占位符的作用</li>
</ol>
</li>
</ol>
<h2 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a>3. 对象的访问定位</h2><ol>
<li>句柄访问<ol>
<li><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/FB23035C-D0A6-4944-B09C-50FD043767CF.png" alt="img"><ul>
<li>实现：堆需要划分出一块内存来做句柄池，reference中存储对象的句柄池地址，句柄中包含对象实例与类型数据各自具体的地址信息。</li>
<li>好处：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针，reference本身不需要被修改。</li>
</ul>
</li>
</ol>
</li>
<li>直接使用指针访问<ol>
<li><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/C2299BF8-C3E7-4BF2-B5E4-29233BD0CC3D.png" alt="img"><ul>
<li>实现：reference中存储的就是对象的地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li>
<li>好处：速度更快，java中对象访问频繁，每次访问都节省了一次指针定位的时间开销。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>HotSpot这里主要使用第2种方式：直接指针访问</p>
<p>JVM可以通过对象引用准确定位到Java堆区中的instanceOopDesc对象，这样既可成功访问到对象的实例信息，当需要访问目标对象的具体类型时，JVM则会通过存储在instanceOopDesc中的元数据指针定位到存储在方法区中的instanceKlass对象上。</p>
<h1 id="第五章-执行引擎篇"><a href="#第五章-执行引擎篇" class="headerlink" title="第五章 执行引擎篇"></a>第五章 执行引擎篇</h1><h1 id="第六章-垃圾回收篇"><a href="#第六章-垃圾回收篇" class="headerlink" title="第六章 垃圾回收篇"></a>第六章 垃圾回收篇</h1><p>从次数上讲：<br>频繁收集Young区<br>较少收集Old区<br>基本不动Perm区（或元空间）</p>
<h2 id="1-垃圾回收算法"><a href="#1-垃圾回收算法" class="headerlink" title="1.垃圾回收算法"></a>1.垃圾回收算法</h2><h3 id="1-1标记算法"><a href="#1-1标记算法" class="headerlink" title="1.1标记算法"></a>1.1标记算法</h3><h4 id="1-1-1引用计数法"><a href="#1-1-1引用计数法" class="headerlink" title="1.1.1引用计数法"></a>1.1.1引用计数法</h4><p><strong>原理</strong>：</p>
<p>对于一个对象A，只要有任何一个对象引用了A ，则A 的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A 的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<p><strong>优点</strong>：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>
<p><strong>缺点</strong>：</p>
<p>缺点1：它需要<strong>单独的字段存储计数器</strong>，这样的做法<strong>增加了存储空间</strong>的开销。</p>
<p>缺点2：每次赋值都需要更新计数器，<strong>伴随着加法和减法</strong>操作，这<strong>增加了时间开销</strong>。</p>
<p>缺点3：引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java 的垃圾回收器中没有使用这类算法。</p>
<ul>
<li><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p>
</li>
<li><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p>
</li>
<li><p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p>
</li>
<li><p>Python如何解决循环引用？</p>
<ul>
<li><strong>手动解除</strong>：很好理解，就是在合适的时机，解除引用关系。</li>
<li><strong>使用弱引用weakref</strong>， weakref是Python提供的标准库，旨在解决循环引用。</li>
</ul>
</li>
</ul>
<h4 id="1-1-2可达性分析算法"><a href="#1-1-2可达性分析算法" class="headerlink" title="1.1.2可达性分析算法"></a>1.1.2可达性分析算法</h4><p><strong>原理</strong>：</p>
<p>其原理简单来说，就是<strong>将对象及其引用关系看作一个图</strong>，<strong>选定活动的对象作为 GC Roots</strong>，然后<strong>跟踪引用链条</strong>，<strong>如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象</strong>。</p>
<p><strong>优点</strong>：</p>
<p>实现简单，执行高效 ，有效的解决循环引用的问题，防止内存泄漏。</p>
<h5 id="GC-root"><a href="#GC-root" class="headerlink" title="GC root"></a>GC root</h5><p>在Java 语言中， GC Roots 包括以下几类元素：</p>
<ul>
<li>虚拟机栈中引用的对象<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
<li>本地方法栈内JNI(通常说的本地方法)引用的对象</li>
</ul>
</li>
<li>类静态属性引用的对象<ul>
<li>比如：Java类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中常量引用的对象<ul>
<li>比如：字符串常量池（String Table）里的引用</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用。</li>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/2975D8CE-8ADA-49C4-A64B-2A2191B34392.png" alt="img"></p>
<ul>
<li><p><strong>除了这些固定的GC Roots集合以外</strong>，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，<strong>还可以有其他对象“临时性”地加入</strong>，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）。</p>
<ul>
<li><blockquote>
<p>不太了解细节</p>
</blockquote>
</li>
</ul>
</li>
<li><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，<strong>这个区域的对象完全有可能被其他区域的对象所引用</strong>，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</p>
</li>
<li><p>小技巧：</p>
</li>
</ul>
<p>由于Root 采用栈方式存放变量和指针，所以如果<strong>一个指针，它保存了堆内存里面的对象</strong>，<strong>但是自己又不存放在堆内存里面，那它就是一个Root 。</strong></p>
<h5 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h5><ul>
<li><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p>
</li>
<li><p>这点也是导致GC进行时必须“Stop The World”的一个重要原因。</p>
</li>
<li><p>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
</li>
</ul>
<h3 id="1-2-清除算法"><a href="#1-2-清除算法" class="headerlink" title="1.2.清除算法"></a>1.2.清除算法</h3><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>标记-清除（Mark - Sweep）算法</p>
<p>背景：</p>
<p>标记 - 清除算法（ Mark-Sweep ）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>
<p>执行过程：</p>
<p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。 </p>
<ul>
<li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li>
<li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li>
</ul>
<p>（很多书、视频讲错了！说是标记的垃圾对象。这里要注意了！）</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/24CA8F45-6D5B-4B39-BC38-C7B5E98C405C.png" alt="img"></p>
<p><strong>缺点</strong>：</p>
<p>1、效率比较低：递归与全堆对象遍历两次</p>
<p>2、在进行GC的时候，需要停止整个应用程序，导致用户体验差</p>
<p>3、这种方式清理出来的空闲内存是不连续的，产生内存碎片。</p>
<p>注意：何为清除?</p>
<ul>
<li>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>核心思想：</p>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/25BC0D0E-478A-4DB3-9306-53353BABDFC8.png" alt="img"></p>
<p>优点：</p>
<ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ul>
<p>缺点：</p>
<ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
</ul>
<p>特别的：</p>
<ul>
<li>如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。</li>
</ul>
<p>应用场景：</p>
<p>在新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<p>比如：IBM 公司的专门研究表明，新生代中 80% 的对象都是“朝生夕死”的。</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/1C6E38D5-D041-4083-88AF-F7366CA80C4F-1664013468432.png" alt="img"></p>
<h4 id="标记压缩"><a href="#标记压缩" class="headerlink" title="标记压缩"></a>标记压缩</h4><p>标记-压缩（或标记-整理、Mark - Compact）算法</p>
<p>背景：</p>
<p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p>
<p>标记－清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM 的设计者需要在此基础之上进行改进。标记 - 压缩（Mark - Compact）算法由此诞生。</p>
<p>执行过程：</p>
<p>第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象</p>
<p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</p>
<p>之后， 清理边界外所有的空间。</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/6EF327A5-CF26-4B0A-AAF5-6F9508F825A9.png" alt="img"></p>
<p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法。 </p>
<p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p>
<p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<p>指针碰撞（Bump the Pointer）</p>
<p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer）。 </p>
<p>优点：（此算法消除了“标记-清除”和“复制”两个算法的弊端。）</p>
<ul>
<li><p>消除了标记&#x2F;清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</p>
</li>
<li><p>消除了复制算法当中，内存减半的高额代价。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>从效率上来说，标记-压缩算法要低于复制算法。</p>
</li>
<li><p>效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。</p>
</li>
<li><p>对于老年代每次都有大量对象存活的区域来说，极为负重。</p>
</li>
<li><p>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</p>
</li>
<li><p>移动过程中，需要全程暂停用户应用程序。即：STW</p>
</li>
</ul>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p> 三种算法的对比：</p>
<p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p>目前几乎所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的。</p>
<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>年轻代(Young Gen)</li>
</ul>
<p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<ul>
<li>老年代(Tenured Gen)</li>
</ul>
<p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<ul>
<li>Mark阶段的开销与存活对象的数量成正比。</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>
<li>Compact阶段的开销与存活对象的数据成正比。</li>
</ul>
<p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p>
<h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World 的状态。在Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<p>基本思想</p>
<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p>
<p>缺点：</p>
<p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>分区算法：—G1 GC使用的算法</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p>
<p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/B272F64C-F9A0-4CA7-84A1-F5A5FB63A658.png" alt="img"></p>
<h2 id="2-相关概念"><a href="#2-相关概念" class="headerlink" title="2.相关概念"></a>2.相关概念</h2><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>System.gc()和Runtime.getRunTime().gc()会做什么事情？ (字节跳动)</p>
<ul>
<li><p>在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会<strong>显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
</li>
<li><p>然而System.gc()调用<strong>附带一个免责声明，无法保证对垃圾收集器的调用</strong>。</p>
</li>
<li><p>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。</p>
</li>
</ul>
<h3 id="finalize-方法详解"><a href="#finalize-方法详解" class="headerlink" title="finalize()方法详解"></a>finalize()方法详解</h3><p>finalize()方法详解，前言，finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</p>
<p>finalize的作用</p>
<p> (1)finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有<strong>不确定性</strong></p>
<p>(2)不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① **清理本地对象(通过JNI创建的对象)**；② <strong>作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。</strong></p>
<h3 id="内存泄漏与内存溢出"><a href="#内存泄漏与内存溢出" class="headerlink" title="内存泄漏与内存溢出"></a>内存泄漏与内存溢出</h3><p><strong>内存溢出</strong></p>
<ul>
<li><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>
</li>
<li><p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现<strong>OOM</strong>的情况。</p>
</li>
<li><p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</p>
</li>
<li><p>javadoc中对OutOfMemoryError的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。</p>
</li>
</ul>
<p>OOM之前必回调用GC?</p>
<ul>
<li><p>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
</li>
<li><p>例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</p>
</li>
<li><p>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</p>
</li>
<li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
</li>
<li><p>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError。</p>
</li>
</ul>
<p><strong>内存泄漏</strong></p>
<p>何为内存泄漏（memory leak）</p>
<p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。</p>
<p><strong>是否还被使用？ 是</strong> </p>
<p><strong>是否还被需要？ 否</strong></p>
<p>内存泄漏（memory leak）的理解</p>
<p>严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</strong>。</p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会<strong>导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”</strong>。</p>
<p>对象 X 引用对象 Y，X 的生命周期比 Y 的生命周期长；</p>
<p>那么当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收期是不会回收对象Y的；</p>
<p>如果对象X还引用着生命周期比较短的A、B、C，对象A又引用着对象 a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p>
<p>内存泄漏与内存溢出的关系：</p>
<ol>
<li>内存泄漏（memory leak ）</li>
</ol>
<p>申请了内存用完了不释放，比如一共有 1024M 的内存，分配了 512M 的内存一直不回收，那么可以用的内存只有 512M 了，仿佛泄露掉了一部分；</p>
<p>通俗一点讲的话，内存泄漏就是【占着茅坑不拉shi】。</p>
<ol start="2">
<li>内存溢出（out of memory）</li>
</ol>
<p>申请内存时，没有足够的内存可以使用；</p>
<p>通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的（内存泄漏），剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位（内存）就不够了，内存泄漏变成内存溢出了。</p>
<p>可见，内存泄漏和内存溢出的关系：内存泄漏的增多，最终会导致内存溢出。</p>
<p>泄漏的分类</p>
<p>经常发生：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存；</p>
<p>偶然发生：在某些特定情况下才会发生；</p>
<p>一次性：发生内存泄露的方法只会执行一次；</p>
<p>隐式泄漏：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</p>
<p><strong>Java中内存泄漏的8种情况</strong></p>
<ol>
<li>静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeak</span> &#123;</span><br><span class="line"><span class="keyword">static</span> List *list* = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTests</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//局部变量</span></span><br><span class="line">*list*.add(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>单例模式</p>
<ol>
<li>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</li>
</ol>
</li>
<li><p>内部类持有外部类</p>
<ol>
<li><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。</p>
<p>这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerDemoActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> <span class="keyword">implements</span> <span class="title class_">OnClickListener</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_INCRESE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_DECRESE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> TextView tv_demo_number;</span><br><span class="line">  <span class="keyword">private</span> Button btn_demo_increase;</span><br><span class="line">  <span class="keyword">private</span> Button btn_demo_decrease;</span><br><span class="line">  <span class="keyword">private</span> Button btn_demo_pause;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>()&#123;</span><br><span class="line">     <span class="comment">//回调方法</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(android.os.Message msg)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">strNum</span> <span class="operator">=</span> tv_demo_number.getText().toString();</span><br><span class="line">       <span class="comment">//转换为整型数据,获取当前显示的数值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(strNum);</span><br><span class="line">       <span class="keyword">switch</span>(msg.what)&#123;</span><br><span class="line">       <span class="keyword">case</span> MESSAGE_INCRESE:</span><br><span class="line">          num++;</span><br><span class="line">          tv_demo_number.setText(num + <span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span>(num == <span class="number">20</span>)&#123;</span><br><span class="line">            Toast.makeText(HandlerDemoActivity.<span class="built_in">this</span>, <span class="string">&quot;已达到最大值&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">            btn_demo_pause.setEnabled(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//发送延迟的+1的消息</span></span><br><span class="line">          sendEmptyMessageDelayed(MESSAGE_INCRESE, <span class="number">300</span>);<span class="comment">//指的是延迟处理，而不是延迟发送</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> MESSAGE_DECRESE:</span><br><span class="line">          num--;</span><br><span class="line">          tv_demo_number.setText(num + <span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            Toast.makeText(HandlerDemoActivity.<span class="built_in">this</span>, <span class="string">&quot;已达到最小值&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">            btn_demo_pause.setEnabled(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//发送延迟的-1的消息</span></span><br><span class="line">          sendEmptyMessageDelayed(MESSAGE_DECRESE, <span class="number">300</span>);<span class="comment">//指的是延迟处理，而不是延迟发送</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.activity_handler_demo);</span><br><span class="line">     init();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">     tv_demo_number = (TextView) findViewById(R.id.tv_demo_number);</span><br><span class="line">     btn_demo_increase = (Button) findViewById(R.id.btn_demo_increase);</span><br><span class="line">     btn_demo_decrease = (Button) findViewById(R.id.btn_demo_decrease);</span><br><span class="line">     btn_demo_pause = (Button) findViewById(R.id.btn_demo_pause);</span><br><span class="line">     btn_demo_increase.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">     btn_demo_decrease.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">     btn_demo_pause.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">     ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>各种连接，如数据库连接、网络连接和IO连接等</p>
</li>
<li><p>变量不合理的作用域</p>
</li>
<li><p>改变哈希值</p>
</li>
<li><p>缓存泄漏</p>
</li>
<li><p>监听器和回调</p>
</li>
</ol>
<h3 id="STW-1"><a href="#STW-1" class="headerlink" title="STW"></a>STW</h3><ul>
<li><p>Stop-the-World ，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>
</li>
<li><p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p>
</li>
<li><p>分析工作必须在一个能确保一致性的快照中进行</p>
</li>
<li><p>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</p>
</li>
<li><p>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</p>
</li>
<li><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p>
</li>
<li><p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p>
</li>
<li><p>哪怕是G1也不能完全避免Stop-the-world 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
</li>
<li><p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
</li>
<li><p>开发中不要用System.gc();会导致Stop-the-world的发生。</p>
</li>
</ul>
<h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><p>并发(Concurrent)</p>
<ul>
<li><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>
</li>
<li><p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段(时间区间)，然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>
</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/5320C6DE-E06F-4C26-A3B6-84BA848D1746.png" alt="img"></p>
<p>并行(Parallel)</p>
<ul>
<li><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行(Parallel)。</p>
</li>
<li><p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p>
</li>
<li><p>适合科学计算，后台处理等弱交互场景</p>
</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/EFC24AEC-B305-4393-9FC7-2318ABB1DE1C.png" alt="img"></p>
<p>二者对比：</p>
<p>并发，指的是多个事情，在同一时间段内同时发生了。 </p>
<p>并行，指的是多个事情，在同一时间点上同时发生了。</p>
<p>并发的多个任务之间是互相抢占资源的。 </p>
<p>并行的多个任务之间是不互相抢占资源的。</p>
<p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。</p>
<p>否则，看似同时发生的事情，其实都是并发执行的。</p>
<p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下： </p>
<ul>
<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</li>
<li>如ParNew、Parallel Scavenge、Parallel Old；</li>
<li>串行（Serial）</li>
<li>相较于并行的概念，单线程执行。</li>
<li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/AA086057-97E6-41F5-856C-30B26BA8DE3B.png" alt="img"></p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/76C82783-01E7-4626-93B0-DED33483B0AF.png" alt="img"></p>
<ul>
<li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。</li>
<li>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上； </li>
<li>如：CMS、G1</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/B771D5A5-4AFA-4C96-AB39-AAE7F0AF3076.png" alt="img"></p>
<h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><p>安全点(Safepoint)</p>
<p>程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p>
<p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>
<p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<ul>
<li>抢先式中断：（目前没有虚拟机采用了）</li>
</ul>
<p>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p>
<ul>
<li>主动式中断：</li>
</ul>
<p>设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
<p>安全区域(Safe Region)</p>
<p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint 。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。</p>
<p>实际执行时：</p>
<p>1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程；</p>
<p>2、当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</p>
<h3 id="5种引用"><a href="#5种引用" class="headerlink" title="5种引用"></a>5种引用</h3><h4 id="强引用（Strong-Reference）——不回收"><a href="#强引用（Strong-Reference）——不回收" class="headerlink" title="强引用（Strong Reference）——不回收"></a>强引用（Strong Reference）——不回收</h4><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p>
<p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的， 软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p>
<p>强引用例子：</p>
<p>StringBuffer str &#x3D; new StringBuffer (“Hello,尚硅谷”);</p>
<p>局部变量str指向StringBuffer实例所在堆空间，通过str可以操作该实例， 那么str就是StringBuffer实例的强引用</p>
<p>对应内存结构：</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/C82F7271-714C-4AEA-B1D4-1094A30A3097.png" alt="img"></p>
<p>此时，如果再运行一个赋值语句：</p>
<p>StringBuffer str1 &#x3D; str;</p>
<p>对应内存结构：</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/61DCA948-1E49-4394-9AB5-D9190455E121.png" alt="img"></p>
<p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ul>
<li><p>强引用可以直接访问目标对象。</p>
</li>
<li><p>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</p>
</li>
<li><p>强引用可能导致内存泄漏。</p>
</li>
</ul>
<h4 id="软引用（Soft-Reference）—-内存不足即回收"><a href="#软引用（Soft-Reference）—-内存不足即回收" class="headerlink" title="软引用（Soft Reference）— 内存不足即回收"></a>软引用（Soft Reference）— 内存不足即回收</h4><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<p>在JDK 1.2版之后提供了java.lang.ref.SoftReference类来实现软引用。</p>
<p>Object obj &#x3D; new Object(); &#x2F;&#x2F;声明强引用</p>
<p>SoftReference sf &#x3D; new SoftReference(obj);</p>
<p>obj &#x3D; null; &#x2F;&#x2F;销毁强引用</p>
<h4 id="弱引用（Weak-Reference）—发现即回收"><a href="#弱引用（Weak-Reference）—发现即回收" class="headerlink" title="弱引用（Weak Reference）—发现即回收"></a>弱引用（Weak Reference）—发现即回收</h4><p>弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此, 并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p>弱引用非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>在JDK 1.2版之后提供了java.lang.ref.WeakReference类来实现弱引用。 </p>
<p>Object obj &#x3D; new Object(); &#x2F;&#x2F;声明强引用</p>
<p>WeakReference wr &#x3D; new WeakReference(obj);</p>
<p>obj &#x3D; null; &#x2F;&#x2F;销毁强引用</p>
<p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p>
<h4 id="虚引用（Phantom-Reference）—对象回收跟踪"><a href="#虚引用（Phantom-Reference）—对象回收跟踪" class="headerlink" title="虚引用（Phantom Reference）—对象回收跟踪"></a>虚引用（Phantom Reference）—对象回收跟踪</h4><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。</p>
<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p>
<ul>
<li><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
</li>
<li><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>
</li>
<li><p>在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p>
</li>
</ul>
<p>Object obj &#x3D; new Object();<br>ReferenceQueue phantomQueue &#x3D; new ReferenceQueue();</p>
<p>PhantomReference pf &#x3D; new PhantomReference(obj, phantomQueue);</p>
<p>obj &#x3D; null;</p>
<h5 id="终结器引用-Final-reference"><a href="#终结器引用-Final-reference" class="headerlink" title="终结器引用(Final reference)"></a>终结器引用(Final reference)</h5><blockquote>
<p>不太懂</p>
</blockquote>
<ul>
<li><p>它用以实现对象的finalize()方法，也可以称为终结器引用。</p>
</li>
<li><p>无需手动编码，其内部配合引用队列使用。</p>
</li>
<li><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。</p>
</li>
</ul>
<h2 id="3-垃圾回收器"><a href="#3-垃圾回收器" class="headerlink" title="3.垃圾回收器"></a>3.垃圾回收器</h2><h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><ul>
<li>按线程数分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行</strong>垃圾回收器。<ul>
<li>串行回收指的是在同一时间段内<strong>只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停</strong>，直至垃圾收集工作结束。</li>
<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li>
<li>和串行回收相反，并行收集可以<strong>运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐</strong>量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-world”机制。</li>
</ul>
</li>
<li>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器(Stop the world)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/4CE30391-2CA8-4F5D-944A-ADA1DC17B6D7.png" alt="img"></p>
<ul>
<li>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li>
<li>再分配对象空间使用：指针碰撞</li>
<li>非压缩式的垃圾回收器不进行这步操作。</li>
<li>再分配对象空间使用：空闲列表</li>
</ul>
</li>
<li>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</li>
</ul>
<h3 id="GC评估指标"><a href="#GC评估指标" class="headerlink" title="GC评估指标"></a>GC评估指标</h3><p>评估GC的性能指标：吞吐量(throughput)</p>
<ul>
<li><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间 + 垃圾收集时间）。</p>
</li>
<li><p>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
</li>
<li><p>这种情况下，应用程序能容忍较高的暂停时间。因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>
</li>
<li><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 &#x3D; 0.4</p>
</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/2A361A45-E69F-4C28-A37E-C0FE6F4FD6F0.png" alt="img"></p>
<p>评估GC的性能指标：暂停时间(pause time)</p>
<ul>
<li><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p>
</li>
<li><p>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p>
</li>
<li><p>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 &#x3D; 0.5</p>
</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/DAD479EF-C161-4B04-B05F-446CD2AFAF41.png" alt="img"></p>
<p>评估GC的性能指标：吞吐量vs暂停时间</p>
<ul>
<li>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</li>
<li>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</li>
<li>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</li>
<li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
<p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>
<p>现在JVM调优标准：在最大吞吐量优先的情况下，降低停顿时间。</p>
<h3 id="垃圾回收器都有哪些？"><a href="#垃圾回收器都有哪些？" class="headerlink" title="垃圾回收器都有哪些？"></a>垃圾回收器都有哪些？</h3><h4 id="GC发展史"><a href="#GC发展史" class="headerlink" title="GC发展史"></a>GC发展史</h4><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p>
<ul>
<li>1999年随JDK1.3.1一起来的是串行方式的Serial GC ，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li>
<li>2002年2月26日，Parallel GC 和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布</li>
<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>
<li>2012年，在JDK1.7u4版本中，G1可用。-XX:+UseG1GC</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>
<li>2018年3月，JDK 10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为”No-Op（无操作）”回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器(Experimental)。</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC(Experimental)。</li>
<li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</li>
</ul>
<h4 id="查看默认-垃圾回收期"><a href="#查看默认-垃圾回收期" class="headerlink" title="查看默认 垃圾回收期"></a>查看默认 垃圾回收期</h4><ul>
<li><p>-XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p>
</li>
<li><p>使用命令行指令：jinfo –flag 相关垃圾回收器参数 进程ID</p>
</li>
</ul>
<h4 id="Serial-GC：串行回收"><a href="#Serial-GC：串行回收" class="headerlink" title="Serial GC：串行回收"></a>Serial GC：串行回收</h4><ul>
<li>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</li>
<li>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。</li>
<li>Serial 收集器采用复制算法、串行回收和”Stop-the-World”机制的方式执行内存回收。</li>
<li>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old 收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</li>
<li>Serial Old是运行在Client模式下默认的老年代的垃圾回收器</li>
<li>Serial Old在Server模式下主要有两个用途：① 与新生代的Parallel Scavenge配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/72295F87-7087-48CD-8EC1-10C869D5DFAF.png" alt="img"></p>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）。</p>
<ul>
<li><p>优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
</li>
<li><p>运行在Client模式下的虚拟机是个不错的选择。</p>
</li>
<li><p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms）,只要不频繁发生，使用串行回收器是可以接受的</p>
</li>
<li><p>在HotSpot虚拟机中，使用 -XX:+UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器。</p>
</li>
<li><p>等价于 新生代用Serial GC，且老年代用Serial Old GC</p>
</li>
</ul>
<p>总 结：</p>
<p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p>
<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p>
<h4 id="ParNew-GC：并行回收"><a href="#ParNew-GC：并行回收" class="headerlink" title="ParNew GC：并行回收"></a>ParNew GC：并行回收</h4><ul>
<li><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。</p>
</li>
<li><p>Par是Parallel的缩写，New：只能处理的是新生代</p>
</li>
<li><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop-the-World”机制。</p>
</li>
<li><p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p>
</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/0EEF6E42-6FE2-4B7F-9CB4-B7023D94DF25.png" alt="img"></p>
<ul>
<li><p>对于新生代，回收次数频繁，使用并行方式高效。</p>
</li>
<li><p>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p>
</li>
<li><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？ </p>
</li>
<li><p>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</p>
</li>
<li><p>但是在单个CPU的环境下，ParNew收集器不比Serial 收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</p>
</li>
<li><p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p>
</li>
<li><p>在程序中，开发人员可以通过选项”-XX:+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
</li>
<li><p>-XX:ParallelGCThreads 限制线程数量，默认开启和CPU数据相同的线程数。</p>
</li>
</ul>
<h4 id="Parallel-GC：吞吐量优先"><a href="#Parallel-GC：吞吐量优先" class="headerlink" title="Parallel GC：吞吐量优先"></a>Parallel GC：吞吐量优先</h4><ul>
<li><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p>
</li>
<li><p>那么Parallel收集器的出现是否多此一举？</p>
</li>
<li><p>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</p>
</li>
<li><p>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。</p>
</li>
<li><p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</p>
</li>
<li><p>Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-World”机制。</p>
</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/51FA7A77-7AEC-4393-A03B-068153F3F7AB.png" alt="img"></p>
<ul>
<li>在程序吞吐量优先的应用场景中， Parallel 收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。</li>
<li>在Java8中，默认是此垃圾收集器。</li>
</ul>
<p>参数配置：</p>
<ul>
<li><p>-XX:+UseParallelGC  手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p>
</li>
<li><p>-XX:+UseParallelOldGC  手动指定老年代都是使用并行回收收集器。</p>
</li>
<li><p>分别适用于新生代和老年代。默认jdk8是开启的。</p>
</li>
<li><p>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</p>
</li>
<li><p>-XX:ParallelGCThreads 设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p>
</li>
<li><p>在默认情况下，当CPU 数量小于8个， ParallelGCThreads 的值等于CPU 数量。</p>
</li>
<li><p>当CPU数量大于8个，ParallelGCThreads 的值等于3+[5*CPU_Count]&#x2F;8] 。</p>
</li>
<li><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒。</p>
</li>
<li><p>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</p>
</li>
<li><p>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</p>
</li>
<li><p>该参数使用需谨慎。</p>
</li>
<li><p>-XX:GCTimeRatio垃圾收集时间占总时间的比例（&#x3D; 1 &#x2F; (N + 1))。用于衡量吞吐量的大小。</p>
</li>
<li><p>取值范围（0,100）。默认值99，也就是垃圾回收时间不超过1%。</p>
</li>
<li><p>与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p>
</li>
<li><p>-XX:+UseAdaptiveSizePolicy  设置Parallel Scavenge收集器具有自适应调节策略</p>
</li>
<li><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>
</li>
<li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</p>
</li>
</ul>
<h4 id="CMS：低延迟"><a href="#CMS：低延迟" class="headerlink" title="CMS：低延迟"></a>CMS：低延迟</h4><ul>
<li><p>在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS (Concurrent-Mark-Sweep)收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p>
</li>
<li><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
</li>
<li><p>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>
</li>
<li><p>CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-world”</p>
</li>
</ul>
<p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器Parallel Scavenge 配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p>
<p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/C60960D4-7E6D-47E5-9A9A-97BDF215858B.png" alt="img"></p>
<p>初始标记（STW）：暂时时间非常短，标记与GC Roots直接关联的对象。</p>
<p>并发标记（最耗时）：从GC Roots开始遍历整个对象图的过程。不会停顿用户线程</p>
<p>重新标记：（STW）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题</p>
<p>并发清理（最耗时）</p>
<p>CMS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。</p>
<ul>
<li><p>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
</li>
<li><p>并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li><p>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（比如：由不可达变为可达对象的数据），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
</li>
<li><p>并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>
</li>
</ul>
<p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</p>
<p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>
<p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>CMS收集器的垃圾收集算法采用的是标记—清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/1E96FBDC-6BBD-4D46-A28F-8A8474442077.png" alt="img"></p>
<p>有人会觉得既然Mark Sweep会造成内存碎片,那么为什么不把算法换成Mark Compact呢?</p>
<p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark-Compact更适合“Stop the World”这种场景下使用</p>
<p>参数</p>
<ul>
<li><p>-XX:+UseConcMarkSweepGC 手动指定使用CMS 收集器执行内存回收任务。</p>
</li>
<li><p>开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew(Young区用)+CMS(Old区用)+Serial Old的组合。</p>
</li>
<li><p>-XX:CMSlnitiatingOccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p>
</li>
<li><p>JDK5及以前版本的默认值为68,即当老年代的空间使用率达到68%时，会执行一次CMS 回收。JDK6及以上版本默认值为92%</p>
</li>
<li><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC 的执行次数。</p>
</li>
<li><p>-XX:+UseCMSCompactAtFullCollection 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
</li>
<li><p>-XX:CMSFullGCsBeforeCompaction设置在执行多少次Full GC后对内存空间进行压缩整理。</p>
</li>
<li><p>-XX:ParallelCMSThreads 设置CMS的线程数量。</p>
</li>
<li><p>CMS 默认启动的线程数是（ParallelGCThreads+3)&#x2F;4，ParallelGCThreads 是年轻代并行收集器的线程数。当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p>
</li>
<li><p>CMS的优点：</p>
</li>
<li><p>并发收集</p>
</li>
<li><p>低延迟</p>
</li>
<li><p>CMS的弊端：</p>
</li>
</ul>
<p>1）会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</p>
<p>2）CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。 </p>
<p>3）CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</p>
<p>小结：</p>
<p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p>
<p>请记住以下口令：</p>
<p>如果你想要最小化地使用内存和并行开销，请选Serial GC；</p>
<p>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</p>
<p>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</p>
<ul>
<li><p>JDK9新特性：CMS被标记为Deprecate了(JEP291)</p>
</li>
<li><p>如果对JDK 9及以上版本的HotSpot虚拟机使用参数-XX：+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p>
</li>
<li><p>JDK14新特性：删除CMS垃圾回收器(JEP363)</p>
</li>
<li><p>移除了CMS垃圾收集器，如果在JDK14中使用-XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p>
</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/81FB9A33-B3B5-47CA-93A0-47604276E744.png" alt="img"></p>
<h4 id="G1-GC：区域化分代式"><a href="#G1-GC：区域化分代式" class="headerlink" title="G1 GC：区域化分代式"></a>G1 GC：区域化分代式</h4><p>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）GC？</p>
<p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p>
<p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
<p>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</p>
<p>为什么名字叫做Garbage First（G1）呢？</p>
<ul>
<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li>
<li>G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</li>
</ul>
<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p>
<p>在JDK1.7版本正式启用，移除了Experimental的标识，是JDK 9以后的默认垃圾回收器，取代了CMS 回收器以及Parallel + Parallel Old组合。被Oracle官方称为“全功能的垃圾收集器”。</p>
<p>与此同时，CMS已经在JDK 9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-XX:+UseG1GC来启用。</p>
<ul>
<li><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，兼顾吞吐量和停顿时间的GC实现。</p>
</li>
<li><p>在JDK1.7版本正式启用，是JDK 9以后的默认GC选项，取代了CMS 回收器。</p>
</li>
</ul>
<p>与其他 GC 收集器相比，G1使用了全新的分区算法，其特点如下所示：</p>
<ul>
<li>并行与并发</li>
<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
<li>分代收集</li>
<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/33AA5DC7-C392-4CC5-AD5E-7175D11017DF.png" alt="img"></p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/8EAD35DC-5388-43B2-979A-3C29A9203024.png" alt="img"></p>
<ul>
<li><p>空间整合</p>
</li>
<li><p>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</p>
</li>
<li><p>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</p>
</li>
<li><p>可预测的停顿时间模型（即：软实时soft real-time）</p>
</li>
</ul>
<p>这是 G1 相对于 CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p>
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
<p>缺点：</p>
<p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</p>
<p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p>
<p>参数</p>
<ul>
<li>-XX：+UseG1GC  手动指定使用G1收集器执行内存回收任务。</li>
<li>-XX:G1HeapRegionSize  设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</li>
<li>-XX:MaxGCPauseMillis  设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms</li>
<li>-XX:ParallelGCThread  设置STW时GC线程数的值。最多设置为8</li>
<li>-XX:ConcGCThreads  设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1&#x2F;4左右。</li>
<li>-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li>
</ul>
<p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>
<p>第一步：开启G1垃圾收集器</p>
<p>第二步：设置堆的最大内存</p>
<p>第三步：设置最大的停顿时间</p>
<p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。</p>
<p>适用场景</p>
<ul>
<li><p>面向服务端应用，针对具有大内存、多处理器的机器。(在普通大小的堆里表现并不惊喜)</p>
</li>
<li><p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p>
</li>
<li><p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</p>
</li>
<li><p>用来替换掉JDK1.5中的CMS收集器；</p>
<p>在下面的情况时，使用G1可能比CMS好：</p>
<p>① 超过50％的Java堆被活动数据占用；</p>
<p>② 对象分配频率或年代提升频率变化很大；</p>
<p>③ GC停顿时间过长（长于0.5至1秒）。</p>
</li>
<li><p>HotSpot 垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>
</li>
</ul>
<p>web应用，java进程最大堆4G,每分钟1500个请求，45s年轻代的垃圾回收。</p>
<p>31小时使用率达到了45%，则开发并发标记，进行混合回收。</p>
<p>分区Region：化整为零</p>
<p>使用 G1 收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB,2MB,4MB,8MB,16MB,32MB。可以通过-XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/1F15CB6B-AFFC-4E91-B559-D5BD9439D960.png" alt="img"></p>
<ul>
<li>一个 region 有可能属于 Eden，Survivor 或者 Old&#x2F;Tenured 内存区域。但是一个region只可能属于一个角色。图中的 E 表示该region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</li>
<li>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过1.5个region，就放到H。</li>
</ul>
<p>设置H的原因：</p>
<p>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/BA3DBE34-0A0B-457C-92DD-71047A39DA3C.png" alt="img"></p>
<ul>
<li>Bump – the – pointer</li>
</ul>
<p>即：指针碰撞</p>
<ul>
<li>TLAB</li>
</ul>
<h5 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h5><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li><p>年轻代GC （Young GC）</p>
</li>
<li><p>老年代并发标记过程 （Concurrent Marking）</p>
</li>
<li><p>混合回收（Mixed GC）</p>
</li>
<li><p>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p>
</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/73C8F8EF-E187-40EC-A874-D15ADE817EAA.png" alt="img"></p>
<p>顺时针，young gc -&gt; young gc + concurrent mark-&gt; Mixed GC顺序，进行垃圾回收。</p>
<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>
<p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>
<p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
<p>G1回收器垃圾回收过程: Remembered Set</p>
<ul>
<li><p>一个对象被不同区域引用的问题</p>
</li>
<li><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>
</li>
<li><p>在其他的分代收集器，也存在这样的问题（而G1更突出）</p>
</li>
<li><p>回收新生代也不得不同时扫描老年代？</p>
</li>
<li><p>这样的话会降低Minor GC的效率；</p>
</li>
<li><p>解决方法：</p>
</li>
<li><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p>
</li>
<li><p>每个Region都有一个对应的Remembered Set；</p>
</li>
<li><p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p>
</li>
<li><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p>
</li>
<li><p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</p>
</li>
<li><p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
</li>
</ul>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/E18C6693-5088-4107-A16B-D2DC2C648B44.png" alt="img"></p>
<p>G1回收过程一：年轻代GC</p>
<p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p>年轻代垃圾回收只会回收Eden区和Survivor区。</p>
<p>YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/2C4552BD-D607-4090-B935-9C14AADCE0AA.png" alt="img"></p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/1A7D2995-18D8-4164-A620-3140ED4C1D6C.png" alt="img"></p>
<p>然后开始如下回收过程：</p>
<p>第一阶段，扫描根。</p>
<p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>
<p>第二阶段，更新RSet。</p>
<p>处理dirty card queue(见备注)中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p>
<p>第三阶段，处理RSet。</p>
<p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>
<p>第四阶段，复制对象。</p>
<p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p>
<p>第五阶段，处理引用。</p>
<p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
<p>G1回收过程二：并发标记过程</p>
<p>\1. 初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。</p>
<p>\2. 根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。</p>
<p>3.并发标记(Concurrent Marking)：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<p>\4. 再次标记(Remark)： 由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>\5. 独占清理(cleanup,STW)：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。</p>
<ul>
<li>这个阶段并不会实际上去做垃圾的收集</li>
</ul>
<p>\6. 并发清理阶段：识别并清理完全空闲的区域。</p>
<p>G1回收过程三：混合回收</p>
<p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/5E41192B-DAF0-46EA-92AC-A606712BEF68.png" alt="img"></p>
<ul>
<li>并发标记结束以后，老年代中百分百为垃圾的内存region被回收了，部分为垃圾的内存region被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。</li>
<li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。 </li>
<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，-XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li>
<li>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li>
</ul>
<p>G1回收可选的过程四：Full GC</p>
<p> G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc，这种情况可以通过增大内存解决。</p>
<p>导致G1Full GC的原因可能有两个：</p>
<ul>
<li>Evacuation（回收阶段）的时候没有足够的to-space来存放晋升的对象；</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ul>
<p>G1回收器优化建议</p>
<ul>
<li><p>年轻代大小</p>
</li>
<li><p>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</p>
</li>
<li><p>固定年轻代的大小会覆盖暂停时间目标</p>
</li>
<li><p>暂停时间目标不要太过严苛</p>
</li>
<li><p>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</p>
</li>
<li><p>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</p>
</li>
</ul>
<p>补充：</p>
<p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<p>截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/9F7436FA-1263-460B-8B90-9FF09997A055.png" alt="img"></p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/E88AEF3D-6325-468C-A6A3-8A72D0F5FA09.png" alt="img"></p>
<ul>
<li><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</p>
</li>
<li><p>怎么选择垃圾收集器？</p>
</li>
<li><p>优先调整堆的大小让JVM自适应完成。</p>
</li>
<li><p>如果内存小于100M，使用串行收集器</p>
</li>
<li><p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p>
</li>
<li><p>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行收集器</p>
</li>
<li><p>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</p>
</li>
</ul>
<p>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</p>
<p>最后需要明确两个观点：</p>
<ul>
<li>没有最好的收集器，更没有万能的收集；</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ul>
<p>GC新发展</p>
<p>Epsilon GC （<a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/318%EF%BC%89%EF%BC%8C%E5%8F%AA%E5%81%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%8C%E4%B8%8D%E5%81%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84GC%EF%BC%8C%E5%AF%B9%E4%BA%8E%E8%BF%90%E8%A1%8C%E5%AE%8C%E5%B0%B1%E9%80%80%E5%87%BA%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%9D%9E%E5%B8%B8%E9%80%82%E5%90%88%E3%80%82%E7%A7%B0%E4%B8%BA%E6%97%A0%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E3%80%82">http://openjdk.java.net/jeps/318），只做内存分配，不做垃圾回收的GC，对于运行完就退出的程序非常适合。称为无操作的垃圾收集器。</a></p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/810E83B6-A162-4AE3-B741-A67D72B9FA10.png" alt="img"></p>
<p>Open JDK12的Shenandoah GC：低停顿时间的GC（实验性）</p>
<p>Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的HotSpot垃圾收集器。不可避免的受到官方的排挤。比如号称OpenJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p>
<p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</p>
<p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200 MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p>Shenandoah开发团队在实际应用中的测试数据</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/37820614-F3FA-4AD9-96E8-B62A48F285F9.png" alt="img"></p>
<ul>
<li>这是RedHat在2016年发表的论文数据，测试内容是使用ES对200GB的维基百科数据进行索引。从结果看：</li>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ul>
<p>总结：</p>
<p>Shenandoah GC的弱项：高运行负担下的吞吐量下降。</p>
<p>Shenandoah GC的强项：低延迟时间。</p>
<p>Shenandoah GC的工作过程大致分为九个阶段，这里就不再赘述。在之前Java12新特性视频里有过介绍。</p>
<p>令人震惊、革命性的ZGC</p>
<p>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p>
<p>ZGC：是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p>
<p>ZGC的工作过程可以分为4个阶段：并发标记-并发预备重分配-并发重分配-并发重映射等。</p>
<p>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
<p>测试数据：</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/A0E6E745-3E04-4806-974E-CF3F82B3F09D.png" alt="img"></p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/A662402E-A36D-467C-8B8C-2B790B9B1E2E.png" alt="img"></p>
<p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、99%停顿、99.9%停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。</p>
<p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。</p>
<p>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p>
<p>jdk14新特性</p>
<p>JEP 364：ZGC应用在macOS上</p>
<p>JEP 365：ZGC应用在Windows上</p>
<ul>
<li><p>JDK14之前，ZGC仅Linux才支持。</p>
</li>
<li><p>尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</p>
</li>
<li><p>现在mac或Windows上也能使用ZGC了，示例如下：</p>
<p>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</p>
</li>
</ul>
<p>AliGC是阿里巴巴JVM团队基于G1算法， 面向大堆(LargeHeap)应用场景。</p>
<p>指定场景下的对比：</p>
<p><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/80C11308-2458-4EBC-91C9-84DDF40E5725.png" alt="img"><img src="/2022/09/01/7JVM/../../../git-demo/ggq-notes/image/692AC103-F7B2-4639-811E-553475AFA259.png" alt="img"></p>
<p>当然，其他厂商也提供了各种独具一格的GC实现，例如比较有名的低延迟GC，Zing（<a target="_blank" rel="noopener" href="https://www.infoq.com/articles/azul_gc_in_detail%EF%BC%89%EF%BC%8C%E6%9C%89%E5%85%B4%E8%B6%A3%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E6%8F%90%E4%BE%9B%E7%9A%84%E9%93%BE%E6%8E%A5%E3%80%82">https://www.infoq.com/articles/azul_gc_in_detail），有兴趣可以参考提供的链接。</a></p>
<h3 id="各GC使用场景"><a href="#各GC使用场景" class="headerlink" title="各GC使用场景"></a>各GC使用场景</h3><h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><h3 id="GC新发展"><a href="#GC新发展" class="headerlink" title="GC新发展"></a>GC新发展</h3><h2 id="4-分析日志"><a href="#4-分析日志" class="headerlink" title="4.分析日志"></a>4.分析日志</h2><h1 id="JVM面试"><a href="#JVM面试" class="headerlink" title="JVM面试"></a>JVM面试</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="说一下-JVM-的主要组成部分及其作用？"><a href="#说一下-JVM-的主要组成部分及其作用？" class="headerlink" title="说一下 JVM 的主要组成部分及其作用？"></a>说一下 JVM 的主要组成部分及其作用？</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXEa8Kv8ZOMnm82wnHesxe3Wic5UzRaZjIMfTedicYrcOsoeTicy5AvT8EQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p>
<ul>
<li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到运行时数据区中的方法区。</li>
<li>Execution engine（执行引擎）：执行字节码中的指令。</li>
<li>Native Interface(本地接口)：与native libraries交互，是与其它编程语言交互的接口。</li>
<li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li>
</ul>
<p><strong>作用</strong> ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的解释器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h3 id="说一下-JVM-运行时数据区"><a href="#说一下-JVM-运行时数据区" class="headerlink" title="@$说一下 JVM 运行时数据区"></a>@$说一下 JVM 运行时数据区</h3><p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域</strong>。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXs5t1aJQ00noiakZsDdNBBdCnweVXiaTHZsVJcBE6bVoSHicGlb6z4E0tQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>
<ul>
<li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li>
<li>方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>
<li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li>
<li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li>
<li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解释器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li>
</ul>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址</p>
<p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</p>
<p>使用深拷贝的情况下，不会出现浅拷贝时释放同一个内存的错误。</p>
<h3 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h3><table>
<thead>
<tr>
<th></th>
<th>堆</th>
<th>栈</th>
</tr>
</thead>
<tbody><tr>
<td>物理地址</td>
<td>物理地址分配是不连续的，因此性能慢些。在GC的时候需要考虑到不连续的分配，所以有各种垃圾回收算法。</td>
<td>栈使用的是数据结构中的栈，具有先进后出的规则，物理地址分配是连续的，因此性能快</td>
</tr>
<tr>
<td>分配内存时机</td>
<td>堆因为是不连续的，所以分配的内存是在<code>运行期</code>确认的，因此大小不固定。一般堆大小远远大于栈。</td>
<td>栈是连续的，所以分配的内存大小要在<code>编译期</code>就确认，大小是固定的。</td>
</tr>
<tr>
<td>存放的内容</td>
<td>堆存放的是对象的实例和数组。此区域更关注的是数据的存储</td>
<td>栈存放：局部变量，操作数栈，返回结果。此区域更关注的是程序方法的执行。</td>
</tr>
<tr>
<td>程序的可见度</td>
<td>堆对于整个应用程序都是共享的、可见的。</td>
<td>栈对当前线程是可见的，是线程私有。他的生命周期和线程相同。</td>
</tr>
</tbody></table>
<h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="@$对象的创建"></a>@$对象的创建</h3><p>说到对象的创建，首先让我们看看 <code>Java</code> 中提供的几种对象创建方式：</p>
<table>
<thead>
<tr>
<th align="left">Header</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">使用new关键字</td>
<td align="left">调用了构造函数</td>
</tr>
<tr>
<td align="left">使用Class的newInstance方法</td>
<td align="left">调用了构造函数</td>
</tr>
<tr>
<td align="left">使用Constructor类的newInstance方法</td>
<td align="left">调用了构造函数</td>
</tr>
<tr>
<td align="left">使用clone方法</td>
<td align="left">没有调用构造函数</td>
</tr>
<tr>
<td align="left">使用反序列化</td>
<td align="left">没有调用构造函数</td>
</tr>
</tbody></table>
<p>下面是对象创建的主要流程：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomX8c58CfxD8EhVVMic9IhF1KZkClgkcyukAdMy31NG5R5m9XJRFfpIRLQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式：CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后将分配到的内存空间都初始化为零值，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行<code>&lt;init&gt;</code>方法。</p>
<h3 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h3><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：</p>
<ul>
<li>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</li>
<li>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录哪些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</li>
</ul>
<p>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXdCnRdaKdENBLBL4HicNFEUmHWI5ZLExhI6iaZW7b3zVAxYlvysEcwH1w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="处理并发安全问题"><a href="#处理并发安全问题" class="headerlink" title="处理并发安全问题"></a>处理并发安全问题</h3><p>在虚拟机中对象的创建是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p>
<ul>
<li>对内存分配的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+UseTLAB参数来设定虚拟机是否使用TLAB。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXK4yeIuok1b4mbnjPuuibIxLXBZXwOar5CULfkHtPxrQeiaNVyS84xVPw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p><code>Java</code>程序需要通过 <code>JVM</code> 栈上的引用访问堆中的具体对象。对象的访问方式取决于 <code>JVM</code> 虚拟机的实现。目前主流的访问方式有 <strong>句柄</strong> 和 <strong>直接指针</strong> 两种方式。</p>
<blockquote>
<p><strong>指针：</strong> 一种内存地址，代表一个对象在内存中的地址。</p>
<p><strong>句柄：</strong> 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</p>
</blockquote>
<h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><code>Java</code>堆中划分出一块内存来作为<strong>句柄池</strong>，引用中存储对象的<strong>句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与<strong>对象类型数据</strong>各自的<strong>具体地址</strong>信息，具体构造如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXaSZfSDqciaOmaJiaKwsXwS6C9u9ROR8nK0rFzRpnPcQ1jEcXSice0ajyg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>优势</strong>：引用中存储的是<strong>稳定</strong>的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变<strong>句柄中</strong>的<strong>实例数据指针</strong>，而<strong>引用</strong>本身不需要修改。</p>
<h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用<strong>直接指针</strong>访问，<strong>引用</strong> 中存储的直接就是<strong>对象地址</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXYZldH2vnofgQ2uR9ateRiaz1VyCepuHHHJsj4XFHlaSE9TZ54s8yslA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>优势</strong>：速度更<strong>快</strong>，节省了<strong>一次指针定位</strong>的时间开销。由于对象的访问在<code>Java</code>中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
<h2 id="内存溢出异常"><a href="#内存溢出异常" class="headerlink" title="内存溢出异常"></a>内存溢出异常</h2><h3 id="Java会存在内存泄漏吗？请简单描述"><a href="#Java会存在内存泄漏吗？请简单描述" class="headerlink" title="@$Java会存在内存泄漏吗？请简单描述"></a>@$Java会存在内存泄漏吗？请简单描述</h3><p>内存泄漏是指不再被使用的对象或者变量一直存在于内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p>
<p>但是，即使这样，Java也还是存在着内存泄漏的情况，Java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的发生场景。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="简述Java垃圾回收机制，GC是什么？垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#简述Java垃圾回收机制，GC是什么？垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="简述Java垃圾回收机制，GC是什么？垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"></a>简述Java垃圾回收机制，GC是什么？垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</h3><p>Java垃圾回收机制：GC 是垃圾收集的意思（Gabage Collection），在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行，这就是垃圾回收机制，垃圾回收机制有效的防止了内存泄露</p>
<p>垃圾回收器的基本原理：在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<p>垃圾回收器可以马上回收内存吗？：程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。但可以手动执行System.gc()主动通知虚拟机进行垃圾回收，但是Java语言规范并不能保证GC一定会执行。</p>
<h3 id="Java-中都有哪些引用类型？强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？"><a href="#Java-中都有哪些引用类型？强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？" class="headerlink" title="Java 中都有哪些引用类型？强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？"></a>Java 中都有哪些引用类型？强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？</h3><p>在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用，根据其生命周期的长短，将引用分为4类。</p>
<p>不同的引用类型，主要体现的是对象不同的可达性状态和对垃圾收集的影响。</p>
<ul>
<li>强引用：最常见的普通对象引用，通过关键字new创建的对象所关联的引用就是强引用，发生 gc 的时候不会被回收。</li>
<li>软引用：软引用的生命周期比强引用短一些。有用但不是必须的对象，在发生内存溢出之前会被回收。应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li>
<li>弱引用：弱引用的生命周期比软引用短。有用但不是必须的对象，在下一次GC时会被回收。应用场景：弱应用同样可用于内存敏感的缓存。</li>
<li>虚引用（幽灵引用&#x2F;幻象引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用。应用场景：虚引用的用途是在这个对象被 gc 时返回一个系统通知。</li>
</ul>
<h3 id="怎么判断对象是否可以被回收？在Java中，对象什么时候可以被垃圾回收"><a href="#怎么判断对象是否可以被回收？在Java中，对象什么时候可以被垃圾回收" class="headerlink" title="怎么判断对象是否可以被回收？在Java中，对象什么时候可以被垃圾回收"></a>怎么判断对象是否可以被回收？在Java中，对象什么时候可以被垃圾回收</h3><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。</p>
<p>一般有两种方法来判断：</p>
<ul>
<li>引用计数器法：为每个对象创建一个引用计数器，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析算法：当一个对象到GC Roots不可达时，在下一个垃圾回收周期中尝试回收该对象。定义一系列的 GC ROOT 为起点。从起点开始向下开始搜索，搜索走过的路径称为引用链。当一个对象到 GC ROOT没有任何引用链相连的话，则对象可以判定是可以被回收的。</li>
</ul>
<p>可达性分析算法详答</p>
<ol>
<li>当不能从GC Root寻找一条路径到达该对象时，将进行第一次标记。</li>
<li>第一次标记后检查对象是否重写了finalize() 和是否已经被调用了finalize()方法。若没有重写finalize()方法或已经被调用，则进行回收。</li>
<li>在已经重写finalize()方法且未调用的情况下，将对象加入一个F-Queue 的队列中，稍后进行第二次检查</li>
<li>在第二次标记之前，对象如果执行finalize()方法并完成自救，对象则不会被回收。否则完成第二次标记，进行回收。值得注意的是finalize()方法并不可靠。</li>
</ol>
<p>虚拟机默认采用的是可达性分析算法。</p>
<p>可以作为 GC ROOT 的对象包括：</p>
<ol>
<li>栈中引用的对象；</li>
<li>静态变量、常量引用的对象；</li>
<li>本地方法栈 native 方法引用的对象。</li>
</ol>
<h3 id="JVM中的永久代中会发生垃圾回收吗"><a href="#JVM中的永久代中会发生垃圾回收吗" class="headerlink" title="JVM中的永久代中会发生垃圾回收吗"></a>JVM中的永久代中会发生垃圾回收吗</h3><p>垃圾回收一般不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。通过查看垃圾收集器的输出信息，就会发现永久代也是被回收的。所以正确的设置永久代大小可以有效避免Full GC。</p>
<p>Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区，现在大多数的类元数据分配在本地化内存中。</p>
<h3 id="说一下-JVM-有哪些垃圾回收算法？"><a href="#说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="@$说一下 JVM 有哪些垃圾回收算法？"></a>@$说一下 JVM 有哪些垃圾回收算法？</h3><ul>
<li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li>
<li>复制算法：按照容量划分两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的那块内存空间清理掉。缺点：内存使用率不高，只有原来的一半。</li>
<li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后清除掉端边界以外的内存。</li>
<li>分代收集算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代采用复制算法，老年代采用标记整理算法。</li>
</ul>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记无用对象，然后进行清除回收。</p>
<p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p>
<ul>
<li>标记阶段：标记出可以回收的对象。</li>
<li>清除阶段：回收被标记的对象所占用的空间。</li>
</ul>
<p>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。</p>
<p><strong>优点</strong>：实现简单，不需要对象进行移动。</p>
<p><strong>缺点</strong>：由于标记的过程需要遍历所有的 GC ROOT，清除的过程也要遍历堆中所有的对象，标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</p>
<p>标记-清除算法的执行的过程如下图所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXLKJpNtaFCicWvns6iaKNZdTnic3jtbPKUMKpHyQM74WBw55fWx92xtiaEA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="复制算法-1"><a href="#复制算法-1" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将已使用的内存空间一次清理掉。</p>
<p><strong>优点</strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p><strong>缺点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p>
<p>复制算法的执行过程如下图所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXv0K4YhDVzvoWAp5IiaF7U9rSsvK3M6Qe7m6CW4qKsGbUZic1QPLqicnfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-清除算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。</p>
<p><strong>优点</strong>：解决了标记-清除算法存在的内存碎片问题。</p>
<p><strong>缺点</strong>：需要进行局部对象移动，一定程度上降低了效率。</p>
<p>标记-整理算法的执行过程如下图所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXyCmOw29Y4K3WrWxBoxKm5MI8CAEYZ8XWHQiap0PMf2felI4ZSicnQzoQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="分代收集算法-1"><a href="#分代收集算法-1" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前商业虚拟机都采用<strong>分代收集</strong>的垃圾收集算法。分代收集算法，顾名思义是根据对象的<strong>存活周期</strong>将内存划分为几块。一般包括<strong>新生代</strong>、<strong>老年代</strong>，新生代采用复制算法，老年代采用标记-整理算法，注：Java8中已经移除了永久代，添加了元数据区。如图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomX7rZsMEDAeDxYrHicrWVuJ4pOP19ClXowqPjvjMEF621vTg3pF0EiaG8Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>垃圾收集算法小结</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXV4JWu6zkISbOtt31ibdTsBLXmbG0kbhaDW1pOW8eZ8FfQGxqibYj4Svw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="说一下-JVM-有哪些垃圾回收器？"><a href="#说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="@$说一下 JVM 有哪些垃圾回收器？"></a>@$说一下 JVM 有哪些垃圾回收器？</h3><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、ParNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXFaXfibnDGQcjTKKM4lEos531aV0azRpCYvBPzFmibLfUH7zcxa9aE8TA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li>Serial收集器(复制算法)：新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
<li>ParNew收集器 (复制算法)：新生代并行收集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li>Parallel Scavenge收集器 (复制算法)：新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li>
<li>Serial Old收集器 (标记-整理算法)：老年代单线程收集器，Serial收集器的老年代版本；</li>
<li>Parallel Old收集器 (标记-整理算法)：老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
<li>CMS(Concurrent Mark Sweep)收集器(标记-清除算法)：老年代并行收集器，追求最短GC回收停顿时间，具有高并发、低停顿的特点；</li>
<li>G1(Garbage First)收集器 (标记-整理算法)：Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<h3 id="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</h3><ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS</li>
<li>整堆回收器：G1</li>
</ul>
<p><strong>新生代垃圾回收器一般采用的是复制算法</strong></p>
<p><strong>老年代垃圾回收器一般采用的是标记-整理的算法</strong></p>
<h3 id="详细介绍一下-CMS-垃圾回收器？"><a href="#详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="详细介绍一下 CMS 垃圾回收器？"></a>详细介绍一下 CMS 垃圾回收器？</h3><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。</p>
<p>在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<p>CMS 收集器是以获取最短停顿时间为目标的收集器。相对于其他的收集器 STW 的时间更短暂，可以并行收集是它的特点，同时它基于<strong>标记-清除</strong>算法。整个 GC 过程分为4步：</p>
<ol>
<li><strong>初始标记</strong>：标记 GC ROOT 能关联到的对象，需要 STW；</li>
<li><strong>并发标记</strong>：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，不需要 STW；</li>
<li><strong>重新标记</strong>：为了修正并发标记期间，因用户程序继续运作而导致标记产生改变的标记，需要 STW；</li>
<li><strong>并发清除</strong>：清理删除掉标记阶段判断的已经死亡的对象，不需要 STW。</li>
</ol>
<p>从整个过程来看，并发标记和并发清除的耗时最长，但是不需要停止用户线程。而初始标记和重新标记的耗时较短，但是需要停止用户线程。总体而言，整个过程造成的停顿时间较短，大部分时候是可以和用户线程一起工作的。</p>
<h3 id="G1垃圾回收器的原理了解吗？"><a href="#G1垃圾回收器的原理了解吗？" class="headerlink" title="G1垃圾回收器的原理了解吗？"></a>G1垃圾回收器的原理了解吗？</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXEQLNIVP4sNv7dALQWWJtKzCAK0JFF8qSoiaZSkRZIpyfEaLsK4pT3kA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>G1 作为 JDK9 之后的服务端默认收集器，不再区分年轻代和老年代进行垃圾回收。</p>
<p>把内存划分为多个 Region，每个 Region 的大小可以通过 <strong>-XX:G1HeapRegionSize</strong> 设置，大小为1~32M。</p>
<p>对于大对象的存储则衍生出 <strong>Humongous</strong> 的概念。超过 Region 大小一半的对象会被认为是大对象，而超过整个 Region 大小的对象被认为是超级大对象，将会被存储在连续的 N 个 Humongous Region 中。</p>
<p>G1 在进行回收的时候会在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先回收收益最大的 Region。</p>
<p>G1 的回收过程分为以下四个步骤：</p>
<ol>
<li><strong>初始标记</strong>：标记 GC ROOT 能关联到的对象，需要 STW；</li>
<li><strong>并发标记</strong>：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，扫描完成后还会重新处理并发标记过程中产生变动的对象；</li>
<li><strong>最终标记</strong>：短暂暂停用户线程，再处理一次，需要 STW；</li>
<li><strong>筛选回收</strong>：更新 Region 的统计数据，对每个 Region 的回收价值和成本排序，根据用户设置的停顿时间制定回收计划。再把Region 中存活对象复制到空的 Region，同时清理旧的 Region。需要 STW。</li>
</ol>
<p>总的来说除了并发标记之外，其他几个过程也还是需要短暂的 STW。G1 的目标是在停顿和延迟可控的情况下尽可能提高吞吐量。</p>
<h3 id="简述分代垃圾回收器是怎么工作的？"><a href="#简述分代垃圾回收器是怎么工作的？" class="headerlink" title="简述分代垃圾回收器是怎么工作的？"></a>简述分代垃圾回收器是怎么工作的？</h3><p>根据对象的<strong>存活周期</strong>将堆内存划分：老年代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老年代的默认占比是 2&#x2F;3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、From Survivor、To Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<ul>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li>
</ul>
<p>每次在 From Survivor 到 To Survivor 移动存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老年代。大对象会直接进入老年代。</p>
<p>老年代当空间占用到达某个值之后就会触发全局垃圾回收，一般使用标记整理算法。</p>
<p>以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="简述java内存分配与回收策略以及Minor-GC和Major-GC"><a href="#简述java内存分配与回收策略以及Minor-GC和Major-GC" class="headerlink" title="@$简述java内存分配与回收策略以及Minor GC和Major GC"></a>@$简述java内存分配与回收策略以及Minor GC和Major GC</h3><p>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。</p>
<p>对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，则线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：</p>
<h4 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h4><p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p>
<p>这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC&#x2F;Full GC。</p>
<ul>
<li><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所以 Minor GC 非常频繁，一般回收速度也非常快；</li>
<li><strong>Major GC&#x2F;Full GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</li>
</ul>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC，以获取足够的连续空间来安置新对象。</p>
<p>新生代使用的是复制算法，如果大对象直接在新生代分配，就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制，因此对于大对象都会直接在老年代进行分配。</p>
<h4 id="长期存活对象将进入老年代"><a href="#长期存活对象将进入老年代" class="headerlink" title="长期存活对象将进入老年代"></a>长期存活对象将进入老年代</h4><p>虚拟机采用分代收集的思想来管理内存，会给每个对象定义了一个对象年龄的计数器，对象在 Eden 区出生，经过一次 Minor GC 对象年龄就会加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代，也就是长期存活对象将进入老年代。</p>
<h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><h3 id="简述Java类加载机制？类加载机制的原理"><a href="#简述Java类加载机制？类加载机制的原理" class="headerlink" title="简述Java类加载机制？类加载机制的原理"></a>简述Java类加载机制？类加载机制的原理</h3><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行，同时对数据进行验证，准备，解析和初始化，最终形成可以被虚拟机直接使用的类型。</p>
<p>类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的需求，像是反射，就需要显式的加载所需要的类。</p>
<p>类装载方式，有两种 ：</p>
<ul>
<li><p>隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中</p>
</li>
<li><p>显式装载， 通过class.forname()等方法，显式加载需要的类</p>
</li>
</ul>
<p>Java中类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载，这是为了节省内存开销。</p>
<h3 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h3><p>类加载器负责将字节码文件的类加载到虚拟机内存中。</p>
<p>主要有一下四种类加载器:</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：用来加载Java核心类库，无法被Java程序直接引用。即用来加载JAVA_HOME&#x2F;jre&#x2F;lib目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>
<li>扩展类加载器（Extension ClassLoader）：用来加载 Java 的扩展库。负责加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录或-Djava.ext.dir系统变量指定的路径中的所有类库；</li>
<li>应用程序类加载器（Application ClassLoader）：用来加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器，默认就是用这个加载器。</li>
<li>用户自定义类加载器：通过继承 java.lang.ClassLoader类的方式实现用户自定义类加载器。</li>
</ul>
<h3 id="说一下类装载的执行过程？"><a href="#说一下类装载的执行过程？" class="headerlink" title="说一下类装载的执行过程？"></a>说一下类装载的执行过程？</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXLDpq2wiaJcNFTgMjQ0OzAjXKyAqIcMOuqA0EoAR4TiaqqoU9ScIYGA7g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>类装载分为以下 5 个步骤：</p>
<ul>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>验证：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用可以理解为一个标识，而直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ul>
<h3 id="什么是双亲委派模型？双亲委派模型工作流程是怎样的？双亲委派模型的好处是什么？"><a href="#什么是双亲委派模型？双亲委派模型工作流程是怎样的？双亲委派模型的好处是什么？" class="headerlink" title="@$什么是双亲委派模型？双亲委派模型工作流程是怎样的？双亲委派模型的好处是什么？"></a>@$什么是双亲委派模型？双亲委派模型工作流程是怎样的？双亲委派模型的好处是什么？</h3><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomX5PbQKcQk0bTFSSylLbuDUG9Ndggu9yNKlf4PC6CHa7k32Tj1evtsRA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去加载，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载器无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载此类。</p>
<p><strong>自下而上检查类是否已经被加载，自上而下尝试加载类</strong></p>
<p>双亲委派模型工作流程：</p>
<ol>
<li>当Application ClassLoader 收到一个类加载请求时，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器Extension ClassLoader去完成。</li>
<li>当Extension ClassLoader收到一个类加载请求时，他首先也不会自己去尝试加载这个类，而是将请求委派给父类加载器Bootstrap ClassLoader去完成。 </li>
<li>Bootstrap ClassLoader尝试加载此类，如果Bootstrap ClassLoader加载失败，就会让Extension ClassLoader尝试加载。</li>
<li>Extension ClassLoader尝试加载此类，如果Extension ClassLoader也加载失败，就会让Application ClassLoader尝试加载。</li>
<li>Application ClassLoader尝试加载此类，如果Application ClassLoader也加载失败，就会让自定义加载器尝试加载。</li>
<li>如果均加载失败，就会抛出ClassNotFoundException异常。</li>
</ol>
<p>双亲委派模型的好处：<strong>保证核心类库不被覆盖</strong>。如果没有使用双亲委派模型，由各个类加载器自行加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统将会出现多个不同的Object类， Java类型体系中最基础的行为就无法保证，应用程序也将会变得一片混乱。</p>
<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h3 id="说一下-JVM-调优的工具？"><a href="#说一下-JVM-调优的工具？" class="headerlink" title="说一下 JVM 调优的工具？"></a>说一下 JVM 调优的工具？</h3><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款可视化监控工具。</p>
<ul>
<li>jconsole：JDK 自带的可视化管理工具，用于对 JVM 中的内存、线程和类等进行监控，对垃圾回收算法有很详细的跟踪，功能简单；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等，功能强大。</li>
</ul>
<p>常用的故障检测，监视，修理工具</p>
<table>
<thead>
<tr>
<th>工具名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>jps (JVM Process Status Tool)</td>
<td>显示系统中所有的虚拟机进程</td>
</tr>
<tr>
<td>jstat (JVM Statistics Monitoring Tool)</td>
<td>收集虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo (Configuration Info for Java)</td>
<td>显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap (Memory Map for Java)</td>
<td>生成虚拟机的内存转储快照</td>
</tr>
<tr>
<td>jhat (JVM Heap Dump Browser)</td>
<td>分析堆内存转储快照，不推荐使用，消耗资源而且慢</td>
</tr>
<tr>
<td>jstack (Stack Trace for Java）</td>
<td>显示线程堆栈快照</td>
</tr>
</tbody></table>
<h3 id="谈谈你的GC调优思路"><a href="#谈谈你的GC调优思路" class="headerlink" title="谈谈你的GC调优思路?"></a>谈谈你的GC调优思路?</h3><p>谈到调优，这一定是针对特定场景、特定目的的事情， 对于 GC 调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput）</p>
<p>基本的调优思路可以总结为：</p>
<ul>
<li>理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。</li>
<li>掌握 JVM 和 GC 的状态，定位具体问题，确定是否有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。</li>
<li>接着需要思考选择的 GC 类型是否符合我们的应用特征，具体问题表现在哪里。是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。</li>
<li>通过分析确定具体调整的参数或者软硬件配置。</li>
<li>验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复进行分析、调整、验证。</li>
</ul>
<h3 id="常用的-JVM-调优的参数都有哪些？"><a href="#常用的-JVM-调优的参数都有哪些？" class="headerlink" title="@$常用的 JVM 调优的参数都有哪些？"></a>@$常用的 JVM 调优的参数都有哪些？</h3><p>1、性能调优要做到有的放矢，根据实际业务系统的特点，以一定时间的JVM日志记录为依据，进行有针对性的调整、比较和观察。</p>
<p>2、性能调优是个无止境的过程，要综合权衡调优成本和更换硬件成本的大小，使用最经济的手段达到最好的效果。</p>
<p>3、性能调优不仅仅包括JVM的调优，还有服务器硬件配置、操作系统参数、中间件线程池、数据库连接池、数据库本身参数以及具体的数据库表、索引、分区等的调整和优化。</p>
<p>4、通过特定工具检查代码中存在的性能问题并加以修正是一种比较经济快捷的调优方法。</p>
<p>常用的 JVM 调优的参数</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmknsuwutmtEnNxLTNJ1qaomXw2zEEZiczfGl5U8hOlhJ3vTTGzX4l3Djt7IJnTX2dMDjczVxxnEdG1w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li><p>-Xms2g：初始化堆大小为 2g；</p>
</li>
<li><p>-Xmx2g：堆最大内存为 2g；</p>
</li>
<li><p>-Xmn1g：新生代内存大小为1g；-XX:NewSize 新生代大小，-XX:MaxNewSize 新生代最大值，-Xmn 则是相当于同时配置 -XX:NewSize 和 -XX:MaxNewSize 为一样的值；</p>
</li>
<li><p>-XX:NewRatio&#x3D;2：设置新生代的和老年代的内存比例为 1:2，即新生代占堆内存的1&#x2F;3，老年代占堆内存的2&#x2F;3；</p>
</li>
<li><p>-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 两个Survivor 比例为 8:1:1；</p>
</li>
<li><p>–XX:+UseParNewGC：对新生代使用并行垃圾回收器。</p>
</li>
<li><p>-XX:+UseParallelOldGC：对老年代并行垃圾回收器。</p>
</li>
<li><p>-XX:+UseConcMarkSweepGC：以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。</p>
</li>
<li><p>-XX:+PrintGC：开启打印 gc 信息；</p>
</li>
<li><p>-XX:+PrintGCDetails：打印 gc 详细信息。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io">ggq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io/2022/09/01/7JVM/">https://gouguoqiang.github.io/2022/09/01/7JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gouguoqiang.github.io" target="_blank">ggq</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/01/5redis/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">redis</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/01/9MicroService/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">微服务</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ggq</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AD%97%E8%8A%82%E7%A0%81%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">第一章 字节码篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">分析一个对象的创建字节码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.</span> <span class="toc-text">第二章 类的加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 类加载器子系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8ClassLoader%E8%A7%92%E8%89%B2"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 类加载器ClassLoader角色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2. 类加载过程(生命周期)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-Resolve"><span class="toc-number">2.2.0.1.1.</span> <span class="toc-text">解析(Resolve)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">2.3. 初始化阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA"><span class="toc-number">2.2.0.2.1.</span> <span class="toc-text">类的初始化时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#clinit"><span class="toc-number">2.2.0.2.2.</span> <span class="toc-text">clinit()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8vs%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.0.2.3.</span> <span class="toc-text">类的初始化情况：主动使用vs被动使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.2.0.2.4.</span> <span class="toc-text">主动使用的说明：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.2.0.2.5.</span> <span class="toc-text">被动使用的情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">2.4. 类的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="toc-number">2.2.0.4.</span> <span class="toc-text">2.5. 类的卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.0.5.</span> <span class="toc-text">2.6. 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3. 类的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%88%86%E7%B1%BB%EF%BC%9A%E6%98%BE%E5%BC%8F%E5%8A%A0%E8%BD%BD-vs-%E9%9A%90%E5%BC%8F%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. 类的加载分类：显式加载 vs 隐式加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. 类加载机制的必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%B1%BB%E6%98%AF%E5%94%AF%E4%B8%80%E7%9A%84%E5%90%97"><span class="toc-number">2.3.3.</span> <span class="toc-text">3. 加载的类是唯一的吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.3.4.</span> <span class="toc-text">4. 类加载的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E8%AF%B4%E6%98%8E"><span class="toc-number">2.3.5.</span> <span class="toc-text">5. 类加载器的分类说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%88%B6%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">子父类的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8CBootstrap-ClassLoader%EF%BC%89"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">启动类加载器（引导类加载器，Bootstrap ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Extension-ClassLoader%EF%BC%89"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">扩展类加载器（Extension ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8CAppClassLoader%EF%BC%89"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">应用程序类加载器（系统类加载器，AppClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.3.5.5.</span> <span class="toc-text">用户自定义类加载器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-cl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">4. cl源码剖析及相关机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">3.</span> <span class="toc-text">第三章 运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Program-Counter-Register%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">1. 程序计数寄存器（Program Counter Register）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JVM%E6%A0%88"><span class="toc-number">3.2.</span> <span class="toc-text">2. JVM栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">栈帧内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E6%A6%82%E8%BF%B0"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">0. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">1. 局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#slot"><span class="toc-number">3.2.2.2.1.</span> <span class="toc-text">slot</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">2. 操作数栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">3. 动态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.2.5.</span> <span class="toc-text">4. 方法返回地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-number">3.2.2.6.</span> <span class="toc-text">5. 一些附加信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.3.</span> <span class="toc-text">面试扩展问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">3.3.</span> <span class="toc-text">3. 本地方法接口与本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A0%86"><span class="toc-number">3.4.</span> <span class="toc-text">4. 堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.2.</span> <span class="toc-text">堆的内部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-number">3.4.3.</span> <span class="toc-text">如何设置堆内存大小？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3%E6%AF%94%E4%BE%8B%EF%BC%9F"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">如何设置新生代与老年代比例？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEEden%E3%80%81%E5%B9%B8%E5%AD%98%E8%80%85%E5%8C%BA%E6%AF%94%E4%BE%8B%EF%BC%9F"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">如何设置Eden、幸存者区比例？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OOM%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">OOM举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E5%B0%8F%E7%BB%93"><span class="toc-number">3.4.3.4.</span> <span class="toc-text">参数设置小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D"><span class="toc-number">3.4.4.</span> <span class="toc-text">对象分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">3.4.4.0.1.</span> <span class="toc-text">空间分配担保</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">3.5.</span> <span class="toc-text">5. 方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.5.1.</span> <span class="toc-text">1. 栈、堆、方法区的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFTLAB%EF%BC%9F"><span class="toc-number">3.5.2.</span> <span class="toc-text">2. 什么是TLAB？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">3.5.3.</span> <span class="toc-text">3. 方法区在哪里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.5.4.</span> <span class="toc-text">4. 方法区的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">3.5.5.</span> <span class="toc-text">5. 方法区的演进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.5.6.</span> <span class="toc-text">6. 设置方法区内存的大小</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">4.</span> <span class="toc-text">第四章 对象的内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">1. 对象的实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%9C%89%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 有几种创建对象的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2 创建对象的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8B%E5%BE%85%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-%E8%A7%81%E5%AD%97%E8%8A%82%E7%A0%81%E7%AF%87"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">1.2.1 从字节码角度看待对象创建过程 : 见字节码篇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E4%BB%8E%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">1.2.2 从执行步骤角度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">4.2.</span> <span class="toc-text">2. 对象的内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.3.</span> <span class="toc-text">3. 对象的访问定位</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E7%AF%87"><span class="toc-number">5.</span> <span class="toc-text">第五章 执行引擎篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87"><span class="toc-number">6.</span> <span class="toc-text">第六章 垃圾回收篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">1.垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.1标记算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">1.1.1引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">1.1.2可达性分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#GC-root"><span class="toc-number">6.1.1.2.1.</span> <span class="toc-text">GC root</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STW"><span class="toc-number">6.1.1.2.2.</span> <span class="toc-text">STW</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">1.2.清除算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">标记清除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">标记压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.2.4.</span> <span class="toc-text">分代收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.2.5.</span> <span class="toc-text">增量收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.2.6.</span> <span class="toc-text">分区算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">6.2.</span> <span class="toc-text">2.相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System-gc"><span class="toc-number">6.2.1.</span> <span class="toc-text">System.gc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.2.2.</span> <span class="toc-text">finalize()方法详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">6.2.3.</span> <span class="toc-text">内存泄漏与内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STW-1"><span class="toc-number">6.2.4.</span> <span class="toc-text">STW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">6.2.5.</span> <span class="toc-text">垃圾回收的并行与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">6.2.6.</span> <span class="toc-text">安全点与安全区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">6.2.7.</span> <span class="toc-text">5种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89%E2%80%94%E2%80%94%E4%B8%8D%E5%9B%9E%E6%94%B6"><span class="toc-number">6.2.7.1.</span> <span class="toc-text">强引用（Strong Reference）——不回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89%E2%80%94-%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E5%8D%B3%E5%9B%9E%E6%94%B6"><span class="toc-number">6.2.7.2.</span> <span class="toc-text">软引用（Soft Reference）— 内存不足即回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Reference%EF%BC%89%E2%80%94%E5%8F%91%E7%8E%B0%E5%8D%B3%E5%9B%9E%E6%94%B6"><span class="toc-number">6.2.7.3.</span> <span class="toc-text">弱引用（Weak Reference）—发现即回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88Phantom-Reference%EF%BC%89%E2%80%94%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E8%B7%9F%E8%B8%AA"><span class="toc-number">6.2.7.4.</span> <span class="toc-text">虚引用（Phantom Reference）—对象回收跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8-Final-reference"><span class="toc-number">6.2.7.4.1.</span> <span class="toc-text">终结器引用(Final reference)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">3.垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E5%88%86%E7%B1%BB"><span class="toc-number">6.3.1.</span> <span class="toc-text">GC分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87"><span class="toc-number">6.3.2.</span> <span class="toc-text">GC评估指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.3.3.</span> <span class="toc-text">垃圾回收器都有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">GC发展史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%9F"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">查看默认 垃圾回收期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-GC%EF%BC%9A%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">Serial GC：串行回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew-GC%EF%BC%9A%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="toc-number">6.3.3.4.</span> <span class="toc-text">ParNew GC：并行回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-GC%EF%BC%9A%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">6.3.3.5.</span> <span class="toc-text">Parallel GC：吞吐量优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%EF%BC%9A%E4%BD%8E%E5%BB%B6%E8%BF%9F"><span class="toc-number">6.3.3.6.</span> <span class="toc-text">CMS：低延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1-GC%EF%BC%9A%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F"><span class="toc-number">6.3.3.7.</span> <span class="toc-text">G1 GC：区域化分代式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">6.3.3.7.1.</span> <span class="toc-text">垃圾回收过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84GC%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.3.4.</span> <span class="toc-text">各GC使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-number">6.3.5.</span> <span class="toc-text">如何选择？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E6%96%B0%E5%8F%91%E5%B1%95"><span class="toc-number">6.3.6.</span> <span class="toc-text">GC新发展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97"><span class="toc-number">6.4.</span> <span class="toc-text">4.分析日志</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E9%9D%A2%E8%AF%95"><span class="toc-number">7.</span> <span class="toc-text">JVM面试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">7.1.</span> <span class="toc-text">Java内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">7.1.1.</span> <span class="toc-text">说一下 JVM 的主要组成部分及其作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">7.1.2.</span> <span class="toc-text">@$说一下 JVM 运行时数据区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">7.1.3.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%A0%86%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.1.4.</span> <span class="toc-text">说一下堆栈的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98"><span class="toc-number">7.2.</span> <span class="toc-text">HotSpot虚拟机对象探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">7.2.1.</span> <span class="toc-text">@$对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">7.2.2.</span> <span class="toc-text">为对象分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.3.</span> <span class="toc-text">处理并发安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">7.2.4.</span> <span class="toc-text">对象的访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE"><span class="toc-number">7.2.4.1.</span> <span class="toc-text">句柄访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88"><span class="toc-number">7.2.4.2.</span> <span class="toc-text">直接指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">7.3.</span> <span class="toc-text">内存溢出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%90%97%EF%BC%9F%E8%AF%B7%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0"><span class="toc-number">7.3.1.</span> <span class="toc-text">@$Java会存在内存泄漏吗？请简单描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%8CGC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%AF%E4%BB%A5%E9%A9%AC%E4%B8%8A%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E4%B8%BB%E5%8A%A8%E9%80%9A%E7%9F%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">7.4.1.</span> <span class="toc-text">简述Java垃圾回收机制，GC是什么？垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.4.2.</span> <span class="toc-text">Java 中都有哪些引用类型？强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">7.4.3.</span> <span class="toc-text">怎么判断对象是否可以被回收？在Java中，对象什么时候可以被垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E4%B8%AD%E7%9A%84%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%AD%E4%BC%9A%E5%8F%91%E7%94%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%90%97"><span class="toc-number">7.4.4.</span> <span class="toc-text">JVM中的永久代中会发生垃圾回收吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">7.4.5.</span> <span class="toc-text">@$说一下 JVM 有哪些垃圾回收算法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.5.1.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95-1"><span class="toc-number">7.4.5.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.5.3.</span> <span class="toc-text">标记-整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95-1"><span class="toc-number">7.4.5.4.</span> <span class="toc-text">分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">7.4.6.</span> <span class="toc-text">@$说一下 JVM 有哪些垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.4.7.</span> <span class="toc-text">新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">7.4.8.</span> <span class="toc-text">详细介绍一下 CMS 垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">7.4.9.</span> <span class="toc-text">G1垃圾回收器的原理了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">7.4.10.</span> <span class="toc-text">简述分代垃圾回收器是怎么工作的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">7.5.</span> <span class="toc-text">内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8AMinor-GC%E5%92%8CMajor-GC"><span class="toc-number">7.5.1.</span> <span class="toc-text">@$简述java内存分配与回收策略以及Minor GC和Major GC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-Eden-%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">7.5.1.1.</span> <span class="toc-text">对象优先在 Eden 区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">7.5.1.2.</span> <span class="toc-text">大对象直接进入老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">7.5.1.3.</span> <span class="toc-text">长期存活对象将进入老年代</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">7.6.</span> <span class="toc-text">虚拟机类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.6.1.</span> <span class="toc-text">简述Java类加载机制？类加载机制的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">7.6.2.</span> <span class="toc-text">什么是类加载器，类加载器有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">7.6.3.</span> <span class="toc-text">说一下类装载的执行过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.6.4.</span> <span class="toc-text">@$什么是双亲委派模型？双亲委派模型工作流程是怎样的？双亲委派模型的好处是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98"><span class="toc-number">7.7.</span> <span class="toc-text">JVM调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-number">7.7.1.</span> <span class="toc-text">说一下 JVM 调优的工具？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84GC%E8%B0%83%E4%BC%98%E6%80%9D%E8%B7%AF"><span class="toc-number">7.7.2.</span> <span class="toc-text">谈谈你的GC调优思路?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">7.7.3.</span> <span class="toc-text">@$常用的 JVM 调优的参数都有哪些？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/01/%E7%AE%97%E6%B3%95/7%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/AcWing/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/02/01/%E7%AE%97%E6%B3%95/7%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/AcWing/" title="无题">无题</a><time datetime="2023-02-01T15:55:11.432Z" title="发表于 2023-02-01 23:55:11">2023-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/31/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/ruiji/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/01/31/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/ruiji/" title="无题">无题</a><time datetime="2023-01-31T14:50:49.607Z" title="发表于 2023-01-31 22:50:49">2023-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/21/%E7%AE%97%E6%B3%95/00pythonapi/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/12/21/%E7%AE%97%E6%B3%95/00pythonapi/" title="无题">无题</a><time datetime="2022-12-21T14:08:13.553Z" title="发表于 2022-12-21 22:08:13">2022-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/12/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E/0%E7%AE%80%E4%BB%8B/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/12/12/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E/0%E7%AE%80%E4%BB%8B/" title="无题">无题</a><time datetime="2022-12-12T15:06:58.895Z" title="发表于 2022-12-12 23:06:58">2022-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/19/22CloudNative/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/11/19/22CloudNative/" title="无题">无题</a><time datetime="2022-11-19T15:17:22.198Z" title="发表于 2022-11-19 23:17:22">2022-11-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By ggq</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>