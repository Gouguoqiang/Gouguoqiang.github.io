<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>OS | ggq</title><meta name="keywords" content="OS"><meta name="author" content="ggq"><meta name="copyright" content="ggq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OS总结(todo)。">
<meta property="og:type" content="article">
<meta property="og:title" content="OS">
<meta property="og:url" content="https://gouguoqiang.github.io/2022/09/01/15os/index.html">
<meta property="og:site_name" content="ggq">
<meta property="og:description" content="OS总结(todo)。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-01T03:51:56.000Z">
<meta property="article:modified_time" content="2023-03-02T03:17:09.928Z">
<meta property="article:author" content="ggq">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://gouguoqiang.github.io/2022/09/01/15os/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-02 11:17:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ggq</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-01T03:51:56.000Z" title="发表于 2022-09-01 11:51:56">2022-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-02T03:17:09.928Z" title="更新于 2023-03-02 11:17:09">2023-03-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OS/">OS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OS"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>笔试题:</p>
<p>AMAT（平均内存访问时间）&#x3D; 命中时间 + 未命中率 * 未命中惩罚</p>
<ul>
<li>一级缓存，10ns，50%</li>
<li>二级缓存，50ns，90%</li>
<li>主存储器，60ns，100%</li>
</ul>
<p>res  &#x3D; 10 + 0.5*(50 + 0.1 * (600)) &#x3D; 65ns</p>
<h1 id="第一章-操作系统概述-从软件工程角度"><a href="#第一章-操作系统概述-从软件工程角度" class="headerlink" title="第一章 操作系统概述(从软件工程角度)"></a>第一章 操作系统概述(从软件工程角度)</h1><p>abstract<br>What’s OS<br>按软件工程的观点分析OS的结构<br>操作系统的发展，类型及特征<br>现代操作系统体系结构基础知识</p>
<h2 id="1-1What’s-OS"><a href="#1-1What’s-OS" class="headerlink" title="1.1What’s OS"></a>1.1What’s OS</h2><p>1.User&#x2F;Computer Interface (用户角度)<br>OS是用户使用计算机系统的接口，为用户提供了方便的工作环境<br>2.Virtual Machine（程序员）<br>建立在硬件上的虚拟机器,为应用软件提供了许多比计算机硬件功能更强或没有的功能<br>3.Resource Manager(OS开发者1）<br>负责分配，回收，以及控制系统中的各种软硬件资源</p>
<p>4.Job Organizer（OS开发者2）<br>工作流程的组织者，负责协调各个应用软件的运行次序</p>
<p>JVM是建立在OS之上的虚拟机：可对比理解</p>
<p>软件工程 需求分析→系统设计→编码实现→产品测试</p>
<h2 id="1-2-OS的系统需求"><a href="#1-2-OS的系统需求" class="headerlink" title="1.2 OS的系统需求"></a>1.2 OS的系统需求</h2><h3 id="软件系统的系统需求"><a href="#软件系统的系统需求" class="headerlink" title="软件系统的系统需求"></a>软件系统的系统需求</h3><p>指人们从外部对系统提出的诸多期望<br>包括三种类型</p>
<ol>
<li>提供的服务</li>
<li>OS提供服务需要满足的限制条件</li>
<li>OS具有适应某些变化的能力</li>
</ol>
<p>第一类系统需求是后两类系统需求赖以存在的基础，称为功能性需求，后两者为非功能性需求</p>
<h3 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h3><p>计算机用户需要的<strong>用户命令</strong>，由OS实现的所有用户命令构成的集合，被称为<strong>用户接口</strong>或者命令接口<br>引用软件需要的<strong>系统调用</strong>，由OS实现的所有系统调用的集合被称为程序接口或应用编程接口</p>
<p>Interface(用户接口)<br>表示形式：字符，菜单，图形形式<br>使用方式：脱机（off-line处理时不能改变作业步)&#x2F;联机（on-line可随时改变）</p>
<p>System Call<br>应用软件在运行过程可以引用的系统服务<br>常用 POSIX.1 WIN32 API</p>
<h3 id="OS对硬件平台的依赖"><a href="#OS对硬件平台的依赖" class="headerlink" title="OS对硬件平台的依赖"></a>OS对硬件平台的依赖</h3><p>Timer</p>
<ul>
<li>I&#x2F;O Interrupts</li>
<li>DMA or Channel</li>
<li>Privileged Instructions (特权指令）</li>
<li>Memory Protection Mechanism<br>… …</li>
</ul>
<h3 id="基本概念：Job（作业）"><a href="#基本概念：Job（作业）" class="headerlink" title="基本概念：Job（作业）"></a>基本概念：Job（作业）</h3><ul>
<li><p>用户一次上机过程中要求计算机为其所做工作的集合；作业中的每项相对独立的工作称为作业步</p>
</li>
<li><p>通常，一组命令来描述作业；其中每个命令定义为一个作业步<br>-……</p>
</li>
</ul>
<h3 id="基本概念：Thread-amp-Process"><a href="#基本概念：Thread-amp-Process" class="headerlink" title="基本概念：Thread&amp;Process"></a>基本概念：Thread&amp;Process</h3><ul>
<li>Thread是指程序的一次相对独立的运行过程，在现代OS中，线程是系统调度的最小单位。</li>
<li>Process是指，系统分配资源的基本对象；在现代OS中，进程仅仅是系统中拥有资源的最小实体；不过在传统OS中进程同时也是系统调度的最小单位</li>
</ul>
<h3 id="基本概念-Virtual-Memory-amp-File"><a href="#基本概念-Virtual-Memory-amp-File" class="headerlink" title="基本概念 Virtual Memory&amp;File"></a>基本概念 Virtual Memory&amp;File</h3><ul>
<li>虚拟存储简单的说就是进程的逻辑地址空间；是现代OS对计算机系统中多级物理存储体系进行高度抽象的结果</li>
<li>文件，简单的说就是命名了的字节流；它是现代OS对计算机系统种类繁多的外设设备进行高度抽象的结果</li>
</ul>
<h2 id="1-3-OS的演变，类型及特点"><a href="#1-3-OS的演变，类型及特点" class="headerlink" title="1.3 OS的演变，类型及特点"></a>1.3 OS的演变，类型及特点</h2><h3 id="串行处理"><a href="#串行处理" class="headerlink" title="串行处理"></a>串行处理</h3><h3 id="简单批处理系统"><a href="#简单批处理系统" class="headerlink" title="简单批处理系统"></a>简单批处理系统</h3><h2 id="1-4-OS体系结构"><a href="#1-4-OS体系结构" class="headerlink" title="1.4 OS体系结构"></a>1.4 OS体系结构</h2><p>需求分析→系统设计→编码实现→产品测试<br>系统设计→软件体系结构设计→软件部件设计</p>
<h3 id="一种常见的OS总体结构风格"><a href="#一种常见的OS总体结构风格" class="headerlink" title="一种常见的OS总体结构风格"></a>一种常见的OS总体结构风格</h3><ul>
<li>大多数现代OS总体结构包含两类子系统 ：用户接口子系统（提供命令接口），和基础平台子系统（提供系统调用）</li>
<li>两者关系单项性，具体来说用户接口子系统在实现各种用户命令时能够引用基础平台子系统提供的各种系统调用，但基础平台子系统在实现各种系统调用不会引用用户命令</li>
</ul>
<h3 id="OS基础平台子系统结构风格"><a href="#OS基础平台子系统结构风格" class="headerlink" title="OS基础平台子系统结构风格"></a>OS基础平台子系统结构风格</h3><ul>
<li>分层   特征：按层实现一组概念及其相关的基本属性 ，上层只依赖直接下层</li>
<li>分级	类似分层 按级 ~                                                    只依赖以下各级             级~</li>
<li>分块   按块实现~                                                     ~ ，所有各块均可任意引用其他各块提供的概念及属性</li>
</ul>
<h3 id="双模式"><a href="#双模式" class="headerlink" title="双模式"></a>双模式</h3><p>user model 和kernel model</p>
<h1 id="第一章-概述-从了解已有功能角度"><a href="#第一章-概述-从了解已有功能角度" class="headerlink" title="第一章 概述(从了解已有功能角度)"></a>第一章 概述(从了解已有功能角度)</h1><h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h3><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h3><p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>有两种共享方式：互斥共享和同时共享。</p>
<p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p>
<h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p>
<p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h3><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
<h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
<h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p>
<h3 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h3><p>完成用户的 I&#x2F;O 请求，方便用户使用各种设备，并提高设备的利用率。</p>
<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>内核态的功能实现</p>
<p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p>
<p>Linux 的系统调用主要有以下这些：</p>
<table>
<thead>
<tr>
<th align="center">Task</th>
<th>Commands</th>
</tr>
</thead>
<tbody><tr>
<td align="center">进程控制</td>
<td>fork(); exit(); wait();</td>
</tr>
<tr>
<td align="center">进程通信</td>
<td>pipe(); shmget(); mmap();</td>
</tr>
<tr>
<td align="center">文件操作</td>
<td>open(); read(); write();</td>
</tr>
<tr>
<td align="center">设备操作</td>
<td>ioctl(); read(); write();</td>
</tr>
<tr>
<td align="center">信息维护</td>
<td>getpid(); alarm(); sleep();</td>
</tr>
<tr>
<td align="center">安全</td>
<td>chmod(); umask(); chown();</td>
</tr>
</tbody></table>
<h2 id="宏内核和微内核"><a href="#宏内核和微内核" class="headerlink" title="宏内核和微内核"></a>宏内核和微内核</h2><h3 id="1-宏内核"><a href="#1-宏内核" class="headerlink" title="1. 宏内核"></a>1. 宏内核</h3><p>宏内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>
<p>由于各模块共享信息，因此有很高的性能。</p>
<h3 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h3><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p>
<p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p>
<p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"> </div><br>

<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h3><p>由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</p>
<h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>
<h3 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h3><p>在用户程序中使用系统调用。</p>
<h1 id="第二章-进程和调度"><a href="#第二章-进程和调度" class="headerlink" title="第二章 进程和调度"></a>第二章 进程和调度</h1><h2 id="进程描述和控制"><a href="#进程描述和控制" class="headerlink" title="进程描述和控制"></a>进程描述和控制</h2><h3 id="Swapping（交换技术）"><a href="#Swapping（交换技术）" class="headerlink" title="Swapping（交换技术）"></a>Swapping（交换技术）</h3><p>将内存中暂时不能运行的进程，或暂时不用的数据和程序，Swapping-out到外存，以腾出足够的内存空间，把已具备运行条件的进程或进程所需要的数据和程序，Swapping-in内存</p>
<p>程序暂停的原因<br>Swapping<br>用户要求<br>定时任务<br>父进程要求<br>其他系统原因（例如系统怀疑进程会引起问题，会让他暂停）</p>
<p>处理机可处理的一个是新创建的进程或者换入一个以前挂起的进程</p>
<h3 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h3><p>OS如何感知进程，控制进程及其所用的系统资源</p>
<p>OS控制体系</p>
<ul>
<li>关于进程和资源的当前状态信息</li>
<li>表是为了每个操作系统管理的实体构建的</li>
<li>存储表</li>
<li>I&#x2F;O 表</li>
<li>文件表</li>
<li>程序表<br><img src="https://img-blog.csdnimg.cn/a44224cb0fe34b7eb3d860615407a94b.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5bm05Lik5bm05LiJ5bm05Zub5bm0,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>存储表<br>分配内存给程序<br>分配二级存储给程序（内存外的所有可访问数据存储器）<br>共享存储区域的访问的保护属性<br>管理虚拟内存所需要的信息</li>
</ul>
<p>I&#x2F;O表<br>I&#x2F;O设备可选还是已分配<br>I&#x2F;O活动的状态<br>内存中被用作起点或目标的位置</p>
<p>进程表<br>进程在哪<br>为了管理进程而需要的属性<br>    - 进程ID<br>    - 进程状态<br>    - 进程所在存储位置<br>进程<br>该过程包括一组要执行的程序<br>    - 数据位置<br>    - 任何定义的常数<br>    - 堆栈<br>进程控制块（PCB）<br>    - 属性集合<br>(进程映像)<br>    - 程序、数据、堆栈和属性的集合。</p>
<p>用户级线程<br>所有线程被应用管理<br>核心不能感知存在<br>描述此类线程的数据结构及控制此类线程的原语在核外子系统中实现</p>
<p>二合一方法<br>Solaris<br>大量线程被创建在用户空间<br>大批调度和同步在用户线程空间</p>
<h2 id="进程与线程区别"><a href="#进程与线程区别" class="headerlink" title="进程与线程区别"></a>进程与线程区别</h2><p>Ⅰ 拥有资源</p>
<p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p>
<p>Ⅱ 调度</p>
<p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p>
<p>Ⅲ 系统开销</p>
<p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p>
<p>Ⅳ 通信方面</p>
<p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" width="500"> </div><br>

<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h3 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong>  </p>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong>  </p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong>  </p>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h3 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong>  </p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png"> </div><br>

<p><strong>2.2 优先级调度</strong>  </p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>2.3 多级反馈队列</strong>  </p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png"> </div><br>

<h3 id="3-实时系统"><a href="#3-实时系统" class="headerlink" title="3. 实时系统"></a>3. 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li>互斥与同步</li>
<li>死锁与饥饿</li>
</ul>
<p>目标</p>
<ul>
<li>解释什么是并发，同步，互斥，死锁，饥饿,临界区</li>
<li>掌握互斥的要求</li>
<li>掌握互斥的方法：软件方法&amp;硬件支持—Semaphores，Monitors，Message Passing</li>
<li>区别掌握信号量的类型和意义</li>
<li>掌握生产者消费者，读写者，哲学家问题</li>
<li>理解死锁的情况，死锁的预防，死锁的避免，死锁侦查，一旦检测出死锁的策略，银行家算法安全情况和不安全情况</li>
</ul>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="并发设计的问题"><a href="#并发设计的问题" class="headerlink" title="并发设计的问题"></a>并发设计的问题</h4><ul>
<li>进程间交流</li>
<li>共享&#x2F;竞争资源</li>
<li>多进程的同步</li>
<li>处理器时间的分配</li>
</ul>
<h4 id="操作系统问题"><a href="#操作系统问题" class="headerlink" title="操作系统问题"></a>操作系统问题</h4><p>跟踪活动进程:PCB．</p>
<p>分配和释放资源</p>
<ul>
<li><p>处理器时间:调度</p>
</li>
<li><p>记忆:虚拟内存</p>
</li>
<li><p>文件I &#x2F; O设备</p>
</li>
<li><p>保护数据和资源</p>
</li>
</ul>
<p>进程的结果必须独立于其他并发进程的执行</p>
<p>- </p>
<h3 id="互斥条件与解决方案"><a href="#互斥条件与解决方案" class="headerlink" title="互斥条件与解决方案"></a>互斥条件与解决方案</h3><h4 id="互斥的要求"><a href="#互斥的要求" class="headerlink" title="互斥的要求"></a>互斥的要求</h4><ul>
<li>空则让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
<h4 id="互斥的方法-Approaches-of-Mutual-Exclusion"><a href="#互斥的方法-Approaches-of-Mutual-Exclusion" class="headerlink" title="互斥的方法(Approaches of Mutual Exclusion)"></a>互斥的方法(Approaches of Mutual Exclusion)</h4><ul>
<li><p>软件方法</p>
<ul>
<li>内存级别,保证内存 </li>
<li>Access to the same location in main memory are serialized<br>by some sort of memory arbiter (内存仲裁器待学习)</li>
</ul>
</li>
<li><p>硬件支持</p>
<ul>
<li><p>中断禁用(OS中断待学习)</p>
<ul>
<li><p>进程运行到调用操作系统服务或中断为止。</p>
</li>
<li><p>禁用中断保证了互斥。</p>
</li>
</ul>
<p>这种方法的代价很高。</p>
<p>多处理</p>
<ul>
<li>在一个处理器上禁用中断不能保证互斥。</li>
</ul>
</li>
</ul>
</li>
<li><p>信号量</p>
<ul>
<li>称为信号量的特殊变量用于发送信号。</li>
<li>如果一个进程正在等待一个信号，那么它将被阻塞，直到该信号被发送。</li>
<li>等待和信号操作不能中断。</li>
<li>Queue用于保存等待信号量的进程。</li>
<li>信号量信号量是一个具有整数值的变量s。可以初始化为非负数。Wait和Signal是原语(是系统调用,原子的，不能被中断，每个例程可以被视为不可分割的步骤)。<ul>
<li>可理解为资源数,门口多把钥匙,都能进</li>
</ul>
</li>
</ul>
</li>
<li><p>管程</p>
<ul>
<li>队列+互斥区</li>
<li>信号量容易出错(wait和signal操作的顺序很重要)</li>
</ul>
</li>
<li><p>消息传递</p>
<ul>
<li>send(地址,消息) 和 recive(地址,消息)</li>
<li>可以是send和recive都可以是非阻塞的</li>
</ul>
</li>
</ul>
<h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><ul>
<li><p>一个缓冲区同时只能只有一个人访问(互斥)</p>
</li>
<li><p>不能在空的取,不能在满的加(同步)</p>
</li>
<li><p>循环使用缓冲区</p>
<ul>
<li><p><img src="/../images/image-20220820110844150.png" alt="image-20220820110844150"></p>
</li>
<li><p>Java实现</p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;同步方式: Object的wait notify, park,unpark(再复习下),Lock.Condition接口的await()和signal()<br>&#x2F;&#x2F;BlockQueue方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// synchronized 实现互斥,wait,notifyAll()实现同步</span><br><span class="line">public class Cache &#123;</span><br><span class="line">        private final static int MAX_SIZE = 10;</span><br><span class="line">        private int cacheSize = 0;   </span><br><span class="line">		public Cache()&#123;</span><br><span class="line">        	cacheSize = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    public Cache(int size)&#123;</span><br><span class="line">        cacheSize = size;</span><br><span class="line">    &#125;</span><br><span class="line">    //分析过程 一个生产者进来 不大于直接生产 小于则让出</span><br><span class="line">    public void produce()&#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            while (cacheSize &gt;= MAX_SIZE )&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;缓存已满，生产者需要等待&quot;);</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cacheSize++;</span><br><span class="line">            System.out.println(&quot;生产了一个产品。当前产品数量为&quot;+ cacheSize);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void consume()&#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            while(cacheSize &lt;= 0)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;缓存为空，消费者需要等待&quot;);</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cacheSize--;</span><br><span class="line">            System.out.println(&quot;消费了一个产品。当前产品数量为&quot;+ cacheSize);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java内部信号量</span></span><br><span class="line"><span class="comment">//public class Cache &#123;</span></span><br><span class="line"><span class="comment">//    private int cacheSize = 0;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public Semaphore mutex;</span></span><br><span class="line"><span class="comment">//    public Semaphore empty; //保证了容器空的时候（empty的信号量&lt;=0), 消费者等待</span></span><br><span class="line"><span class="comment">//    public Semaphore full;  //保证了容器满的时候（full的信号量 &lt;= 0），生产者等待</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public Cache(int size) &#123;</span></span><br><span class="line"><span class="comment">//        mutex = new Semaphore(1);   //二进制信号量，表示互斥锁</span></span><br><span class="line"><span class="comment">//        empty = new Semaphore(size);</span></span><br><span class="line"><span class="comment">//        full = new Semaphore(0);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public int getCacheSize()throws InterruptedException&#123;</span></span><br><span class="line"><span class="comment">//        return cacheSize;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public void produce() throws InterruptedException&#123;</span></span><br><span class="line"><span class="comment">//        empty.acquire();    // 消耗一个空位</span></span><br><span class="line"><span class="comment">//        mutex.acquire();</span></span><br><span class="line"><span class="comment">//        cacheSize++;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;生产了一个产品， 当前产品数为&quot; + cacheSize);</span></span><br><span class="line"><span class="comment">//        mutex.release();</span></span><br><span class="line"><span class="comment">//        full.release();     // 增加了一个产品</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public void consume() throws InterruptedException&#123;</span></span><br><span class="line"><span class="comment">//        full.acquire();     // 消耗了一个产品</span></span><br><span class="line"><span class="comment">//        mutex.acquire();</span></span><br><span class="line"><span class="comment">//        cacheSize--;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;消费了一个产品， 当前产品数为&quot; + cacheSize);</span></span><br><span class="line"><span class="comment">//        mutex.release();</span></span><br><span class="line"><span class="comment">//        empty.release();    // 增加了一个空位</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cacheSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition notFull;</span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache</span><span class="params">()</span>&#123;</span><br><span class="line">        cacheSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="built_in">this</span>.notFull = lock.newCondition();</span><br><span class="line">        <span class="built_in">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cache</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">        cacheSize = size;</span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="built_in">this</span>.notFull = lock.newCondition();</span><br><span class="line">        <span class="built_in">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分析过程 一个生产者进来 不大于直接生产 小于则让出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (cacheSize == MAX_SIZE )&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;缓存已满，生产者需要等待&quot;</span>);</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cacheSize++;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产了一个产品。当前产品数量为&quot;</span>+ cacheSize);</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (cacheSize == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;缓存为空，消费者需要等待&quot;</span>);</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cacheSize--;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费了一个产品。当前产品数量为&quot;</span>+ cacheSize);</span><br><span class="line">        notFull.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值得一提的信号量自己实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> permit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permit)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.permit = permit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123; <span class="comment">// 获取许可</span></span><br><span class="line">        <span class="keyword">while</span> (permit == <span class="number">0</span>)&#123; <span class="comment">// 无法获取许可</span></span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行permit--操作</span></span><br><span class="line">        permit--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>&#123;  <span class="comment">//释放许可</span></span><br><span class="line">        <span class="comment">//执行permit++ 操作</span></span><br><span class="line"></span><br><span class="line">        permit++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (permit &gt; <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">//唤醒</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消息传递实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 创建两个队列为邮箱 一个存放&quot;有东西的箱子&quot; 让消费者取,取完将空箱子放到第二个队列,</span></span><br><span class="line"><span class="comment">//生产者从空箱子队列取箱子装东西放到 第一个队列</span></span><br><span class="line"><span class="comment">// 生产者阻塞:没有空箱子(队列2为空),消费者阻塞:没有东西取(队列1为空)</span></span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li>只能在父子进程或者兄弟进程中使用。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"> </div><br>

<h3 id="2-FIFO"><a href="#2-FIFO" class="headerlink" title="2. FIFO"></a>2. FIFO</h3><p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifoat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"> </div><br>

<h3 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h3><p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h3><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h3 id="5-共享存储"><a href="#5-共享存储" class="headerlink" title="5. 共享存储"></a>5. 共享存储</h3><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p>
<h3 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h2 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"> </div><br>

<ul>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p>主要有以下四种方法：</p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h3 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h2 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h2><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<h3 id="1-每种类型一个资源的死锁检测"><a href="#1-每种类型一个资源的死锁检测" class="headerlink" title="1. 每种类型一个资源的死锁检测"></a>1. 每种类型一个资源的死锁检测</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"> </div><br>

<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h3 id="2-每种类型多个资源的死锁检测"><a href="#2-每种类型多个资源的死锁检测" class="headerlink" title="2. 每种类型多个资源的死锁检测"></a>2. 每种类型多个资源的死锁检测</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"> </div><br>

<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A &#x3D; (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A &#x3D; (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h3 id="3-死锁恢复"><a href="#3-死锁恢复" class="headerlink" title="3. 死锁恢复"></a>3. 死锁恢复</h3><ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>在程序运行之前预防发生死锁。</p>
<h3 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1. 破坏互斥条件"></a>1. 破坏互斥条件</h3><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
<h3 id="2-破坏占有和等待条件"><a href="#2-破坏占有和等待条件" class="headerlink" title="2. 破坏占有和等待条件"></a>2. 破坏占有和等待条件</h3><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>
<h3 id="3-破坏不可抢占条件"><a href="#3-破坏不可抢占条件" class="headerlink" title="3. 破坏不可抢占条件"></a>3. 破坏不可抢占条件</h3><h3 id="4-破坏环路等待"><a href="#4-破坏环路等待" class="headerlink" title="4. 破坏环路等待"></a>4. 破坏环路等待</h3><p>给资源统一编号，进程只能按编号顺序来请求资源。</p>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>在程序运行时避免发生死锁。</p>
<h3 id="1-安全状态"><a href="#1-安全状态" class="headerlink" title="1. 安全状态"></a>1. 安全状态</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png"> </div><br>

<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
<h3 id="2-单个资源的银行家算法"><a href="#2-单个资源的银行家算法" class="headerlink" title="2. 单个资源的银行家算法"></a>2. 单个资源的银行家算法</h3><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"> </div><br>

<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h3 id="3-多个资源的银行家算法"><a href="#3-多个资源的银行家算法" class="headerlink" title="3. 多个资源的银行家算法"></a>3. 多个资源的银行家算法</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"> </div><br>

<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<p>- </p>
<h1 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h1><h1 id="第四章IO设备管理"><a href="#第四章IO设备管理" class="headerlink" title="第四章IO设备管理"></a>第四章IO设备管理</h1><p>RAIDRAID的基本特性由两部分组成:磁盘阵列(一组磁盘)可以并行工作，磁盘阵列管理软件磁盘阵列一组数据管理软件在逻辑上连续交叉分布，存储在磁盘阵列中到磁盘上。优点:磁盘阵列管理软件可以并行处理一组数据的单个或多个数据访问请求。磁盘阵列管理软件还负责校验存储相关信息。受益:当磁盘阵列出现磁盘故障时，磁盘阵列管理软件可以恢复磁盘上的数据。磁盘阵列管理软件屏蔽了磁盘阵列的物理细节，操作系统的其他成分不知道磁盘阵列的存在;在他们看来，逻辑盘的容量过大。</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h2><p>Java NIO,AIO 依赖于epoll</p>
<p>IO有两个阶段 等待数据 (写入socket直到socket可读) 和将数据从内核复制到用户空间复制完成返回成功指示</p>
<h3 id="1-阻塞IO"><a href="#1-阻塞IO" class="headerlink" title="1. 阻塞IO"></a>1. 阻塞IO</h3><p>进程阻塞于两个阶段 直到最后返回成功指示</p>
<p>进程阻塞(CPU空转了一直被动等待IO数据准备好)</p>
<p><img src="/../images/image-20220921100207210.png" alt="image-20220921100207210"></p>
<h3 id="2-非阻塞IO"><a href="#2-非阻塞IO" class="headerlink" title="2.  非阻塞IO"></a>2.  非阻塞IO</h3><p>自己主动问询准备好了吗recvfrom指令</p>
<p><img src="/../images/image-20220921100344115.png" alt="image-20220921100344115"></p>
<h3 id="3-IO多路复用"><a href="#3-IO多路复用" class="headerlink" title="3. IO多路复用"></a>3. IO多路复用</h3><p><strong>select异步阻塞IO</strong> 由select帮线程轮询socket 但是进程阻塞于select直到多个socket其中一个可读</p>
<p><img src="/../images/image-20220921100545404.png" alt="image-20220921100545404"></p>
<p>select使用了Reactor设计模式 由select帮线程轮询socket 可读后在通知用户线程</p>
<blockquote>
<p>异步: 进程走走停停 以不可知的速度执行, 不用等待结果,等回调在拿到结果</p>
</blockquote>
<h3 id="4-信号驱动-第一阶段非阻塞IO"><a href="#4-信号驱动-第一阶段非阻塞IO" class="headerlink" title="4. (信号驱动)第一阶段非阻塞IO"></a>4. (信号驱动)第一阶段非阻塞IO</h3><h3 id="5-真正的异步IO"><a href="#5-真正的异步IO" class="headerlink" title="5. 真正的异步IO"></a>5. 真正的异步IO</h3><p>两个阶段都不需要阻塞</p>
<p>linux中的aio_read</p>
<p><img src="/../images/image-20220921101124634.png" alt="image-20220921101124634"></p>
<h2 id="select、poll、epoll的区别？"><a href="#select、poll、epoll的区别？" class="headerlink" title="select、poll、epoll的区别？"></a>select、poll、epoll的区别？</h2><blockquote>
<p>select, poll, epoll 都是I&#x2F;O多路复用的具体的实现，之所以有这三个存在，其实是他们出现是有先后顺序的。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/nanxiaotao/article/details/90612404">https://blog.csdn.net/nanxiaotao/article/details/90612404</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/9166944.html">https://www.cnblogs.com/aspirant/p/9166944.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/32163005">https://www.zhihu.com/question/32163005</a></li>
</ul>
</blockquote>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ol>
<li>它仅仅知道了，有I&#x2F;O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</li>
<li>单个进程可监视的fd_set(监听的端口个数)数量被限制：32位机默认是1024个，64位机默认是2048。</li>
</ol>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll本质上和select没有区别，采用<strong>链表</strong>的方式替换原有fd_set数据结构,而使其<strong>没有连接数的限制</strong>。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ol>
<li>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I&#x2F;O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数。即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
<li>epoll通过内核和用户空间共享一块内存来实现的。select和poll都是内核需要将消息传递到用户空间，都需要内核拷贝动作</li>
<li>epoll有EPOLLLT和EPOLLET两种触发模式。(<strong>暂时不去记，有个印象，大致是什么样就可以</strong>)</li>
</ol>
<h2 id="linux进程管理"><a href="#linux进程管理" class="headerlink" title="linux进程管理"></a>linux进程管理</h2><p>进程类型</p>
<p>前台进程 占用终端shell</p>
<blockquote>
<p>在Linux系统中执行某些操作时候，有时需要将当前任务暂停调至后台好执行其他命令；有时又得将后台暂停的任务调至前台重新运行。这些操作可使用 jobs、bg 和 fg 三个命令以及 Ctrl + z 快捷键来完成。</p>
<p>按下ctr+z，将当前运行的程序放入后台挂起，此时你就可以执行其他任务了。<br>jobs 命令，显示后台被挂起的所有进程<br>bg N 使第N个序号的任务在后台运行<br>fg N 使第N个序号的任务在前台运行</p>
<p>ctr+c 退出前台进程</p>
<p>注：默认bg,fg不带N时表示对最后一个进程操作!<br>例如：<br>假如我在使用 vim a.js遍历一个文件，此时我可以使用ctrl+z将vim放入后台；再调用less config.cfg查看文件，暂时找到需要的东西后再使用ctrl+z将less查看放入后台； jobs查看所有的后台任务。记下刚才挂起的vim序列号为1，再通过fg 1将其从后台重新放入前台进行编辑。</p>
</blockquote>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>从整体上看，netstat的输出结果可以分为两个部分：</p>
<p>一个是Active Internet connections，称为有源TCP连接，其中”Recv-Q”和”Send-Q”指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。</p>
<p><img src="/../images/image-20221002102520729-1666009739255.png" alt="image-20221002102520729"></p>
<p>另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。</p>
<p><img src="/../images/image-20221002102413211-1666009739255.png" alt="image-20221002102413211"></p>
<blockquote>
<p>Proto显示连接使用的协议</p>
<p>RefCnt表示连接到本套接口上的进程号</p>
<p>Types显示套接口的类型</p>
<p>State显示套接口当前的状态</p>
<p>Path表示连接到套接口的其它进程使用的路径名</p>
</blockquote>
<p>-a 显示所有连接和侦听端口，默认不显示LISTEN相关<br>-b 显示在创建每个连接或侦听端口时涉及的可执行程序。在某些情况下，已知可执行程序承载多个独立的组件，这些情况下，显示创建连接或侦听端口时涉及的组件序列。在此情况下，可执行程序的名称位于底部 [] 中，它调用的组件位于顶部，直至达到 TCP&#x2F;IP。注意，此选项可能很耗时，并且在你没有足够权限时可能失败。<br>-e 显示以太网统计信息。此选项可以与 -s 选项结合使用。</p>
<p>-i 显示网络接口列表<br>-n 以数字形式显示地址和端口号。<br>-o 显示拥有的与每个连接关联的进程 ID。<br>-p proto 显示 proto 指定的协议的连接；proto可以是下列任何一个: TCP、UDP、TCPv6 或 UDPv6。如果与 -s选项一起用来显示每个协议的统计信息，proto 可以是下列任何一个:IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 或 UDPv6。<br>-q 显示所有连接、侦听端口和绑定的非侦听 TCP 端口。绑定的非侦听端口不一定与活动连接相关联。<br>-r 显示路由表。<br>-s 显示每个协议的统计信息。默认情况下，显示 IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息;-p 选项可用于指定默认的子网。<br>interval 重新显示选定的统计信息，各个显示间暂停的间隔秒数。按 CTRL+C 停止重新显示统计信息。如果省略，则 netstat 将打印当前的配置信息一次。<br>-t (tcp)仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-c 每隔一个固定时间，执行该netstat命令，netstat 将每隔一秒输出网络信息。</p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。</p>
<p>ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p>
<p>ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。</p>
<p>linux上进程有5种状态</p>
<ol>
<li><p>运行(正在运行或在运行队列中等待)</p>
</li>
<li><p>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</p>
</li>
<li><p>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</p>
</li>
<li><p>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</p>
</li>
<li><p>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</p>
</li>
</ol>
<p>ps工具标识进程的5种状态码</p>
<p>D 不可中断 uninterruptible sleep (usually IO)</p>
<p>R 运行 runnable (on run queue)</p>
<p>S 中断 sleeping</p>
<p>T 停止 traced or stopped</p>
<p>Z 僵死 a defunct (”zombie”) process</p>
<p>语法</p>
<p>ps [option]</p>
<p>命令参数</p>
<p>a      显示所有进程</p>
<p>-a     显示同一终端下的所有程序</p>
<p>-A     显示所有进程</p>
<p>c      显示进程的真实名称</p>
<p>-N     反向选择</p>
<p>-e     等于“-A”</p>
<p>e      显示环境变量</p>
<p>f      显示程序间的关系</p>
<p>-H     显示树状结构</p>
<p>r      显示当前终端的进程</p>
<p>T      显示当前终端的所有程序</p>
<p>u      指定用户的所有进程</p>
<p>-au    显示较详细的资讯</p>
<p>-aux   显示所有包含其他使用者的行程</p>
<p>-C&lt;命令&gt;     列出指定命令的状况</p>
<p>–lines&lt;行数&gt;     每页显示的行数</p>
<p>–width&lt;字符数&gt;     每页显示的字符数</p>
<p>–help      显示帮助信息</p>
<p>–version     显示版本显示</p>
<p>部分使用实例</p>
<p> ps -A           显示所有进程信息<br> ps -u root    显示指定用户信息</p>
<p> ps -ef          显示所有进程信息，连同命令行</p>
<p> ps -ef | grep ssh    查找特定进程</p>
<p> ps -l            将目前属于您自己这次登入的 PID 与相关信息列示出来</p>
<p> ps aux          列出目前所有的正在内存当中的程序</p>
<p>ps -axjf        列出类似程序树的程序显示</p>
<p>ps aux | egrep ‘(cron|syslog)’       找出与 cron 与 syslog 这两个服务有关的 PID 号码</p>
<p>ps -aux | more      可以用 | 管道和 more 连接起来分页查看</p>
<p> ps -aux &gt; ps001.txt      把所有进程显示出来，并输出到ps001.txt文件</p>
<p> ps -o pid,ppid,pgrp,session,tpgid,comm      输出指定的字段</p>
<p>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</p>
<p>S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</p>
<p>UID 程序被该 UID 所拥有</p>
<p>PID 就是这个程序的 ID ！</p>
<p>PPID 则是其上级父程序的ID</p>
<p><strong>C CPU 使用的资源百分比</strong></p>
<p>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</p>
<p>NI 这个是 Nice 值，在下一小节我们会持续介绍</p>
<p>ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</p>
<p>SZ 使用掉的内存大小</p>
<p>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</p>
<p>TTY 登入者的终端机位置</p>
<p><strong>TIME 使用掉的 CPU 时间。</strong></p>
<p>CMD 所下达的指令为何在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，所以， 当我使用 ps -l 的时候，只有三个 PID。</p>
<p>USER：该 process 属于那个使用者账号的</p>
<p>PID ：该 process 的号码</p>
<p>%CPU：该 process 使用掉的 CPU 资源百分比</p>
<p>%MEM：该 process 所占用的物理内存百分比</p>
<p>VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)</p>
<p>RSS ：该 process 占用的固定的内存量 (Kbytes)</p>
<p>STIME 启动时间</p>
<p><strong>TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts&#x2F;0 等等的，则表示为由网络连接进主机的程序。</strong></p>
<p>STAT：该程序目前的状态，主要的状态有</p>
<p>R ：该程序目前正在运作，或者是可被运作</p>
<p>S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。</p>
<p>T ：该程序目前正在侦测或者是停止了</p>
<p>Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</p>
<p>START：该 process 被触发启动的时间</p>
<p>TIME ：<strong>该 process 实际使用 CPU 运作的时间</strong></p>
<p>COMMAND：该程序的实际指令</p>
<p>ps -ef<br>UID          PID    PPID  C STIME TTY          TIME CMD</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io">ggq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io/2022/09/01/15os/">https://gouguoqiang.github.io/2022/09/01/15os/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gouguoqiang.github.io" target="_blank">ggq</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/01/14ES/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ES</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/01/17linux/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ggq</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-%E4%BB%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%A7%92%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">第一章 操作系统概述(从软件工程角度)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1What%E2%80%99s-OS"><span class="toc-number">1.1.</span> <span class="toc-text">1.1What’s OS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-OS%E7%9A%84%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 OS的系统需求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82"><span class="toc-number">1.2.1.</span> <span class="toc-text">软件系统的系统需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82"><span class="toc-number">1.2.2.</span> <span class="toc-text">功能性需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OS%E5%AF%B9%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="toc-number">1.2.3.</span> <span class="toc-text">OS对硬件平台的依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9AJob%EF%BC%88%E4%BD%9C%E4%B8%9A%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">基本概念：Job（作业）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9AThread-amp-Process"><span class="toc-number">1.2.5.</span> <span class="toc-text">基本概念：Thread&amp;Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-Virtual-Memory-amp-File"><span class="toc-number">1.2.6.</span> <span class="toc-text">基本概念 Virtual Memory&amp;File</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-OS%E7%9A%84%E6%BC%94%E5%8F%98%EF%BC%8C%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 OS的演变，类型及特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%A4%84%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">串行处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">简单批处理系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-OS%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 OS体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84OS%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.4.1.</span> <span class="toc-text">一种常见的OS总体结构风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OS%E5%9F%BA%E7%A1%80%E5%B9%B3%E5%8F%B0%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.4.2.</span> <span class="toc-text">OS基础平台子系统结构风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">双模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0-%E4%BB%8E%E4%BA%86%E8%A7%A3%E5%B7%B2%E6%9C%89%E5%8A%9F%E8%83%BD%E8%A7%92%E5%BA%A6"><span class="toc-number">2.</span> <span class="toc-text">第一章 概述(从了解已有功能角度)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.</span> <span class="toc-text">基本特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B9%B6%E5%8F%91"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B1%E4%BA%AB"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%99%9A%E6%8B%9F"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. 虚拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BC%82%E6%AD%A5"><span class="toc-number">2.1.4.</span> <span class="toc-text">4. 异步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">基本功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. 进程管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.3.</span> <span class="toc-text">3. 文件管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.4.</span> <span class="toc-text">4. 设备管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E5%86%85%E6%A0%B8%E5%92%8C%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-number">2.4.</span> <span class="toc-text">宏内核和微内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%8F%E5%86%85%E6%A0%B8"><span class="toc-number">2.4.1.</span> <span class="toc-text">1. 宏内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-number">2.4.2.</span> <span class="toc-text">2. 微内核</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%88%86%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">中断分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%96%E4%B8%AD%E6%96%AD"><span class="toc-number">2.5.1.</span> <span class="toc-text">1. 外中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%82%E5%B8%B8"><span class="toc-number">2.5.2.</span> <span class="toc-text">2. 异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%99%B7%E5%85%A5"><span class="toc-number">2.5.3.</span> <span class="toc-text">3. 陷入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%B0%83%E5%BA%A6"><span class="toc-number">3.</span> <span class="toc-text">第二章 进程和调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">进程描述和控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Swapping%EF%BC%88%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">Swapping（交换技术）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">进程描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">进程与线程区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">进程状态的切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">进程调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">1. 批处理系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.2.</span> <span class="toc-text">2. 交互式系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.3.</span> <span class="toc-text">3. 实时系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">3.5.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">3.5.1.</span> <span class="toc-text">并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">并发设计的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">操作系统问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.5.2.</span> <span class="toc-text">互斥条件与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">互斥的要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E6%96%B9%E6%B3%95-Approaches-of-Mutual-Exclusion"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">互斥的方法(Approaches of Mutual Exclusion)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">生产者消费者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">3.6.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%A1%E9%81%93"><span class="toc-number">3.6.1.</span> <span class="toc-text">1. 管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-FIFO"><span class="toc-number">3.6.2.</span> <span class="toc-text">2. FIFO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.6.3.</span> <span class="toc-text">3. 消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.6.4.</span> <span class="toc-text">4. 信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">3.6.5.</span> <span class="toc-text">5. 共享存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">3.6.6.</span> <span class="toc-text">6. 套接字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A6%82%E8%BF%B0"><span class="toc-number">3.7.</span> <span class="toc-text">死锁概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.7.1.</span> <span class="toc-text">必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.2.</span> <span class="toc-text">处理方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%B8%B5%E9%B8%9F%E7%AD%96%E7%95%A5"><span class="toc-number">3.7.3.</span> <span class="toc-text">鸵鸟策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-number">3.8.</span> <span class="toc-text">死锁检测与死锁恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">3.8.1.</span> <span class="toc-text">1. 每种类型一个资源的死锁检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">3.8.2.</span> <span class="toc-text">2. 每种类型多个资源的死锁检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-number">3.8.3.</span> <span class="toc-text">3. 死锁恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">3.9.</span> <span class="toc-text">死锁预防</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.9.1.</span> <span class="toc-text">1. 破坏互斥条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A0%B4%E5%9D%8F%E5%8D%A0%E6%9C%89%E5%92%8C%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.9.2.</span> <span class="toc-text">2. 破坏占有和等待条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%8F%AF%E6%8A%A2%E5%8D%A0%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.9.3.</span> <span class="toc-text">3. 破坏不可抢占条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A0%B4%E5%9D%8F%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85"><span class="toc-number">3.9.4.</span> <span class="toc-text">4. 破坏环路等待</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">3.10.</span> <span class="toc-text">死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="toc-number">3.10.1.</span> <span class="toc-text">1. 安全状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.10.2.</span> <span class="toc-text">2. 单个资源的银行家算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.10.3.</span> <span class="toc-text">3. 多个资源的银行家算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">第三章 内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0IO%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">第四章IO设备管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux"><span class="toc-number">6.</span> <span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">五种IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%BB%E5%A1%9EIO"><span class="toc-number">6.1.1.</span> <span class="toc-text">1. 阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">6.1.2.</span> <span class="toc-text">2.  非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">6.1.3.</span> <span class="toc-text">3. IO多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">6.1.4.</span> <span class="toc-text">4. (信号驱动)第一阶段非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%BC%82%E6%AD%A5IO"><span class="toc-number">6.1.5.</span> <span class="toc-text">5. 真正的异步IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select%E3%80%81poll%E3%80%81epoll%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">select、poll、epoll的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select"><span class="toc-number">6.2.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll"><span class="toc-number">6.2.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">6.2.3.</span> <span class="toc-text">epoll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">linux进程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">6.4.</span> <span class="toc-text">常用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat"><span class="toc-number">6.4.1.</span> <span class="toc-text">netstat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ps"><span class="toc-number">6.5.</span> <span class="toc-text">ps</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/AcWing/" title="一. 基础知识AcWing题目"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一. 基础知识AcWing题目"/></a><div class="content"><a class="title" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/AcWing/" title="一. 基础知识AcWing题目">一. 基础知识AcWing题目</a><time datetime="2022-09-02T03:51:56.000Z" title="发表于 2022-09-02 11:51:56">2022-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6java%E6%A8%A1%E6%9D%BF/" title="一. 基础知识Java模板"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一. 基础知识Java模板"/></a><div class="content"><a class="title" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6java%E6%A8%A1%E6%9D%BF/" title="一. 基础知识Java模板">一. 基础知识Java模板</a><time datetime="2022-09-02T03:51:56.000Z" title="发表于 2022-09-02 11:51:56">2022-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5%E4%BD%8D%E8%BF%90%E7%AE%97/" title="基础知识-位运算"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础知识-位运算"/></a><div class="content"><a class="title" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5%E4%BD%8D%E8%BF%90%E7%AE%97/" title="基础知识-位运算">基础知识-位运算</a><time datetime="2022-09-02T03:51:56.000Z" title="发表于 2022-09-02 11:51:56">2022-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/LeetCode/" title="一  . 基础知识LeetCode"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一  . 基础知识LeetCode"/></a><div class="content"><a class="title" href="/2022/09/02/%E7%AE%97%E6%B3%95/1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/LeetCode/" title="一  . 基础知识LeetCode">一  . 基础知识LeetCode</a><time datetime="2022-09-02T03:51:56.000Z" title="发表于 2022-09-02 11:51:56">2022-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/02/%E7%AE%97%E6%B3%95/2%E6%90%9C%E7%B4%A2/LeetCode/" title="搜索leetCode"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="搜索leetCode"/></a><div class="content"><a class="title" href="/2022/09/02/%E7%AE%97%E6%B3%95/2%E6%90%9C%E7%B4%A2/LeetCode/" title="搜索leetCode">搜索leetCode</a><time datetime="2022-09-02T03:51:56.000Z" title="发表于 2022-09-02 11:51:56">2022-09-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By ggq</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>