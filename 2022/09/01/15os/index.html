<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>OS | ggq</title><meta name="author" content="ggq"><meta name="copyright" content="ggq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OS总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="OS">
<meta property="og:url" content="https://gouguoqiang.github.io/2022/09/01/15os/index.html">
<meta property="og:site_name" content="ggq">
<meta property="og:description" content="OS总结。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-01T03:51:56.000Z">
<meta property="article:modified_time" content="2022-10-22T15:29:00.229Z">
<meta property="article:author" content="ggq">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://gouguoqiang.github.io/2022/09/01/15os/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-22 23:29:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ggq</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-01T03:51:56.000Z" title="发表于 2022-09-01 11:51:56">2022-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-22T15:29:00.229Z" title="更新于 2022-10-22 23:29:00">2022-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OS/">OS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OS"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>笔试题:</p>
<p>AMAT（平均内存访问时间）&#x3D; 命中时间 + 未命中率 * 未命中惩罚</p>
<ul>
<li>一级缓存，10ns，50%</li>
<li>二级缓存，50ns，90%</li>
<li>主存储器，60ns，100%</li>
</ul>
<p>res  &#x3D; 10 + 0.5*(50 + 0.1 * (600)) &#x3D; 65ns</p>
<h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><p>abstract<br>What’s OS<br>按软件工程的观点分析OS的结构<br>操作系统的发展，类型及特征<br>现代操作系统体系结构基础知识</p>
<h2 id="1-1What’s-OS"><a href="#1-1What’s-OS" class="headerlink" title="1.1What’s OS"></a>1.1What’s OS</h2><p>1.User&#x2F;Computer Interface (用户角度)<br>OS是用户使用计算机系统的接口，为用户提供了方便的工作环境<br>2.Virtual Machine（程序员）<br>建立在硬件上的虚拟机器,为应用软件提供了许多比计算机硬件功能更强或没有的功能<br>3.Resource Manager(OS开发者1）<br>负责分配，回收，以及控制系统中的各种软硬件资源</p>
<ol start="4">
<li>Job Organizer（OS开发者2）<br>工作流程的组织者，负责协调各个应用软件的运行次序</li>
</ol>
<p>JVM是建立在OS之上的虚拟机：可对比理解</p>
<p>软件工程 需求分析→系统设计→编码实现→产品测试</p>
<h2 id="1-2-OS的系统需求"><a href="#1-2-OS的系统需求" class="headerlink" title="1.2 OS的系统需求"></a>1.2 OS的系统需求</h2><h3 id="软件系统的系统需求"><a href="#软件系统的系统需求" class="headerlink" title="软件系统的系统需求"></a>软件系统的系统需求</h3><p>指人们从外部对系统提出的诸多期望<br>包括三种类型</p>
<ol>
<li>提供的服务</li>
<li>OS提供服务需要满足的限制条件</li>
<li>OS具有适应某些变化的能力</li>
</ol>
<p>第一类系统需求是后两类系统需求赖以存在的基础，称为功能性需求，后两者为非功能性需求</p>
<h3 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h3><p>计算机用户需要的<strong>用户命令</strong>，由OS实现的所有用户命令构成的集合，被称为用户接口或者命令接口<br>引用软件需要的<strong>系统调用</strong>，由OS实现的所有系统调用的集合被称为程序接口或应用编程接口</p>
<p>Interface<br>表示形式：字符，菜单，图形形式<br>使用方式：脱机（off-line处理时不能改变作业步)&#x2F;联机（on-line可随时改变）</p>
<p>System Call<br>应用软件在运行过程可以引用的系统服务<br>常用 POSIX.1 WIN32 API</p>
<h3 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h3><ul>
<li>性能</li>
<li>效率</li>
<li>公平性</li>
<li>可靠性</li>
<li>安全性</li>
<li>可伸缩性</li>
<li>可扩展性</li>
<li>可移植性<br>… …</li>
</ul>
<h3 id="OS对硬件平台的依赖"><a href="#OS对硬件平台的依赖" class="headerlink" title="OS对硬件平台的依赖"></a>OS对硬件平台的依赖</h3><p>Timer</p>
<ul>
<li>I&#x2F;O Interrupts</li>
<li>DMA or Channel</li>
<li>Privileged Instructions (特权指令）</li>
<li>Memory Protection Mechanism<br>… …</li>
</ul>
<h3 id="基本概念：Job（作业）"><a href="#基本概念：Job（作业）" class="headerlink" title="基本概念：Job（作业）"></a>基本概念：Job（作业）</h3><ul>
<li><p>用户一次上机过程中要求计算机为其所做工作的集合；作业中的每项相对独立的工作称为作业步</p>
</li>
<li><p>通常，一组命令来描述作业；其中每个命令定义为一个作业步<br>-……</p>
</li>
</ul>
<h3 id="基本概念：Thread-amp-Process"><a href="#基本概念：Thread-amp-Process" class="headerlink" title="基本概念：Thread&amp;Process"></a>基本概念：Thread&amp;Process</h3><ul>
<li>Thread是指程序的一次相对独立的运行过程，在现代OS中，线程是系统调度的最小单位。</li>
<li>Process是指，系统分配资源的基本对象；在现代OS中，进程仅仅是系统中拥有资源的最小实体；不过在传统OS中进程同时也是系统调度的最小单位</li>
</ul>
<h3 id="基本概念-Virtual-Memory-amp-File"><a href="#基本概念-Virtual-Memory-amp-File" class="headerlink" title="基本概念 Virtual Memory&amp;File"></a>基本概念 Virtual Memory&amp;File</h3><ul>
<li>虚拟存储简单的说就是进程的逻辑地址空间；是现代OS对计算机系统中多级物理存储体系进行高度抽象的结果</li>
<li>文件，简单的说就是命名了的字节流；它是现代OS对计算机系统种类繁多的外设设备进行高度抽象的结果</li>
<li></li>
</ul>
<h2 id="1-3-OS的演变，类型及特点"><a href="#1-3-OS的演变，类型及特点" class="headerlink" title="1.3 OS的演变，类型及特点"></a>1.3 OS的演变，类型及特点</h2><h3 id="OS进行演变的情况"><a href="#OS进行演变的情况" class="headerlink" title="OS进行演变的情况"></a>OS进行演变的情况</h3><ul>
<li>修改</li>
<li>新服务</li>
<li>硬件升级&#x2F;新的软件类型</li>
<li>效率</li>
</ul>
<h3 id="串行处理"><a href="#串行处理" class="headerlink" title="串行处理"></a>串行处理</h3><h3 id="简单批处理系统"><a href="#简单批处理系统" class="headerlink" title="简单批处理系统"></a>简单批处理系统</h3><h2 id="1-4-OS体系结构"><a href="#1-4-OS体系结构" class="headerlink" title="1.4 OS体系结构"></a>1.4 OS体系结构</h2><p>需求分析→系统设计→编码实现→产品测试<br>系统设计→软件体系结构设计→软件部件设计</p>
<h3 id="一种常见的OS总体结构风格"><a href="#一种常见的OS总体结构风格" class="headerlink" title="一种常见的OS总体结构风格"></a>一种常见的OS总体结构风格</h3><ul>
<li>大多数现代OS总体结构包含两类子系统 ：用户接口子系统（提供命令接口），和基础平台子系统（提供系统调用）</li>
<li>两者关系单项性，具体来说用户接口子系统在实现各种用户命令时能够引用基础平台子系统提供的各种系统调用，但基础平台子系统在实现各种系统调用不会引用用户命令</li>
</ul>
<h3 id="OS基础平台子系统结构风格"><a href="#OS基础平台子系统结构风格" class="headerlink" title="OS基础平台子系统结构风格"></a>OS基础平台子系统结构风格</h3><ul>
<li>分层   特征：按层实现一组概念及其相关的基本属性 ，上层只依赖直接下层</li>
<li>分级	类似分层 按级 ~                                                    只依赖以下各级             级~</li>
<li>分块   按块实现~                                                     ~ ，所有各块均可任意引用其他各块提供的概念及属性</li>
</ul>
<h3 id="双模式"><a href="#双模式" class="headerlink" title="双模式"></a>双模式</h3><p>user model 和kernel model</p>
<h1 id="第二章-进程和调度"><a href="#第二章-进程和调度" class="headerlink" title="第二章 进程和调度"></a>第二章 进程和调度</h1><p>abstract<br>基础：进程描述及控制<br>实现：互斥与同步<br>避免：死锁与饥饿<br>解决：几个经典问题<br>关于：进程通信<br>策略：进程调度</p>
<h2 id="2-1-进程描述和控制"><a href="#2-1-进程描述和控制" class="headerlink" title="2.1 进程描述和控制"></a>2.1 进程描述和控制</h2><p>学习目标：</p>
<ul>
<li>解释什么事进程，交换，线程</li>
<li>掌握分析进程的结构PCB，Process image（进程映像）</li>
<li>描述进程的基本状态及转换规则与原因</li>
<li>区别进程的挂起与阻塞状态</li>
<li>理解OS内核的主要功能</li>
<li>理解原语（process control primitives）</li>
<li>区别Provess Swithcing vs. Mode switching</li>
<li>区别进程线程</li>
</ul>
<h3 id="OS的主要要求"><a href="#OS的主要要求" class="headerlink" title="OS的主要要求"></a>OS的主要要求</h3><p>操作系统的主要要求．</p>
<ul>
<li>交叉执行多个进程，在提供合理响应时间的同时，最大限度地利用处理器</li>
<li>资源支持</li>
<li>进程间通信和用户创建进程</li>
</ul>
<h3 id="程序执行顺序"><a href="#程序执行顺序" class="headerlink" title="程序执行顺序"></a>程序执行顺序</h3><p>顺序执行特征：顺序性，封闭性，可再现性<br>并发 间断 非封闭 不可再现</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>也被叫做task是程序在一个数据集合的运行过程，是系统进行资源分配和调度的独立单位<br>特性：动态性 并发 独立 异步<br>结构：代码，数据 PCB（进程控制块<br>进程状态：<br>执行或非执行<br>new（ready suspengd）   ready  Running   exit<br>    （blocked suspengd）			Bolcked<br>使用两个队列<br><img src="https://img-blog.csdnimg.cn/dac53c610f64471e92d03b6518cd97cd.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5bm05Lik5bm05LiJ5bm05Zub5bm0,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>等待相同资源（例如锁）的在一队  多个不同的队列<br><img src="https://img-blog.csdnimg.cn/37f9c83f5b3b4e3cb6f9c5aac7a5d8f3.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5bm05Lik5bm05LiJ5bm05Zub5bm0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="Swapping（交换技术）"><a href="#Swapping（交换技术）" class="headerlink" title="Swapping（交换技术）"></a>Swapping（交换技术）</h3><p>将内存中暂时不能运行的进程，或暂时不用的数据和程序，Swapping-out到外存，以腾出足够的内存空间，把已具备运行条件的进程或进程所需要的数据和程序，Swapping-in内存</p>
<p>程序暂停的原因<br>Swapping<br>用户要求<br>定时任务<br>父进程要求<br>其他系统原因（例如系统怀疑进程会引起问题，会让他暂停）</p>
<p>处理机可处理的一个是新创建的进程或者换入一个以前挂起的进程</p>
<h3 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h3><p>OS如何感知进程，控制进程及其所用的系统资源</p>
<p>OS控制体系</p>
<ul>
<li>关于进程和资源的当前状态信息</li>
<li>表是为了每个操作系统管理的实体构建的</li>
<li>存储表</li>
<li>I&#x2F;O 表</li>
<li>文件表</li>
<li>程序表<br><img src="https://img-blog.csdnimg.cn/a44224cb0fe34b7eb3d860615407a94b.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5bm05Lik5bm05LiJ5bm05Zub5bm0,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>存储表<br>分配内存给程序<br>分配二级存储给程序（内存外的所有可访问数据存储器）<br>共享存储区域的访问的保护属性<br>管理虚拟内存所需要的信息</li>
</ul>
<p>I&#x2F;O表<br>I&#x2F;O设备可选还是已分配<br>I&#x2F;O活动的状态<br>内存中被用作起点或目标的位置</p>
<p>进程表<br>进程在哪<br>为了管理进程而需要的属性<br>    - 进程ID<br>    - 进程状态<br>    - 进程所在存储位置<br>进程<br>该过程包括一组要执行的程序<br>    - 数据位置<br>    - 任何定义的常数<br>    - 堆栈<br>进程控制块（PCB）<br>    - 属性集合<br>(进程映像)<br>    - 程序、数据、堆栈和属性的集合。</p>
<p>2_1_09 PCB</p>
<h3 id="OS内核功能"><a href="#OS内核功能" class="headerlink" title="OS内核功能"></a>OS内核功能</h3><p>资源管理功能<br>进程管理：进程创建，终止，调度，状态转换，同步和通信，管理PCB<br>存储管理：为进程分配空间，对换，段&#x2F;页管理<br>I&#x2F;O管理  ：缓存管理，为进程分配I&#x2F;O通道和设备<br>通过原语</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>执行状态（正在运行、准备就绪等）</li>
<li>未运行时要保存线程上下文</li>
<li>有一个执行堆栈</li>
<li>每个线程局部变量的静态存储</li>
<li>访问其进程的内存和资源<ul>
<li>一个进程的所有线程都共享进程内存和资源<br><img src="https://img-blog.csdnimg.cn/d617acf6e49b4b4787e099c294d079b5.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5bm05Lik5bm05LiJ5bm05Zub5bm0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>线程的好处</li>
</ul>
</li>
<li>创建新线程所需的时间比创建进程所需的时间少</li>
<li>终止线程的时间比终止进程的时间短</li>
<li>在同一进程内的两个线程之间切换的时间更短</li>
<li>由于同一进程中的线程共享内存和文件，因此可以在不调用内核的情况下相互通信。</li>
</ul>
<p>挂起进程涉及挂起进程的所有线程<br>    -因为所有线程共享相同的地址空间<br>进程的终止，终止进程中的所有线程</p>
<p>多线程<br>操作系统支持在单个进程中执行多个线程。<br>MS-DOS支持单线程。<br>UNIX支持多个用户进程，但每个进程只支持一个线程。<br>Windows 2000、Solaris、Linux、Mach和Os&#x2F;2支持多线程。</p>
<p>线程状态<br>关键状态 Running Ready Blocked<br>改变线程状态的相关操作</p>
<ul>
<li>派生， 派生其他线程</li>
<li>阻塞</li>
<li>解除阻塞</li>
<li>完成</li>
</ul>
<p>用户级线程<br>所有线程被应用管理<br>核心不能感知存在<br>描述此类线程的数据结构及控制此类线程的原语在核外子系统中实现</p>
<p>二合一方法<br>Solaris<br>大量线程被创建在用户空间<br>大批调度和同步在用户线程空间</p>
<h2 id="2-2-进程调度"><a href="#2-2-进程调度" class="headerlink" title="2.2 进程调度"></a>2.2 进程调度</h2><p>abtstract</p>
<ul>
<li>调度种类</li>
<li>调度准则</li>
<li>调度算法</li>
<li>调度真正时间</li>
</ul>
<p>目标</p>
<ul>
<li>解释什么是响应时间，周转时间，截止时间，吞吐量</li>
<li>理解进程调度的目标，类型原则</li>
<li>理解剥夺&amp;非剥夺</li>
<li>研究经典进程调度算法FCFS ，轮转，最短作业优先，最短剩下时间，最高响应比优先，Feedback</li>
<li>理解Real-Time Systems及类型</li>
<li>理解掌握：Real-Time Scheduling,Deadline Scheduling, Rate Monotonic Scheduling(速度单调)</li>
</ul>
<h3 id="2-2-1调度类型"><a href="#2-2-1调度类型" class="headerlink" title="2.2.1调度类型"></a>2.2.1调度类型</h3><p>调度目标</p>
<p>响应时间<br>系统吞吐量<br>处理机效率<br>公平性（防止进程饥饿）</p>
<p>进程调度的类型</p>
<p>按OS ：批处理，分时，实时，多处理机<br>按调度层次： 长程 ，中， 短程调度</p>
<p><img src="/../images/image-20220818071833411.png" alt="image-20220818071833411"></p>
<p>长期调度</p>
<p>也称高级调度、作业调度，它是为调度作业或用户程序创建进程、分配必要的系统资源，并插入新的进程创建的就绪队列，等待短期调度利用交换技术系统将新创建的进程插入(就绪、挂起)队列，等待中期调度。</p>
<p>批处理系统，第一个作业进入系统后，驻留在磁盘(批处理队列)上,长程调度从该队列选择作业为之创建进程</p>
<p>长期调度确定系统允许哪些程序进行处理</p>
<ul>
<li>它依赖于调度算法，如FCFS、短分配优先级、基于优先级、响应优先级比大多数高优先级调度算法。</li>
</ul>
<p>有多少项目被允许进入系统?</p>
<ul>
<li><p>控制多编程程度</p>
</li>
<li><blockquote>
<p>自己的理解是取决于内存大小,和系统核数共同决定吧</p>
</blockquote>
</li>
</ul>
<p>程度调度程序何时被调用?</p>
<ul>
<li><p>每次工作终止时</p>
</li>
<li><p>处理器空闲超过阈值</p>
</li>
</ul>
<p>短程调度</p>
<p>​	．当事件发生时调用</p>
<p>时钟中断．</p>
<p>IO中断</p>
<p>操作系统调用</p>
<p>signals(信号)</p>
<h3 id="2-2-2调度算法"><a href="#2-2-2调度算法" class="headerlink" title="2.2.2调度算法"></a>2.2.2调度算法</h3><h4 id="简述操作系统进程的相关调度算法"><a href="#简述操作系统进程的相关调度算法" class="headerlink" title="简述操作系统进程的相关调度算法"></a>简述操作系统进程的相关调度算法</h4><p>先来先服务调度算法<br>短作业有限调度算法<br>优先级调度算法<br>高相应比优先调度算法<br>时间片轮转法</p>
<p>多级反馈队列调度算法：设置多个就绪队列，为各个队列赋予不同的优先级，第一个队列的优先级最高第二个队列次之，其余各队列的优先权逐个降低，该算法赋予各个队列中进程的时间片的大小也各不相同，在优先级越高的队列中，为每个进程所规定的时间片就越小，<br>当一个进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度，当轮到该进程执行时如能在该时间片完成，便可准备撤离系统，如果未完成，调度程序便将该进程放入第二队列的末尾，同样FCFS 依次往下<br>仅当第一队空闲时，调度程序才调度第二队列中的进程运行<br>如果处理机正处理第i队 为某进程服务时又有新进程进入优先权较高的任何一个队列，此时新进程会抢占正在运行进程的处理机，正在运行的进程被放回第i队的末尾</p>
<h4 id><a href="#" class="headerlink" title></a></h4><h2 id="2-2-3实时系统与实时调度"><a href="#2-2-3实时系统与实时调度" class="headerlink" title="2.2.3实时系统与实时调度"></a>2.2.3实时系统与实时调度</h2><p>实时系统:</p>
<p>​	系统的正确性不仅取决于计算的逻辑结果，还取决于产生结果的时间。任务或过程试图控制或响应发生在外部世界的事件。．这些事件是“实时”发生的，流程必须能够跟上它们。</p>
<p>实时操作系统的特点．</p>
<p>用户控件用户指定的优先级</p>
<p>指定分页(存储页面)</p>
<p>哪些进程必须始终驻留在主存中。磁盘算法使用进程的权限</p>
<p>可靠性(Reliability)</p>
<p>性能的降低会带来灾难性的后果(灾难性的)</p>
<p>在继续运行的同时，尝试纠正问题或最小化其影响。．执行最关键的、高优先级的任务。</p>
<p>实时操作系统的特点．快速上下文切换小尺寸．能够快速响应外部中断。多任务处理与进程间通信工具，如信号量，信号和事件。的文件存储数据速率快。</p>
<h2 id="2-3-并发"><a href="#2-3-并发" class="headerlink" title="2.3 并发"></a>2.3 并发</h2><ul>
<li>互斥与同步</li>
<li>死锁与饥饿</li>
</ul>
<p>目标</p>
<ul>
<li>解释什么是并发，同步，互斥，死锁，饥饿,临界区</li>
<li>掌握互斥的要求</li>
<li>掌握互斥的方法：软件方法&amp;硬件支持—Semaphores，Monitors，Message Passing</li>
<li>区别掌握信号量的类型和意义</li>
<li>掌握生产者消费者，读写者，哲学家问题</li>
<li>理解死锁的情况，死锁的预防，死锁的避免，死锁侦查，一旦检测出死锁的策略，银行家算法安全情况和不安全情况</li>
</ul>
<h3 id="2-3-1-并发控制"><a href="#2-3-1-并发控制" class="headerlink" title="2.3.1 并发控制"></a>2.3.1 并发控制</h3><h4 id="并发设计的问题"><a href="#并发设计的问题" class="headerlink" title="并发设计的问题"></a>并发设计的问题</h4><ul>
<li>进程间交流</li>
<li>共享&#x2F;竞争资源</li>
<li>多进程的同步</li>
<li>处理器时间的分配</li>
</ul>
<h4 id="并发性的困难"><a href="#并发性的困难" class="headerlink" title="并发性的困难"></a>并发性的困难</h4><ul>
<li>全局资源共享</li>
<li>资源分配的管理</li>
<li>编程错误难以定位</li>
</ul>
<h3 id="2-3-2-并发进程"><a href="#2-3-2-并发进程" class="headerlink" title="2.3.2 并发进程"></a>2.3.2 并发进程</h3><h4 id="操作系统问题"><a href="#操作系统问题" class="headerlink" title="操作系统问题"></a>操作系统问题</h4><p>跟踪活动进程:PCB．</p>
<p>分配和释放资源</p>
<ul>
<li><p>处理器时间:调度</p>
</li>
<li><p>记忆:虚拟内存</p>
</li>
<li><p>文件I &#x2F; O设备</p>
</li>
<li><p>保护数据和资源</p>
</li>
</ul>
<p>进程的结果必须独立于其他并发进程的执行</p>
<h4 id="相互作用过程-理解"><a href="#相互作用过程-理解" class="headerlink" title="相互作用过程(理解)"></a>相互作用过程(理解)</h4><p>进程之间不知道彼此——竞争</p>
<p>​	互斥、死锁、饥饿</p>
<p>进程可以间接感知彼此——共享合作</p>
<p>​	 互斥，死锁，饥饿，数据一致性(Data coherence)</p>
<p>进程直接感知彼此</p>
<ul>
<li>消息传递</li>
<li>死锁,饥饿</li>
</ul>
<h4 id="进程间的合作通过沟通"><a href="#进程间的合作通过沟通" class="headerlink" title="进程间的合作通过沟通"></a>进程间的合作通过沟通</h4><p>消息传递</p>
<p>互斥不是控制要求。</p>
<p>．可能出现死锁每个进程都在等待来自另一个进程的消息。</p>
<p>．可能会挨饿两个进程互相发送消息，而另一个进程等待消息。</p>
<h3 id="2-3-3-互斥条件与解决方案"><a href="#2-3-3-互斥条件与解决方案" class="headerlink" title="2.3.3 互斥条件与解决方案"></a>2.3.3 互斥条件与解决方案</h3><h4 id="互斥的要求"><a href="#互斥的要求" class="headerlink" title="互斥的要求"></a>互斥的要求</h4><ul>
<li>空则让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
<h4 id="互斥的方法-Approaches-of-Mutual-Exclusion"><a href="#互斥的方法-Approaches-of-Mutual-Exclusion" class="headerlink" title="互斥的方法(Approaches of Mutual Exclusion)"></a>互斥的方法(Approaches of Mutual Exclusion)</h4><ul>
<li><p>软件方法</p>
<ul>
<li>内存级别,保证内存 </li>
<li>Access to the same location in main memory are serialized<br>by some sort of memory arbiter (内存仲裁器待学习)</li>
</ul>
</li>
<li><p>硬件支持</p>
<ul>
<li><p>中断禁用(OS中断待学习)</p>
<ul>
<li><p>进程运行到调用操作系统服务或中断为止。</p>
</li>
<li><p>禁用中断保证了互斥。</p>
</li>
</ul>
<p>这种方法的代价很高。</p>
<p>多处理</p>
<ul>
<li>在一个处理器上禁用中断不能保证互斥。</li>
</ul>
</li>
</ul>
</li>
<li><p>信号量</p>
<ul>
<li>称为信号量的特殊变量用于发送信号。</li>
<li>如果一个进程正在等待一个信号，那么它将被阻塞，直到该信号被发送。</li>
<li>等待和信号操作不能中断。</li>
<li>Queue用于保存等待信号量的进程。</li>
<li>信号量信号量是一个具有整数值的变量s。可以初始化为非负数。Wait和Signal是原语(是系统调用,原子的，不能被中断，每个例程可以被视为不可分割的步骤)。<ul>
<li>可理解为资源数,门口多把钥匙,都能进</li>
</ul>
</li>
</ul>
</li>
<li><p>管程</p>
<ul>
<li>队列+互斥区</li>
<li>信号量容易出错(wait和signal操作的顺序很重要)</li>
</ul>
</li>
<li><p>消息传递</p>
<ul>
<li>send(地址,消息) 和 recive(地址,消息)</li>
<li>可以是send和recive都可以是非阻塞的</li>
</ul>
</li>
</ul>
<h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><ul>
<li><p>一个缓冲区同时只能只有一个人访问(互斥)</p>
</li>
<li><p>不能在空的取,不能在满的加(同步)</p>
</li>
<li><p>循环使用缓冲区</p>
<ul>
<li><p><img src="/../images/image-20220820110844150.png" alt="image-20220820110844150"></p>
</li>
<li><p>Java实现</p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;同步方式: Object的wait notify, park,unpark(再复习下),Lock.Condition接口的await()和signal()<br>&#x2F;&#x2F;BlockQueue方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// synchronized 实现互斥,wait,notifyAll()实现同步</span><br><span class="line">    public class Cache &#123;</span><br><span class="line">        private final static int MAX_SIZE = 10;</span><br><span class="line">        private int cacheSize = 0;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        public Cache()&#123;</span><br><span class="line">            cacheSize = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public Cache(int size)&#123;</span><br><span class="line">            cacheSize = size;</span><br><span class="line">        &#125;</span><br><span class="line">        //分析过程 一个生产者进来 不大于直接生产 小于则让出</span><br><span class="line">        public void produce()&#123;</span><br><span class="line">            synchronized (this)&#123;</span><br><span class="line">                while (cacheSize &gt;= MAX_SIZE )&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;缓存已满，生产者需要等待&quot;);</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cacheSize++;</span><br><span class="line">                System.out.println(&quot;生产了一个产品。当前产品数量为&quot;+ cacheSize);</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public void consume()&#123;</span><br><span class="line">            synchronized (this)&#123;</span><br><span class="line">                while(cacheSize &lt;= 0)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;缓存为空，消费者需要等待&quot;);</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cacheSize--;</span><br><span class="line">                System.out.println(&quot;消费了一个产品。当前产品数量为&quot;+ cacheSize);</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">    // Java内部信号量</span><br><span class="line">    //public class Cache &#123;</span><br><span class="line">    //    private int cacheSize = 0;</span><br><span class="line">    //</span><br><span class="line">    //    public Semaphore mutex;</span><br><span class="line">    //    public Semaphore empty; //保证了容器空的时候（empty的信号量&lt;=0), 消费者等待</span><br><span class="line">    //    public Semaphore full;  //保证了容器满的时候（full的信号量 &lt;= 0），生产者等待</span><br><span class="line">    //</span><br><span class="line">    //    public Cache(int size) &#123;</span><br><span class="line">    //        mutex = new Semaphore(1);   //二进制信号量，表示互斥锁</span><br><span class="line">    //        empty = new Semaphore(size);</span><br><span class="line">    //        full = new Semaphore(0);</span><br><span class="line">    //    &#125;</span><br><span class="line">    //</span><br><span class="line">    //    public int getCacheSize()throws InterruptedException&#123;</span><br><span class="line">    //        return cacheSize;</span><br><span class="line">    //    &#125;</span><br><span class="line">    //</span><br><span class="line">    //    public void produce() throws InterruptedException&#123;</span><br><span class="line">    //        empty.acquire();    // 消耗一个空位</span><br><span class="line">    //        mutex.acquire();</span><br><span class="line">    //        cacheSize++;</span><br><span class="line">    //        System.out.println(&quot;生产了一个产品， 当前产品数为&quot; + cacheSize);</span><br><span class="line">    //        mutex.release();</span><br><span class="line">    //        full.release();     // 增加了一个产品</span><br><span class="line">    //</span><br><span class="line">    //</span><br><span class="line">    //    &#125;</span><br><span class="line">    //</span><br><span class="line">    //    public void consume() throws InterruptedException&#123;</span><br><span class="line">    //        full.acquire();     // 消耗了一个产品</span><br><span class="line">    //        mutex.acquire();</span><br><span class="line">    //        cacheSize--;</span><br><span class="line">    //        System.out.println(&quot;消费了一个产品， 当前产品数为&quot; + cacheSize);</span><br><span class="line">    //        mutex.release();</span><br><span class="line">    //        empty.release();    // 增加了一个空位</span><br><span class="line">    //</span><br><span class="line">    //    &#125;</span><br><span class="line">    //&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">    //管程</span><br><span class="line">    public class Cache &#123;</span><br><span class="line">        private final static int MAX_SIZE = 10;</span><br><span class="line">        private int cacheSize = 0;</span><br><span class="line">        private Lock lock;</span><br><span class="line">        private Condition notFull;</span><br><span class="line">        private Condition notEmpty;</span><br><span class="line">    </span><br><span class="line">        public Cache()&#123;</span><br><span class="line">            cacheSize = 0;</span><br><span class="line">            this.lock = new ReentrantLock();</span><br><span class="line">            this.notFull = lock.newCondition();</span><br><span class="line">            this.notEmpty = lock.newCondition();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public Cache(int size)&#123;</span><br><span class="line">            cacheSize = size;</span><br><span class="line">            this.lock = new ReentrantLock();</span><br><span class="line">            this.notFull = lock.newCondition();</span><br><span class="line">            this.notEmpty = lock.newCondition();</span><br><span class="line">        &#125;</span><br><span class="line">        //分析过程 一个生产者进来 不大于直接生产 小于则让出</span><br><span class="line">        public void produce()&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while (cacheSize == MAX_SIZE )&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;缓存已满，生产者需要等待&quot;);</span><br><span class="line">                    notFull.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cacheSize++;</span><br><span class="line">            System.out.println(&quot;生产了一个产品。当前产品数量为&quot;+ cacheSize);</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public void consume()&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while (cacheSize == 0 )&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;缓存为空，消费者需要等待&quot;);</span><br><span class="line">                    notEmpty.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cacheSize--;</span><br><span class="line">            System.out.println(&quot;消费了一个产品。当前产品数量为&quot;+ cacheSize);</span><br><span class="line">            notFull.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //值得一提的信号量自己实现</span><br><span class="line">    public class Semaphore&#123;</span><br><span class="line">        private volatile int permit;</span><br><span class="line">    </span><br><span class="line">        public Semaphore(int permit)&#123;</span><br><span class="line">            this.permit = permit;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        //</span><br><span class="line">        public synchronized void acquire() throws InterruptedException &#123; // 获取许可</span><br><span class="line">            while (permit == 0)&#123; // 无法获取许可</span><br><span class="line">                //等待</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            //执行permit--操作</span><br><span class="line">            permit--;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public synchronized void release()&#123;  //释放许可</span><br><span class="line">            //执行permit++ 操作</span><br><span class="line">    </span><br><span class="line">            permit++;</span><br><span class="line">    </span><br><span class="line">            while (permit &gt; 0)&#123; </span><br><span class="line">                //唤醒</span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //消息传递实现</span><br><span class="line">    //</span><br><span class="line">    // 创建两个队列为邮箱 一个存放&quot;有东西的箱子&quot; 让消费者取,取完将空箱子放到第二个队列,</span><br><span class="line">    //生产者从空箱子队列取箱子装东西放到 第一个队列</span><br><span class="line">    // 生产者阻塞:没有空箱子(队列2为空),消费者阻塞:没有东西取(队列1为空)</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a>2.4 死锁</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>死锁概念</p>
</li>
<li><p>条件</p>
</li>
<li><p>避免</p>
</li>
<li><p>预防</p>
</li>
</ul>
<h1 id="第四章IO设备管理"><a href="#第四章IO设备管理" class="headerlink" title="第四章IO设备管理"></a>第四章IO设备管理</h1><p>RAIDRAID的基本特性由两部分组成:磁盘阵列(一组磁盘)可以并行工作，磁盘阵列管理软件磁盘阵列一组数据管理软件在逻辑上连续交叉分布，存储在磁盘阵列中到磁盘上。优点:磁盘阵列管理软件可以并行处理一组数据的单个或多个数据访问请求。磁盘阵列管理软件还负责校验存储相关信息。受益:当磁盘阵列出现磁盘故障时，磁盘阵列管理软件可以恢复磁盘上的数据。磁盘阵列管理软件屏蔽了磁盘阵列的物理细节，操作系统的其他成分不知道磁盘阵列的存在;在他们看来，逻辑盘的容量过大。</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h2><p>Java NIO,AIO 依赖于epoll</p>
<p>IO两个阶段等待数据 (写入socket直到socket可读) 将数据从内核复制到用户空间复制完成返回成功指示</p>
<h3 id="1-阻塞IO"><a href="#1-阻塞IO" class="headerlink" title="1. 阻塞IO"></a>1. 阻塞IO</h3><p>进程阻塞于两个阶段 直到最后返回成功指示</p>
<p><img src="/../images/image-20220921100207210.png" alt="image-20220921100207210"></p>
<h3 id="2-非阻塞IO"><a href="#2-非阻塞IO" class="headerlink" title="2.  非阻塞IO"></a>2.  非阻塞IO</h3><p><img src="/../images/image-20220921100344115.png" alt="image-20220921100344115"></p>
<h3 id="3-IO多路复用"><a href="#3-IO多路复用" class="headerlink" title="3. IO多路复用"></a>3. IO多路复用</h3><p><strong>select异步阻塞IO</strong> 由select帮线程轮询socket 但是进程阻塞于select直到多个socket其中一个可读</p>
<p><img src="/../images/image-20220921100545404.png" alt="image-20220921100545404"></p>
<p>select使用了Reactor设计模式 由select帮线程轮询socket 可读后在通知用户线程</p>
<h3 id="4-信号驱动-第一阶段非阻塞IO"><a href="#4-信号驱动-第一阶段非阻塞IO" class="headerlink" title="4. (信号驱动)第一阶段非阻塞IO"></a>4. (信号驱动)第一阶段非阻塞IO</h3><h3 id="5-真正的异步IO"><a href="#5-真正的异步IO" class="headerlink" title="5. 真正的异步IO"></a>5. 真正的异步IO</h3><p>两个阶段都不需要阻塞</p>
<p>linux中的aio_read</p>
<p><img src="/../images/image-20220921101124634.png" alt="image-20220921101124634"></p>
<h2 id="select、poll、epoll的区别？"><a href="#select、poll、epoll的区别？" class="headerlink" title="select、poll、epoll的区别？"></a>select、poll、epoll的区别？</h2><blockquote>
<p>select, poll, epoll 都是I&#x2F;O多路复用的具体的实现，之所以有这三个存在，其实是他们出现是有先后顺序的。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/nanxiaotao/article/details/90612404">https://blog.csdn.net/nanxiaotao/article/details/90612404</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/9166944.html">https://www.cnblogs.com/aspirant/p/9166944.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/32163005">https://www.zhihu.com/question/32163005</a></li>
</ul>
</blockquote>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ol>
<li>它仅仅知道了，有I&#x2F;O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</li>
<li>单个进程可监视的fd_set(监听的端口个数)数量被限制：32位机默认是1024个，64位机默认是2048。</li>
</ol>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll本质上和select没有区别，采用<strong>链表</strong>的方式替换原有fd_set数据结构,而使其<strong>没有连接数的限制</strong>。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ol>
<li>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I&#x2F;O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数。即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
<li>epoll通过内核和用户空间共享一块内存来实现的。select和poll都是内核需要将消息传递到用户空间，都需要内核拷贝动作</li>
<li>epoll有EPOLLLT和EPOLLET两种触发模式。(<strong>暂时不去记，有个印象，大致是什么样就可以</strong>)</li>
</ol>
<h2 id="linux进程管理"><a href="#linux进程管理" class="headerlink" title="linux进程管理"></a>linux进程管理</h2><p>进程类型</p>
<p>前台进程 占用终端shell</p>
<blockquote>
<p>在Linux系统中执行某些操作时候，有时需要将当前任务暂停调至后台好执行其他命令；有时又得将后台暂停的任务调至前台重新运行。这些操作可使用 jobs、bg 和 fg 三个命令以及 Ctrl + z 快捷键来完成。</p>
<p>按下ctr+z，将当前运行的程序放入后台挂起，此时你就可以执行其他任务了。<br>jobs 命令，显示后台被挂起的所有进程<br>bg N 使第N个序号的任务在后台运行<br>fg N 使第N个序号的任务在前台运行</p>
<p>ctr+c 退出前台进程</p>
<p>注：默认bg,fg不带N时表示对最后一个进程操作!<br>例如：<br>假如我在使用 vim a.js遍历一个文件，此时我可以使用ctrl+z将vim放入后台；再调用less config.cfg查看文件，暂时找到需要的东西后再使用ctrl+z将less查看放入后台； jobs查看所有的后台任务。记下刚才挂起的vim序列号为1，再通过fg 1将其从后台重新放入前台进行编辑。</p>
</blockquote>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>从整体上看，netstat的输出结果可以分为两个部分：</p>
<p>一个是Active Internet connections，称为有源TCP连接，其中”Recv-Q”和”Send-Q”指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。</p>
<p><img src="/../images/image-20221002102520729-1666009739255.png" alt="image-20221002102520729"></p>
<p>另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。</p>
<p><img src="/../images/image-20221002102413211-1666009739255.png" alt="image-20221002102413211"></p>
<blockquote>
<p>Proto显示连接使用的协议</p>
<p>RefCnt表示连接到本套接口上的进程号</p>
<p>Types显示套接口的类型</p>
<p>State显示套接口当前的状态</p>
<p>Path表示连接到套接口的其它进程使用的路径名</p>
</blockquote>
<p>-a 显示所有连接和侦听端口，默认不显示LISTEN相关<br>-b 显示在创建每个连接或侦听端口时涉及的可执行程序。在某些情况下，已知可执行程序承载多个独立的组件，这些情况下，显示创建连接或侦听端口时涉及的组件序列。在此情况下，可执行程序的名称位于底部 [] 中，它调用的组件位于顶部，直至达到 TCP&#x2F;IP。注意，此选项可能很耗时，并且在你没有足够权限时可能失败。<br>-e 显示以太网统计信息。此选项可以与 -s 选项结合使用。</p>
<p>-i 显示网络接口列表<br>-n 以数字形式显示地址和端口号。<br>-o 显示拥有的与每个连接关联的进程 ID。<br>-p proto 显示 proto 指定的协议的连接；proto可以是下列任何一个: TCP、UDP、TCPv6 或 UDPv6。如果与 -s选项一起用来显示每个协议的统计信息，proto 可以是下列任何一个:IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 或 UDPv6。<br>-q 显示所有连接、侦听端口和绑定的非侦听 TCP 端口。绑定的非侦听端口不一定与活动连接相关联。<br>-r 显示路由表。<br>-s 显示每个协议的统计信息。默认情况下，显示 IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息;-p 选项可用于指定默认的子网。<br>interval 重新显示选定的统计信息，各个显示间暂停的间隔秒数。按 CTRL+C 停止重新显示统计信息。如果省略，则 netstat 将打印当前的配置信息一次。<br>-t (tcp)仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-c 每隔一个固定时间，执行该netstat命令，netstat 将每隔一秒输出网络信息。</p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。</p>
<p>ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p>
<p>ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。</p>
<p>linux上进程有5种状态</p>
<ol>
<li><p>运行(正在运行或在运行队列中等待)</p>
</li>
<li><p>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</p>
</li>
<li><p>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</p>
</li>
<li><p>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</p>
</li>
<li><p>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</p>
</li>
</ol>
<p>ps工具标识进程的5种状态码</p>
<p>D 不可中断 uninterruptible sleep (usually IO)</p>
<p>R 运行 runnable (on run queue)</p>
<p>S 中断 sleeping</p>
<p>T 停止 traced or stopped</p>
<p>Z 僵死 a defunct (”zombie”) process</p>
<p>语法</p>
<p>ps [option]</p>
<p>命令参数</p>
<p>a      显示所有进程</p>
<p>-a     显示同一终端下的所有程序</p>
<p>-A     显示所有进程</p>
<p>c      显示进程的真实名称</p>
<p>-N     反向选择</p>
<p>-e     等于“-A”</p>
<p>e      显示环境变量</p>
<p>f      显示程序间的关系</p>
<p>-H     显示树状结构</p>
<p>r      显示当前终端的进程</p>
<p>T      显示当前终端的所有程序</p>
<p>u      指定用户的所有进程</p>
<p>-au    显示较详细的资讯</p>
<p>-aux   显示所有包含其他使用者的行程</p>
<p>-C&lt;命令&gt;     列出指定命令的状况</p>
<p>–lines&lt;行数&gt;     每页显示的行数</p>
<p>–width&lt;字符数&gt;     每页显示的字符数</p>
<p>–help      显示帮助信息</p>
<p>–version     显示版本显示</p>
<p>部分使用实例</p>
<p> ps -A           显示所有进程信息<br> ps -u root    显示指定用户信息</p>
<p> ps -ef          显示所有进程信息，连同命令行</p>
<p> ps -ef | grep ssh    查找特定进程</p>
<p> ps -l            将目前属于您自己这次登入的 PID 与相关信息列示出来</p>
<p> ps aux          列出目前所有的正在内存当中的程序</p>
<p>ps -axjf        列出类似程序树的程序显示</p>
<p>ps aux | egrep ‘(cron|syslog)’       找出与 cron 与 syslog 这两个服务有关的 PID 号码</p>
<p>ps -aux | more      可以用 | 管道和 more 连接起来分页查看</p>
<p> ps -aux &gt; ps001.txt      把所有进程显示出来，并输出到ps001.txt文件</p>
<p> ps -o pid,ppid,pgrp,session,tpgid,comm      输出指定的字段</p>
<p>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</p>
<p>S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</p>
<p>UID 程序被该 UID 所拥有</p>
<p>PID 就是这个程序的 ID ！</p>
<p>PPID 则是其上级父程序的ID</p>
<p><strong>C CPU 使用的资源百分比</strong></p>
<p>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</p>
<p>NI 这个是 Nice 值，在下一小节我们会持续介绍</p>
<p>ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</p>
<p>SZ 使用掉的内存大小</p>
<p>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</p>
<p>TTY 登入者的终端机位置</p>
<p><strong>TIME 使用掉的 CPU 时间。</strong></p>
<p>CMD 所下达的指令为何在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，所以， 当我使用 ps -l 的时候，只有三个 PID。</p>
<p>USER：该 process 属于那个使用者账号的</p>
<p>PID ：该 process 的号码</p>
<p>%CPU：该 process 使用掉的 CPU 资源百分比</p>
<p>%MEM：该 process 所占用的物理内存百分比</p>
<p>VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)</p>
<p>RSS ：该 process 占用的固定的内存量 (Kbytes)</p>
<p>STIME 启动时间</p>
<p><strong>TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts&#x2F;0 等等的，则表示为由网络连接进主机的程序。</strong></p>
<p>STAT：该程序目前的状态，主要的状态有</p>
<p>R ：该程序目前正在运作，或者是可被运作</p>
<p>S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。</p>
<p>T ：该程序目前正在侦测或者是停止了</p>
<p>Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</p>
<p>START：该 process 被触发启动的时间</p>
<p>TIME ：<strong>该 process 实际使用 CPU 运作的时间</strong></p>
<p>COMMAND：该程序的实际指令</p>
<p>ps -ef<br>UID          PID    PPID  C STIME TTY          TIME CMD</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io">ggq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io/2022/09/01/15os/">https://gouguoqiang.github.io/2022/09/01/15os/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gouguoqiang.github.io" target="_blank">ggq</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/01/13MQ/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MQ</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/01/16net/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Net</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ggq</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章 操作系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1What%E2%80%99s-OS"><span class="toc-number">1.1.</span> <span class="toc-text">1.1What’s OS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-OS%E7%9A%84%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 OS的系统需求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82"><span class="toc-number">1.2.1.</span> <span class="toc-text">软件系统的系统需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82"><span class="toc-number">1.2.2.</span> <span class="toc-text">功能性需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82"><span class="toc-number">1.2.3.</span> <span class="toc-text">非功能性需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OS%E5%AF%B9%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="toc-number">1.2.4.</span> <span class="toc-text">OS对硬件平台的依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9AJob%EF%BC%88%E4%BD%9C%E4%B8%9A%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">基本概念：Job（作业）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9AThread-amp-Process"><span class="toc-number">1.2.6.</span> <span class="toc-text">基本概念：Thread&amp;Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-Virtual-Memory-amp-File"><span class="toc-number">1.2.7.</span> <span class="toc-text">基本概念 Virtual Memory&amp;File</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-OS%E7%9A%84%E6%BC%94%E5%8F%98%EF%BC%8C%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 OS的演变，类型及特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OS%E8%BF%9B%E8%A1%8C%E6%BC%94%E5%8F%98%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">OS进行演变的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%A4%84%E7%90%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">串行处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">简单批处理系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-OS%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 OS体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84OS%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.4.1.</span> <span class="toc-text">一种常见的OS总体结构风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OS%E5%9F%BA%E7%A1%80%E5%B9%B3%E5%8F%B0%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.4.2.</span> <span class="toc-text">OS基础平台子系统结构风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">双模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%B0%83%E5%BA%A6"><span class="toc-number">2.</span> <span class="toc-text">第二章 进程和调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 进程描述和控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OS%E7%9A%84%E4%B8%BB%E8%A6%81%E8%A6%81%E6%B1%82"><span class="toc-number">2.1.1.</span> <span class="toc-text">OS的主要要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">程序执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.3.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swapping%EF%BC%88%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%EF%BC%89"><span class="toc-number">2.1.4.</span> <span class="toc-text">Swapping（交换技术）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.1.5.</span> <span class="toc-text">进程描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OS%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.6.</span> <span class="toc-text">OS内核功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.7.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1%E8%B0%83%E5%BA%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1调度类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">简述操作系统进程的相关调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.2.2.2.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-3%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.</span> <span class="toc-text">2.2.3实时系统与实时调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%B9%B6%E5%8F%91"><span class="toc-number">2.4.</span> <span class="toc-text">2.3 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.3.1 并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">并发设计的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%80%A7%E7%9A%84%E5%9B%B0%E9%9A%BE"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">并发性的困难</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.3.2 并发进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">操作系统问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8%E8%BF%87%E7%A8%8B-%E7%90%86%E8%A7%A3"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">相互作用过程(理解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%88%E4%BD%9C%E9%80%9A%E8%BF%87%E6%B2%9F%E9%80%9A"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">进程间的合作通过沟通</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.3.3 互斥条件与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">互斥的要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E6%96%B9%E6%B3%95-Approaches-of-Mutual-Exclusion"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">互斥的方法(Approaches of Mutual Exclusion)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">生产者消费者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%AD%BB%E9%94%81"><span class="toc-number">2.5.</span> <span class="toc-text">2.4 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.5.0.1.</span> <span class="toc-text">概述</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0IO%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">第四章IO设备管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux"><span class="toc-number">4.</span> <span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">五种IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%BB%E5%A1%9EIO"><span class="toc-number">4.1.1.</span> <span class="toc-text">1. 阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.  非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">3. IO多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">4.1.4.</span> <span class="toc-text">4. (信号驱动)第一阶段非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%BC%82%E6%AD%A5IO"><span class="toc-number">4.1.5.</span> <span class="toc-text">5. 真正的异步IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select%E3%80%81poll%E3%80%81epoll%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">select、poll、epoll的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select"><span class="toc-number">4.2.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll"><span class="toc-number">4.2.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">4.2.3.</span> <span class="toc-text">epoll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">linux进程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">4.4.</span> <span class="toc-text">常用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat"><span class="toc-number">4.4.1.</span> <span class="toc-text">netstat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ps"><span class="toc-number">4.5.</span> <span class="toc-text">ps</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/01/%E7%AE%97%E6%B3%95/7%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/AcWing/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/02/01/%E7%AE%97%E6%B3%95/7%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/AcWing/" title="无题">无题</a><time datetime="2023-02-01T15:55:11.432Z" title="发表于 2023-02-01 23:55:11">2023-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/31/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/ruiji/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/01/31/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/ruiji/" title="无题">无题</a><time datetime="2023-01-31T14:50:49.607Z" title="发表于 2023-01-31 22:50:49">2023-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/21/%E7%AE%97%E6%B3%95/00pythonapi/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/12/21/%E7%AE%97%E6%B3%95/00pythonapi/" title="无题">无题</a><time datetime="2022-12-21T14:08:13.553Z" title="发表于 2022-12-21 22:08:13">2022-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/12/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E/0%E7%AE%80%E4%BB%8B/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/12/12/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E/0%E7%AE%80%E4%BB%8B/" title="无题">无题</a><time datetime="2022-12-12T15:06:58.895Z" title="发表于 2022-12-12 23:06:58">2022-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/19/22CloudNative/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/11/19/22CloudNative/" title="无题">无题</a><time datetime="2022-11-19T15:17:22.198Z" title="发表于 2022-11-19 23:17:22">2022-11-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By ggq</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>