<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MQ | ggq</title><meta name="keywords" content="缓存,中间件"><meta name="author" content="ggq"><meta name="copyright" content="ggq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MQ总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="MQ">
<meta property="og:url" content="https://gouguoqiang.github.io/2022/09/01/13MQ/index.html">
<meta property="og:site_name" content="ggq">
<meta property="og:description" content="MQ总结。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-01T03:51:56.000Z">
<meta property="article:modified_time" content="2022-10-17T12:53:26.135Z">
<meta property="article:author" content="ggq">
<meta property="article:tag" content="缓存">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://gouguoqiang.github.io/2022/09/01/13MQ/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MQ',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-17 20:53:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ggq</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MQ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-01T03:51:56.000Z" title="发表于 2022-09-01 11:51:56">2022-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-17T12:53:26.135Z" title="更新于 2022-10-17 20:53:26">2022-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MQ"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0. 学习目标"></a>0. 学习目标</h1><ul>
<li>能够说出什么是消息中间件</li>
<li>能够安装RabbitMQ</li>
<li>能够编写RabbitMQ的入门程序</li>
<li>能够说出RabbitMQ的5种模式特征</li>
<li>能够使用Spring整合RabbitMQ</li>
</ul>
<h1 id="1-消息中间件概述"><a href="#1-消息中间件概述" class="headerlink" title="1. 消息中间件概述"></a>1. 消息中间件概述</h1><h2 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1. 什么是消息中间件"></a>1.1. 什么是消息中间件</h2><p>MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法。</p>
<ul>
<li><p>为什么使用MQ</p>
<p>在项目中，可将一些无需即时返回且耗时的操作提取出来，进行<strong>异步处理</strong>，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而<strong>提高</strong>了<strong>系统</strong>的<strong>吞吐量</strong>。</p>
<blockquote>
<p>疑惑1:另起一个线程(是MQ吗)来处理,MQ的作用是将消息写到消息队列,减少了服务器将消息写入缓冲区的同步操作?</p>
</blockquote>
</li>
<li><p>开发中消息队列通常有如下应用场景：</p>
<p>1、任务<strong>异步</strong>处理</p>
<p>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p>
<blockquote>
<p>接疑惑1:另起的”线程”是一个消费方,来进行处理吗</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>解惑: 另一个消费端相当于另一个线程 来做主线程本该做的事</p>
</blockquote>
<h5 id="1-并发编程又叫多线程编程。"><a href="#1-并发编程又叫多线程编程。" class="headerlink" title="1.并发编程又叫多线程编程。"></a>1.<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B9%B6%E5%8F%91&spm=1001.2101.3001.7020">并发</a>编程又叫多线程编程。</h5><p>      在程序中，往往有很多很耗时的工作，比如上传文件、下载文件、跟客户聊天需要长时间建立连接。这种时候，一个线程是服务不了多个用户的，会产生因为资源独占产生的等待问题。并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间的多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率（买票问题并发进行）。<br>    并发当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。</p>
<h5 id="2-“并行”指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。（hadoop集群就是并行计算的）"><a href="#2-“并行”指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。（hadoop集群就是并行计算的）" class="headerlink" title="2.“并行”指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。（hadoop集群就是并行计算的）"></a>2.“并行”指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。（hadoop集群就是并行计算的）</h5><p>    当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。</p>
<h6 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h6><p>    并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。</p>
<h5 id="3-串行、并行："><a href="#3-串行、并行：" class="headerlink" title="3.串行、并行："></a>3.串行、并行：</h5><p>      并行和串行指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行，异步是多个任务并行的前提条件。</p>
<h5 id="4-同步、异步："><a href="#4-同步、异步：" class="headerlink" title="4.同步、异步："></a>4.同步、异步：</h5><p>      指的是能否开启新的线程。同步不能开启新的线程，异步可以。<br>      异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。<br>      异步和<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。</p>
<h5 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5.多线程"></a>5.多线程</h5><p>      多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。</p>
<p>  rabbitmq一个典型的使用场景就是异步处理<br>  场景说明：用户注册后，向用户发注册邮件和注册短信。</p>
<p>  我们在进行以上场景开发时，通常会使用两种方式实现。</p>
<p>  串行的方式</p>
<p>  在没有mq中间件之前，我们通常使用这种方式实现，实现起来很容易，比如先将用户信息插入数据库，然后发送成功注册的邮件、短信。以上三个任务完成后才会给用户响应，但我们应该都知道，对于邮件、短信，对于系统核心业务来说这都不是必须马上发送的，这样的实现方式无非会增加系统的响应时间，甚至给用户带来不好的体验。可以认为就是一个线程在串行执行三个任务。</p>
<p>  <img src="https://img-blog.csdnimg.cn/2ce055a7f0e549b398e59152d9262491.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX3J1bm5pbmc0Sg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>  并行的方式<br>  将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。可以认为是三个线程在同时处理不同的任务，并行执行。</p>
<p>  <img src="https://img-blog.csdnimg.cn/9146589a1c4a4c03812bd3c172840128.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAX3J1bm5pbmc0Sg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>  有了以上的应用场景，我们可以联想到其他的应用场景，比如一个用户同时下单了多个商品，此时系统要向该用户及商家发送下单消息。这个场景主要分为两个任务：1.生成订单 2.向用户和服务商发送下单消息。而生成订单任务是系统的核心业务，发送消息的任务就可以异步执行，否则每次都要访问一次数据库插入一条消息记录，增加了下单操作的响应时间。 下面就是此应用场景的实战。<br>  原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41519304/article/details/120432790">https://blog.csdn.net/qq_41519304/article/details/120432790</a></p>
<p>  2、应用程序<strong>解耦合</strong></p>
<p>  MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p>
<p>  3、<strong>削峰填谷</strong></p>
<p>  如订单系统，在下单的时候就会往数据库写数据。但是数据库只能支撑每秒1000左右的并发写入，并发量再高就容易宕机。低峰期的时候并发也就100多个，但是在高峰期时候，并发量会突然激增到5000以上，这个时候数据库肯定卡死了。</p>
<p>  <img src="/../images/01.jpg"></p>
<p>  消息被MQ保存起来了，然后系统就可以按照自己的消费能力来消费，比如每秒1000个数据，这样慢慢写入数据库，这样就不会卡死数据库了。</p>
<p>  <img src="/../images/02.jpg"></p>
<p>  但是使用了MQ之后，限制消费消息的速度为1000，但是这样一来，高峰期产生的数据势必会被积压在MQ中，高峰就被“削”掉了。但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000QPS，直到消费完积压的消息,这就叫做“填谷”</p>
<p>  <img src="/../images/03.jpg"></p>
<h2 id="1-2-AMQP-和-JMS"><a href="#1-2-AMQP-和-JMS" class="headerlink" title="1.2. AMQP 和 JMS"></a>1.2. AMQP 和 JMS</h2><p>MQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。</p>
<h3 id="1-2-1-AMQP"><a href="#1-2-1-AMQP" class="headerlink" title="1.2.1. AMQP"></a>1.2.1. AMQP</h3><p>AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接<strong>定义网络交换的数据格式</strong>。</p>
<h3 id="1-2-2-JMS"><a href="#1-2-2-JMS" class="headerlink" title="1.2.2. JMS"></a>1.2.2. JMS</h3><p>JMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p>
<h3 id="1-2-3-AMQP-与-JMS-区别"><a href="#1-2-3-AMQP-与-JMS-区别" class="headerlink" title="1.2.3. AMQP 与 JMS 区别"></a>1.2.3. AMQP 与 JMS 区别</h3><ul>
<li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li>
<li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li>
<li>JMS规定了两种消息模式；而AMQP的消息模式更加丰富</li>
</ul>
<h2 id="1-3-消息队列产品"><a href="#1-3-消息队列产品" class="headerlink" title="1.3. 消息队列产品"></a>1.3. 消息队列产品</h2><p>市场上常见的消息队列有如下：</p>
<ul>
<li>ActiveMQ：基于JMS</li>
<li>ZeroMQ：基于C语言开发</li>
<li>RabbitMQ：基于<strong>AMQP</strong>协议，erlang语言开发，稳定性好</li>
<li>RocketMQ：基于<strong>JMS</strong>，阿里巴巴产品</li>
<li>Kafka：类似MQ的产品；分布式消息系统，高吞吐量</li>
</ul>
<h2 id="1-4-RabbitMQ"><a href="#1-4-RabbitMQ" class="headerlink" title="1.4. RabbitMQ"></a>1.4. RabbitMQ</h2><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p>
<p>RabbitMQ官方地址：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a></p>
<p>RabbitMQ提供了6种模式：简单模式，work模式，Publish&#x2F;Subscribe发布与订阅模式，Routing路由模式，Topics主题模式，RPC远程调用模式（远程调用，不太算MQ；暂不作介绍）；</p>
<p>官网对应模式介绍：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p>
<p><img src="/../images/1555988678324.png" alt="1555988678324"></p>
<h1 id="2-安装及配置RabbitMQ"><a href="#2-安装及配置RabbitMQ" class="headerlink" title="2. 安装及配置RabbitMQ"></a>2. 安装及配置RabbitMQ</h1><p>详细查看 <code>资料/软件/安装RabbitMQ.md</code> 文档。</p>
<h1 id="3-RabbitMQ入门"><a href="#3-RabbitMQ入门" class="headerlink" title="3. RabbitMQ入门"></a>3. RabbitMQ入门</h1><h2 id="3-1-搭建示例工程"><a href="#3-1-搭建示例工程" class="headerlink" title="3.1. 搭建示例工程"></a>3.1. 搭建示例工程</h2><h3 id="3-1-1-创建工程"><a href="#3-1-1-创建工程" class="headerlink" title="3.1.1. 创建工程"></a>3.1.1. 创建工程</h3><p><img src="/../images/1558319510387.png" alt="1555991321159"></p>
<p><img src="/../images/1558319546688.png" alt="1555991353704"></p>
<h3 id="3-1-2-添加依赖"><a href="#3-1-2-添加依赖" class="headerlink" title="3.1.2. 添加依赖"></a>3.1.2. 添加依赖</h3><p>往heima-rabbitmq的pom.xml文件中添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-2-编写生产者"><a href="#3-2-编写生产者" class="headerlink" title="3.2. 编写生产者"></a>3.2. 编写生产者</h2><p>编写消息生产者com.itheima.rabbitmq.simple.Producer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.rabbitmq.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//主机地址;默认为 localhost</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">//连接端口;默认为 5672</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//虚拟主机名称;默认为 /</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        <span class="comment">//连接用户名；默认为guest</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;heima&quot;</span>);</span><br><span class="line">        <span class="comment">//连接密码；默认为guest</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;heima&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明（创建）队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名称</span></span><br><span class="line"><span class="comment">         * 参数2：是否定义持久化队列</span></span><br><span class="line"><span class="comment">         * 参数3：是否独占本次连接</span></span><br><span class="line"><span class="comment">         * 参数4：是否在不使用的时候自动删除队列</span></span><br><span class="line"><span class="comment">         * 参数5：队列其它参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要发送的信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;你好；小兔子！&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span></span><br><span class="line"><span class="comment">         * 参数2：路由key,简单模式可以传递队列名称</span></span><br><span class="line"><span class="comment">         * 参数3：消息其它属性</span></span><br><span class="line"><span class="comment">         * 参数4：消息内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;已发送消息：&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在执行上述的消息发送之后；可以登录rabbitMQ的管理控制台，可以发现队列和其消息：</p>
<p><img src="/../images/1556006638979.png" alt="1556006638979"></p>
<p><img src="/../images/1556006647177.png" alt="1556006647177"></p>
<h2 id="3-3-编写消费者"><a href="#3-3-编写消费者" class="headerlink" title="3.3. 编写消费者"></a>3.3. 编写消费者</h2><p>抽取创建connection的工具类com.itheima.rabbitmq.util.ConnectionUtil；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.rabbitmq.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//主机地址;默认为 localhost</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">//连接端口;默认为 5672</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//虚拟主机名称;默认为 /</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);</span><br><span class="line">        <span class="comment">//连接用户名；默认为guest</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;heima&quot;</span>);</span><br><span class="line">        <span class="comment">//连接密码；默认为guest</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;heima&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="keyword">return</span> connectionFactory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>编写消息的消费者com.itheima.rabbitmq.simple.Consumer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.rabbitmq.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.rabbitmq.util.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建频道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明（创建）队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名称</span></span><br><span class="line"><span class="comment">         * 参数2：是否定义持久化队列</span></span><br><span class="line"><span class="comment">         * 参数3：是否独占本次连接</span></span><br><span class="line"><span class="comment">         * 参数4：是否在不使用的时候自动删除队列</span></span><br><span class="line"><span class="comment">         * 参数5：队列其它参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(Producer.QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者；并设置消息处理</span></span><br><span class="line">        <span class="type">DefaultConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span></span><br><span class="line"><span class="comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span></span><br><span class="line"><span class="comment">             * properties 属性信息</span></span><br><span class="line"><span class="comment">             * body 消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">//路由key</span></span><br><span class="line">                System.out.println(<span class="string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());</span><br><span class="line">                <span class="comment">//交换机</span></span><br><span class="line">                System.out.println(<span class="string">&quot;交换机为：&quot;</span> + envelope.getExchange());</span><br><span class="line">                <span class="comment">//消息id</span></span><br><span class="line">                System.out.println(<span class="string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">                <span class="comment">//收到的消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到的消息为：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听消息</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：队列名称</span></span><br><span class="line"><span class="comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span></span><br><span class="line"><span class="comment">         * 参数3：消息接收到后回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(Producer.QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不关闭资源，应该一直监听消息</span></span><br><span class="line">        <span class="comment">//channel.close();</span></span><br><span class="line">        <span class="comment">//connection.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4. 小结"></a>3.4. 小结</h2><p>上述的入门案例中中其实使用的是如下的简单模式：</p>
<p><img src="/../images/1555991074575.png" alt="1555991074575"></p>
<p>在上图的模型中，有以下概念：</p>
<ul>
<li>P：生产者，也就是要发送消息的程序</li>
<li>C：消费者：消息的接受者，会一直等待消息到来。</li>
<li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li>
</ul>
<h1 id="4-AMQP"><a href="#4-AMQP" class="headerlink" title="4. AMQP"></a>4. AMQP</h1><h2 id="4-1-相关概念介绍"><a href="#4-1-相关概念介绍" class="headerlink" title="4.1. 相关概念介绍"></a>4.1. 相关概念介绍</h2><p>AMQP  一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</p>
<p>AMQP是一个二进制协议，拥有一些现代化特点：多信道、协商式，异步，安全，扩平台，中立，高效。</p>
<p>RabbitMQ是AMQP协议的Erlang的实现。</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>连接Connection</td>
<td>一个网络连接，比如TCP&#x2F;IP套接字连接。</td>
</tr>
<tr>
<td>会话Session</td>
<td>端点之间的命名对话。在一个会话上下文中，保证“恰好传递一次”。</td>
</tr>
<tr>
<td>信道Channel</td>
<td>多路复用连接中的一条独立的双向数据流通道。为会话提供物理传输介质。</td>
</tr>
<tr>
<td>客户端Client</td>
<td>AMQP连接或者会话的发起者。AMQP是非对称的，客户端生产和消费消息，服务器存储和路由这些消息。</td>
</tr>
<tr>
<td>服务节点Broker</td>
<td>消息中间件的服务节点；一般情况下可以将一个RabbitMQ Broker看作一台RabbitMQ 服务器。</td>
</tr>
<tr>
<td>端点</td>
<td>AMQP对话的任意一方。一个AMQP连接包括两个端点（一个是客户端，一个是服务器）。</td>
</tr>
<tr>
<td>消费者Consumer</td>
<td>一个从消息队列里请求消息的客户端程序。</td>
</tr>
<tr>
<td>生产者Producer</td>
<td>一个向交换机发布消息的客户端应用程序。</td>
</tr>
</tbody></table>
<h2 id="4-2-RabbitMQ运转流程"><a href="#4-2-RabbitMQ运转流程" class="headerlink" title="4.2. RabbitMQ运转流程"></a>4.2. RabbitMQ运转流程</h2><p>在入门案例中：</p>
<ul>
<li>生产者发送消息<ol>
<li>生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker；</li>
<li>声明队列并设置属性；如是否排它，是否持久化，是否自动删除；</li>
<li>将路由键（空字符串）与队列绑定起来；</li>
<li>发送消息至RabbitMQ Broker；</li>
<li>关闭信道；</li>
<li>关闭连接；</li>
</ol>
</li>
<li>消费者接收消息<ol>
<li>消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker</li>
<li>向Broker 请求消费相应队列中的消息，设置相应的回调函数；</li>
<li>等待Broker回应闭关投递响应队列中的消息，消费者接收消息；</li>
<li>确认（ack，自动确认）接收到的消息；</li>
<li>RabbitMQ从队列中删除相应已经被确认的消息；</li>
<li>关闭信道；</li>
<li>关闭连接；</li>
</ol>
</li>
</ul>
<p><img src="/../images/1565105223969.png" alt="1565105223969"></p>
<h2 id="4-3-生产者流转过程说明"><a href="#4-3-生产者流转过程说明" class="headerlink" title="4.3. 生产者流转过程说明"></a>4.3. 生产者流转过程说明</h2><ol>
<li>客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start&#x2F;.Start-OK 、Connection.Tune&#x2F;.Tune-Ok ，Connection.Open&#x2F; .Open-Ok 这6 个命令的交互。</li>
<li>客户端调用connection.createChannel方法。此方法开启信道，其包装的channel.open命令发送给Broker,等待channel.basicPublish方法，对应的AMQP命令为Basic.Publish,这个命令包含了content Header 和content Body()。content Header 包含了消息体的属性，例如:投递模式，优先级等，content Body 包含了消息体本身。</li>
<li>客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。</li>
</ol>
<p><img src="/../images/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B%E5%9B%BE.bmp" alt="生产者流转过程图"></p>
<h2 id="4-4-消费者流转过程说明"><a href="#4-4-消费者流转过程说明" class="headerlink" title="4.4. 消费者流转过程说明"></a>4.4. 消费者流转过程说明</h2><ol>
<li>消费者客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start&#x2F;.Start-OK 、Connection.Tune&#x2F;.Tune-Ok ，Connection.Open&#x2F; .Open-Ok 这6 个命令的交互。</li>
<li>消费者客户端调用connection.createChannel方法。和生产者客户端一样，协议涉及Channel . Open&#x2F;Open-Ok命令。</li>
<li>在真正消费之前，消费者客户端需要向Broker 发送Basic.Consume 命令(即调用channel.basicConsume 方法〉将Channel 置为接收模式，之后Broker 回执Basic . Consume - Ok 以告诉消费者客户端准备好消费消息。</li>
<li>Broker 向消费者客户端推送(Push) 消息，即Basic.Deliver 命令，这个命令和Basic.Publish 命令一样会携带Content Header 和Content Body。</li>
<li>消费者接收到消息并正确消费之后，向Broker 发送确认，即Basic.Ack 命令。</li>
<li>客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。</li>
</ol>
<p><img src="/../images/%E6%B6%88%E8%B4%B9%E8%80%85%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B%E5%9B%BE.bmp" alt="消费者流转过程图"></p>
<h1 id="RabbitMQ高级内容介绍"><a href="#RabbitMQ高级内容介绍" class="headerlink" title="RabbitMQ高级内容介绍"></a>RabbitMQ高级内容介绍</h1><p><strong>RabbitMQ高级特性</strong></p>
<p>消息可靠性投递<br>Consumer ACK<br>消费端限流<br>TTL<br>死信队列<br>延迟队列<br>日志与监控<br>消息可靠性分析与追踪<br>管理</p>
<p><strong>RabbitMQ应用问题</strong></p>
<p>消息可靠请保障<br>消息幂等性处理</p>
<p><strong>RabbitMQ集群搭建</strong></p>
<p>RabbitMQ高可用集群</p>
<h2 id="1、RabbitMQ高级特性"><a href="#1、RabbitMQ高级特性" class="headerlink" title="1、RabbitMQ高级特性"></a>1、RabbitMQ高级特性</h2><h3 id="1-1、消息的可靠投递"><a href="#1-1、消息的可靠投递" class="headerlink" title="1.1、消息的可靠投递"></a>1.1、消息的可靠投递</h3><p>1、定义<br>在使用RabbitMQ的时候，作为消息发送方希望杜绝任何消息丢失或投递失败场景。RabbitMQ为我们提供了两种方式用来控制消息的投递可靠性模式。</p>
<p>confirm 确认模式<br>return退回模式<br>rabbitMQ整个消息投递的路径为：<br>pruducer —&gt;rabbitMQ broker —-&gt;exchange——&gt;queue —-&gt; consumer</p>
<p>消息从producer到exchange则会返回一个confirmCallback。<br>消息从exchange–&gt;queue投递失败则会返回一个returnCallback。<br>我们将利用这两个callback控制消息的可靠性投递。</p>
<p>我们都知道，消息从生产端到消费端消费要经过3个步骤：</p>
<ol>
<li>生产端发送消息到RabbitMQ；</li>
<li>RabbitMQ发送消息到消费端；</li>
<li>消费端消费这条消息；</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/pC6q3OmkGY9dBicAx7Bv97xbQIvSXjeIOkbybkBIydNU0Uv1qPfS4b83Sv3KLZFmMl0KwavONWG284OB6qPy7tA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这3个步骤中的每一步都有可能导致消息丢失，消息丢失不可怕，可怕的是丢失了我们还不知道，所以要有一些措施来保证系统的可靠性。这里的可靠并不是一定就100%不丢失了，磁盘损坏，机房爆炸等等都能导致数据丢失，当然这种都是极小概率发生，能做到99.999999%消息不丢失，就是可靠的了。下面来具体分析一下问题以及解决方案。</p>
<h3 id="生产端可靠性投递"><a href="#生产端可靠性投递" class="headerlink" title="生产端可靠性投递"></a>生产端可靠性投递</h3><p>生产端可靠性投递，即生产端要确保将消息正确投递到RabbitMQ中。生产端投递的消息丢失的原因有很多，比如消息在网络传输的过程中发生网络故障消息丢失，或者消息投递到RabbitMQ时RabbitMQ挂了，那消息也可能丢失，而我们根本不知道发生了什么。针对以上情况，RabbitMQ本身提供了一些机制。</p>
<h3 id="事务消息机制"><a href="#事务消息机制" class="headerlink" title="事务消息机制"></a>事务消息机制</h3><p>事务消息机制由于会严重降低性能，所以一般不采用这种方法，我就不介绍了，而采用另一种轻量级的解决方案——confirm消息确认机制。</p>
<h3 id="confirm消息确认机制"><a href="#confirm消息确认机制" class="headerlink" title="confirm消息确认机制"></a>confirm消息确认机制</h3><p>什么是confirm消息确认机制？顾名思义，就是生产端投递的消息一旦投递到RabbitMQ后，RabbitMQ就会发送一个确认消息给生产端，让生产端知道我已经收到消息了，否则这条消息就可能已经丢失了，需要生产端重新发送消息了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/pC6q3OmkGY9dBicAx7Bv97xbQIvSXjeIOLibgvyviaLSZ1YZawnjELnibjBTeLXP6El2rGeM0kqQwCVsc0icFe4rHjg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>通过下面这句代码来开启确认模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.confirmSelect();// 开启发送方确认模式</span><br></pre></td></tr></table></figure>

<p>然后异步监听确认和未确认的消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">channel.addConfirmListener(new ConfirmListener() &#123;</span><br><span class="line">    //消息正确到达broker</span><br><span class="line">    @Override</span><br><span class="line">    public void handleAck(long deliveryTag, boolean multiple) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;已收到消息&quot;);</span><br><span class="line">        //做一些其他处理</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息</span><br><span class="line">    @Override</span><br><span class="line">    public void handleNack(long deliveryTag, boolean multiple) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;未确认消息，标识：&quot; + deliveryTag);</span><br><span class="line">        //做一些其他处理，比如消息重发等</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样就可以让生产端感知到消息是否投递到RabbitMQ中了，当然这样还不够，稍后我会说一下极端情况。</p>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>那消息持久化呢？我们知道，RabbitMQ收到消息后将这个消息暂时存在了内存中，那这就会有个问题，如果RabbitMQ挂了，那重启后数据就丢失了，所以相关的数据应该持久化到硬盘中，这样就算RabbitMQ重启后也可以到硬盘中取数据恢复。那如何持久化呢？</p>
<p>message消息到达RabbitMQ后先是到exchange交换机中，然后路由给queue队列，最后发送给消费端。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/pC6q3OmkGY9dBicAx7Bv97xbQIvSXjeIO8V9H7jdLtC5CY6gI9icERMg2RW7rQdicoDhZ7PbOOWKuKpUhNKzvzZOw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所有需要给exchange、queue和message都进行持久化：</p>
<p>exchange持久化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//第三个参数true表示这个exchange持久化</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;, true);</span><br></pre></td></tr></table></figure>

<p>queue持久化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//第二个参数true表示这个queue持久化</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br></pre></td></tr></table></figure>

<p>message持久化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//第三个参数MessageProperties.PERSISTENT_TEXT_PLAIN表示这条消息持久化</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>

<p>这样，如果RabbitMQ收到消息后挂了，重启后会自行恢复消息。</p>
<p>到此，RabbitMQ提供的几种机制都介绍完了，但这样还不足以保证消息可靠性投递RabbitMQ中，上面我也提到了会有极端情况，比如RabbitMQ收到消息还没来得及将消息持久化到硬盘时，RabbitMQ挂了，这样消息还是丢失了，或者RabbitMQ在发送确认消息给生产端的过程中，由于网络故障而导致生产端没有收到确认消息，这样生产端就不知道RabbitMQ到底有没有收到消息，就不好做接下来的处理。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/pC6q3OmkGY9dBicAx7Bv97xbQIvSXjeIOmZYV3SQyuhHFftCYpfp0hYwL9hiauWLNHtoUO4Kicf4iafbQxbrPz3DWQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所以除了RabbitMQ提供的一些机制外，我们自己也要做一些消息补偿机制，以应对一些极端情况。接下来我就介绍其中的一种解决方案——消息入库。</p>
<h3 id="消息入库"><a href="#消息入库" class="headerlink" title="消息入库"></a>消息入库</h3><p>消息入库，顾名思义就是将要发送的消息保存到数据库中。</p>
<p>首先发送消息前先将消息保存到数据库中，有一个状态字段status&#x3D;0，表示生产端将消息发送给了RabbitMQ但还没收到确认；在生产端收到确认后将status设为1，表示RabbitMQ已收到消息。这里有可能会出现上面说的两种情况，所以生产端这边开一个定时器，定时检索消息表，将status&#x3D;0并且超过固定时间后（可能消息刚发出去还没来得及确认这边定时器刚好检索到这条status&#x3D;0的消息，所以给个时间）还没收到确认的消息取出重发（第二种情况下这里会造成消息重复，消费者端要做幂等性），可能重发还会失败，所以可以做一个最大重发次数，超过就做另外的处理。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/pC6q3OmkGY9dBicAx7Bv97xbQIvSXjeIOiamt0icWwuuhSydDvqrWVbSseob6FVDa6FJFESuKrdX5psljslmSXdeQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这样消息就可以可靠性投递到RabbitMQ中了，而生产端也可以感知到了。</p>
<h3 id="消费端消息不丢失"><a href="#消费端消息不丢失" class="headerlink" title="消费端消息不丢失"></a>消费端消息不丢失</h3><p>既然已经可以让生产端100%可靠性投递到RabbitMQ了，那接下来就改看看消费端的了，如何让消费端不丢失消息。</p>
<p>默认情况下，以下3种情况会导致消息丢失：</p>
<ul>
<li>在RabbitMQ将消息发出后，消费端还没接收到消息之前，发生网络故障，消费端与RabbitMQ断开连接，此时消息会丢失；</li>
<li>在RabbitMQ将消息发出后，消费端还没接收到消息之前，消费端挂了，此时消息会丢失；</li>
<li>消费端正确接收到消息，但在处理消息的过程中发生异常或宕机了，消息也会丢失。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/pC6q3OmkGY9dBicAx7Bv97xbQIvSXjeIO2P45SY4QCTGJOVr8uoBMOhicGzFVDhaYkRmYI9AmTiahflMorQubXlIQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其实，上述3中情况导致消息丢失归根结底是因为RabbitMQ的自动ack机制，即默认RabbitMQ在消息发出后就立即将这条消息删除，而不管消费端是否接收到，是否处理完，导致消费端消息丢失时RabbitMQ自己又没有这条消息了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/pC6q3OmkGY9dBicAx7Bv97xbQIvSXjeIOKwvia1QRw7kTuVxlrrUGKgp7iaQAKOdxEY10QicIc40ym57diajjAv2xuA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所以就需要将自动ack机制改为手动ack机制。</p>
<p>消费端手动确认消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //接收到消息，做处理</span><br><span class="line">        //手动确认</span><br><span class="line">        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        //出错处理，这里可以让消息重回队列重新发送或直接丢弃消息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//第二个参数autoAck设为false表示关闭自动确认机制，需手动确认</span><br><span class="line">channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，当autoAck参数置为false，对于RabbitMQ服务端而言，队列中的消息分成了两个部分：一部分是等待投递给消费端的消息；一部分是已经投递给消费端，但是还没有收到消费端确认信号的消息。如果RabbitMQ一直没有收到消费端的确认信号，并且消费此消息的消费端已经断开连接或宕机（RabbitMQ会自己感知到），则RabbitMQ会安排该消息重新进入队列（放在队列头部），等待投递给下一个消费者，当然也有能还是原来的那个消费端，当然消费端也需要确保幂等性。</p>
<p>好了，到此从生产端到RabbitMQ再到消费端的全链路，就可以保证数据的不丢失。</p>
<h1 id="简单实践"><a href="#简单实践" class="headerlink" title="简单实践"></a>简单实践</h1><h2 id="官网get-start"><a href="#官网get-start" class="headerlink" title="官网get start"></a>官网get start</h2><ol>
<li>要先将RabbitMQ 已<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/download.html">安装</a>并运行在<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/networking.html#ports">标准端口</a>( 5672 )上的localhost上。如果您使用不同的主机、端口或凭据，则需要调整连接设置。</li>
<li>其他操作没有实际意义就不写了,主要是使用Java客户端与服务端进行连接</li>
</ol>
<h2 id="6-2-发送支付状态"><a href="#6-2-发送支付状态" class="headerlink" title="6.2 发送支付状态"></a>6.2 发送支付状态</h2><p>(1)集成RabbitMQ</p>
<p>修改支付微服务，集成RabbitMQ，添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加入ampq--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>这里我们建议在后台手动创建队列，并绑定队列。如果使用程序创建队列，可以按照如下方式实现。</p>
<p>修改application.yml，配置支付队列和交换机信息，代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位置支付交换机和队列</span></span><br><span class="line"><span class="attr">mq</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">pay</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">exchange</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">order</span>: <span class="string">exchange.order</span></span><br><span class="line">    <span class="attr">queue</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">order</span>: <span class="string">queue.order</span></span><br><span class="line">    <span class="attr">routing</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">key</span>: <span class="string">queue.order</span></span><br></pre></td></tr></table></figure>



<p>创建队列以及交换机并让队列和交换机绑定，修改com.changgou.WeixinPayApplication,添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 创建DirectExchange交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">basicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(env.getProperty(<span class="string">&quot;mq.pay.exchange.order&quot;</span>), <span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 创建队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean(name = &quot;queueOrder&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueOrder</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(env.getProperty(<span class="string">&quot;mq.pay.queue.order&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****</span></span><br><span class="line"><span class="comment"> * 队列绑定到交换机上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">basicBinding</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queueOrder()).to(basicExchange()).with(env.getProperty(<span class="string">&quot;mq.pay.routing.key&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-2-2-发送MQ消息"><a href="#6-2-2-发送MQ消息" class="headerlink" title="6.2.2 发送MQ消息"></a>6.2.2 发送MQ消息</h4><p>修改回调方法，在接到支付信息后，立即将支付信息发送给RabbitMQ，代码如下：</p>
<p><img src="/../images/1558578639907.png" alt="1558578639907"></p>
<p>上图代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;mq.pay.exchange.order&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String exchange;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;mq.pay.queue.order&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String queue;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;mq.pay.routing.key&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String routing;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WeixinPayService weixinPayService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 支付回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/notify/url&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">notifyUrl</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    InputStream inStream;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//读取支付回调数据</span></span><br><span class="line">        inStream = request.getInputStream();</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">outSteam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = inStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            outSteam.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        outSteam.close();</span><br><span class="line">        inStream.close();</span><br><span class="line">        <span class="comment">// 将支付回调数据转换成xml字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(outSteam.toByteArray(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//将xml字符串转换成Map结构</span></span><br><span class="line">        Map&lt;String, String&gt; map = WXPayUtil.xmlToMap(result);</span><br><span class="line">        <span class="comment">//将消息发送给RabbitMQ</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange,routing, JSON.toJSONString(map));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//响应数据设置</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">respMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        respMap.put(<span class="string">&quot;return_code&quot;</span>,<span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">        respMap.put(<span class="string">&quot;return_msg&quot;</span>,<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> WXPayUtil.mapToXml(respMap);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//记录错误日志</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-监听MQ消息处理订单"><a href="#6-3-监听MQ消息处理订单" class="headerlink" title="6.3 监听MQ消息处理订单"></a>6.3 监听MQ消息处理订单</h3><p>在订单微服务中，我们需要监听MQ支付状态消息，并实现订单数据操作。</p>
<h4 id="6-3-1-集成RabbitMQ"><a href="#6-3-1-集成RabbitMQ" class="headerlink" title="6.3.1 集成RabbitMQ"></a>6.3.1 集成RabbitMQ</h4><p>在订单微服务中，先集成RabbitMQ，再监听队列消息。</p>
<p>在pom.xml中引入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加入ampq--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>在application.yml中配置rabbitmq配置，代码如下：</p>
<p><img src="/../images/1558578894925.png" alt="1558578894925"></p>
<p>在application.yml中配置队列名字，代码如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#位置支付交换机和队列</span></span><br><span class="line"><span class="attr">mq</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">pay</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">queue</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">order</span>: <span class="string">queue.order</span></span><br></pre></td></tr></table></figure>





<h4 id="6-3-2-监听消息修改订单"><a href="#6-3-2-监听消息修改订单" class="headerlink" title="6.3.2 监听消息修改订单"></a>6.3.2 监听消息修改订单</h4><p>在订单微服务于中创建com.changgou.order.consumer.OrderPayMessageListener，并在该类中consumeMessage方法，用于监听消息，并根据支付状态处理订单，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;$&#123;mq.pay.queue.order&#125;&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPayMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 接收消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="comment">//将数据转成Map</span></span><br><span class="line">        Map&lt;String,String&gt; result = JSON.parseObject(msg,Map.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//return_code=SUCCESS</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">return_code</span> <span class="operator">=</span> result.get(<span class="string">&quot;return_code&quot;</span>);</span><br><span class="line">        <span class="comment">//业务结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result_code</span> <span class="operator">=</span> result.get(<span class="string">&quot;result_code&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//业务结果 result_code=SUCCESS/FAIL，修改订单状态</span></span><br><span class="line">        <span class="keyword">if</span>(return_code.equalsIgnoreCase(<span class="string">&quot;success&quot;</span>) )&#123;</span><br><span class="line">            <span class="comment">//获取订单号</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">outtradeno</span> <span class="operator">=</span> result.get(<span class="string">&quot;out_trade_no&quot;</span>);</span><br><span class="line">            <span class="comment">//业务结果</span></span><br><span class="line">            <span class="keyword">if</span>(result_code.equalsIgnoreCase(<span class="string">&quot;success&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(outtradeno!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//修改订单状态  out_trade_no</span></span><br><span class="line">                    orderService.updateStatus(outtradeno,result.get(<span class="string">&quot;transaction_id&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//订单删除</span></span><br><span class="line">                orderService.deleteOrder(outtradeno);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-定时处理订单状态-学员完成"><a href="#7-定时处理订单状态-学员完成" class="headerlink" title="7 定时处理订单状态(学员完成)"></a>7 定时处理订单状态(学员完成)</h2><h3 id="7-1-业务分析"><a href="#7-1-业务分析" class="headerlink" title="7.1 业务分析"></a>7.1 业务分析</h3><p>在现实场景中，可能会出现这么种情况，就是用户支付后，有可能畅购服务网络不通或者服务器挂了，此时会导致回调地址无法接收到用户支付状态，这时候我们需要取微信服务器查询。所以我们之前订单信息的ID存入到了Redis队列，主要用于解决这种网络不可达造成支付状态无法回调获取的问题。</p>
<p>实现思路如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.每次下单，都将订单存入到Reids</span> <span class="string">List队列中</span></span><br><span class="line"><span class="attr">2.定时每5秒检查一次Redis</span> <span class="string">队列中是否有数据，如果有，则再去查询微信服务器支付状态</span></span><br><span class="line"><span class="attr">3.如果已支付，则修改订单状态</span></span><br><span class="line"><span class="attr">4.如果没有支付，是等待支付，则再将订单存入到Redis队列中，等会再次检查</span></span><br><span class="line"><span class="attr">5.如果是支付失败，直接删除订单信息并修改订单状态</span></span><br></pre></td></tr></table></figure>

<h1 id="消息中间件-amp-RabbitMQ面试"><a href="#消息中间件-amp-RabbitMQ面试" class="headerlink" title="消息中间件&amp;RabbitMQ面试"></a>消息中间件&amp;RabbitMQ面试</h1><h3 id="什么是RabbitMQ？"><a href="#什么是RabbitMQ？" class="headerlink" title="什么是RabbitMQ？"></a>什么是RabbitMQ？</h3><p>RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件</p>
<h3 id="为什么使用MQ？MQ的优点"><a href="#为什么使用MQ？MQ的优点" class="headerlink" title="为什么使用MQ？MQ的优点"></a>为什么使用MQ？MQ的优点</h3><ul>
<li>异步处理 - 相比于传统的串行、并行方式，提高了系统的吞吐量。</li>
<li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li>
<li>流量削锋 - 可以通过消息队列长度控制请求量，可以缓解短时间内的高并发请求。</li>
<li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯消息通讯上。比如实现点对点消息队列，或者聊天室等。</li>
<li>日志处理 - 解决大量日志传输。(todo)</li>
</ul>
<h3 id="你们公司生产环境用的是什么消息中间件？"><a href="#你们公司生产环境用的是什么消息中间件？" class="headerlink" title="@$你们公司生产环境用的是什么消息中间件？"></a>@$你们公司生产环境用的是什么消息中间件？</h3><p>这个首先你可以说下你们公司选用的是什么消息中间件，比如用的是RabbitMQ，然后可以初步给一些你<strong>对不同MQ中间件技术的选型分析</strong>。</p>
<p>举个例子：比如说ActiveMQ是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。</p>
<p>但是问题在于ActiveMQ没法支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，现在在国内互联网公司落地较少。而且使用较多的是一些传统企业，<strong>用ActiveMQ做异步调用和系统解耦</strong>。</p>
<p><strong>然后你可以说说RabbitMQ</strong>，他的好处在于可以支撑高并发、高吞吐量、性能很高，同时有非常完善便捷的后台管理界面可以使用。</p>
<p>另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。</p>
<p>而且经过调研，国内各大互联网公司落地RabbitMQ集群支撑自身业务的case较多，国内各种中小型互联网公司使用RabbitMQ的实践也比较多。</p>
<p>除此之外，RabbitMQ的开源社区很活跃，较高频率的版本迭代，来修复发现的bug以及进行各种优化，因此综合考虑过后，公司采取了RabbitMQ。</p>
<p>但是RabbitMQ也有一点缺陷，就是他自身是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，需要较为扎实的erlang语言功底。</p>
<p><strong>然后可以聊聊RocketMQ</strong>，是阿里开源的，经过阿里生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。</p>
<p>而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上问题，包括源码的二次开发和改造。</p>
<p><strong>另外就是Kafka</strong>。Kafka提供的消息中间件的功能明显较少一些，相对上述几款MQ中间件要少很多。</p>
<p>但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景。</p>
<p>因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。</p>
<h3 id="ActiveMQ、RabbitMQ、RocketMQ、Kafka有什么优缺点？"><a href="#ActiveMQ、RabbitMQ、RocketMQ、Kafka有什么优缺点？" class="headerlink" title="ActiveMQ、RabbitMQ、RocketMQ、Kafka有什么优缺点？"></a>ActiveMQ、RabbitMQ、RocketMQ、Kafka有什么优缺点？</h3><table>
<thead>
<tr>
<th></th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
<th>ZeroMQ</th>
</tr>
</thead>
<tbody><tr>
<td>单机吞吐量</td>
<td>比RabbitMQ低</td>
<td>2.6w&#x2F;s（消息做持久化）</td>
<td>11.6w&#x2F;s</td>
<td>17.3w&#x2F;s</td>
<td>29w&#x2F;s</td>
</tr>
<tr>
<td>开发语言</td>
<td>Java</td>
<td>Erlang</td>
<td>Java</td>
<td>Scala&#x2F;Java</td>
<td>C</td>
</tr>
<tr>
<td>主要维护者</td>
<td>Apache</td>
<td>Mozilla&#x2F;Spring</td>
<td>Alibaba</td>
<td>Apache</td>
<td>iMatix，创始人已去世</td>
</tr>
<tr>
<td>成熟度</td>
<td>成熟</td>
<td>成熟</td>
<td>开源版本不够成熟</td>
<td>比较成熟</td>
<td>只有C、PHP等版本成熟</td>
</tr>
<tr>
<td>订阅形式</td>
<td>点对点(p2p)、广播（发布-订阅）</td>
<td>提供了4种：direct, topic  ,Headers和fanout。fanout就是广播模式</td>
<td>基于topic&#x2F;messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式</td>
<td>基于topic以及按照topic进行正则匹配的发布订阅模式</td>
<td>点对点(p2p)</td>
</tr>
<tr>
<td>持久化</td>
<td>支持少量堆积</td>
<td>支持少量堆积</td>
<td>支持大量堆积</td>
<td>支持大量堆积</td>
<td>不支持</td>
</tr>
<tr>
<td>顺序消息</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>性能稳定性</td>
<td>好</td>
<td>好</td>
<td>一般</td>
<td>较差</td>
<td>很好</td>
</tr>
<tr>
<td>集群方式</td>
<td>支持简单集群模式，比如’主-备’，对高级集群模式支持不好。</td>
<td>支持简单集群，’复制’模式，对高级集群模式支持不好。</td>
<td>常用 多对’Master-Slave’ 模式，开源版本需手动切换Slave变成Master</td>
<td>天然的‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave</td>
<td>不支持</td>
</tr>
<tr>
<td>管理界面</td>
<td>一般</td>
<td>较好</td>
<td>一般</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<p>综上，各种对比之后，有如下建议：</p>
<p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p>
<p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p>
<p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p>
<p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p>
<p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>
<h3 id="MQ-有哪些常见问题？如何解决这些问题？"><a href="#MQ-有哪些常见问题？如何解决这些问题？" class="headerlink" title="@$MQ 有哪些常见问题？如何解决这些问题？"></a>@$MQ 有哪些常见问题？如何解决这些问题？</h3><p>MQ 的常见问题有：</p>
<ol>
<li>消息的顺序问题</li>
<li>消息的重复问题</li>
</ol>
<p><strong>消息的顺序问题</strong></p>
<p>消息有序指的是可以按照消息的发送顺序来消费。</p>
<p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmkno7bwIquViazkPCvfjdzZMHynjarXgIh34D28nXSDIfj614yUAOLr55BPJcunqZJJxuXU0FFeq3Iw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>解决方案：</p>
<p>保证生产者 - MQServer - 消费者是一对一对一的关系</p>
<p>RabbitMQ：拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmkno7bwIquViazkPCvfjdzZMHzlkN0iao7e8tB9tfcIIvBxlySwZVuTqcIU201hvW1lnAwt2eUBW1Prw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>缺陷：</p>
<ul>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。通过合理的设计或者将问题分解来规避。</li>
<li>不关注顺序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序，所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</li>
</ul>
<p>其他解决方案</p>
<p>方案一：消费端增加消息记录表，暂存不满足业务条件的消息，并采用定时器进行补偿处理，补偿超次进行预警；（该方案对技术营运友好，目前DMS正在使用，同样该方案可以用来解决重复消费问题）</p>
<p>方案二：消费端对不满足业务条件的消息不进行确认，多次消费失败进入死信队列，监听死信队列进行补偿，补偿超次或失败进行预警；</p>
<p>方案三：采用RocketMQ顺序消费机制；（不建议使用，会降低系统吞吐量）</p>
<blockquote>
<p>todo 消息记录表</p>
</blockquote>
<p><strong>消息的重复问题</strong></p>
<p>造成消息重复的根本原因是：网络不可达。</p>
<p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<p><strong>消费端处理消息的业务逻辑需要保持幂等性</strong>。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号和添加一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p>
<h3 id="消息积压怎么处理"><a href="#消息积压怎么处理" class="headerlink" title="@$消息积压怎么处理"></a>@$消息积压怎么处理</h3><p><strong>消息积压的原因</strong></p>
<p>消息积压的直接原因，一定是系统中<strong>某个部分出现了性能问题</strong>，<strong>来不及处理上游发送的消息</strong>，才会导致消息积压。</p>
<p>如果日常系统正常运转的时候，没有积压或者只有少量积压很快就消费掉了，但是<strong>某一个时刻</strong>，突然就开始积压消息并且积压持续上涨。这种情况下需要你在短时间内找到消息积压的原因，迅速解决问题才不至于影响业务。</p>
<p><strong>消息积压的处理</strong></p>
<p>排查消息积压原因的方法：能导致积压突然增加，最粗粒度的原因，只有两种：要么是<strong>发送变快</strong>了，要么是<strong>消费变慢</strong>了。</p>
<ul>
<li>大部分消息队列都内置了<strong>监控</strong>的功能，只要通过监控数据，很容易确定是哪种原因。如果是单位时间发送的消息增多，比如说是赶上大促或者抢购，短时间内不太可能优化消费端的代码来提升消费性能，唯一的方法是通过<strong>扩容消费端的实例数</strong>来提升总体的消费能力。如果短时间内没有足够的服务器资源进行扩容，没办法的办法是，将系统降级，通过<strong>关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务</strong>。</li>
<li>还有一种不太常见的情况，你通过监控发现，无论是<strong>发送消息的速度还是消费消息的速度和原来都没什么变化</strong>，这时候你需要检查一下你的消费端，<strong>是不是消费失败导致的一条消息反复消费这种情况比较多</strong>，这种情况也会拖慢整个系统的消费速度。</li>
<li>如果监控到消费变慢了，你需要检查你的消费实例，分析一下是什么原因导致消费变慢。优先<strong>检查一下日志是否有大量的消费错误</strong>，如果没有错误的话，可以通过打印堆栈信息，看一下你的消费线程是不是卡在什么地方不动了，比如触发了死锁或者卡在等待某些资源上了。</li>
</ul>
<h3 id="如何保证RabbitMQ消息的可靠传输？消息丢失怎么办？"><a href="#如何保证RabbitMQ消息的可靠传输？消息丢失怎么办？" class="headerlink" title="@$如何保证RabbitMQ消息的可靠传输？消息丢失怎么办？"></a>@$如何保证RabbitMQ消息的可靠传输？消息丢失怎么办？</h3><p>消息不可靠的情况可能是消息丢失，劫持等原因；</p>
<p>丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；</p>
<p><strong>生产者丢失消息</strong>：<strong>从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息</strong>；</p>
<p>transaction机制就是说：发送消息前，开启事务（channel.txSelect()），然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()），如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；</p>
<p>confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，生产者可以进行重试操作。</p>
<p><strong>消息队列丢数据</strong>：<strong>消息持久化</strong>。</p>
<p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。</p>
<p>这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。</p>
<p>这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p>
<p>那么如何持久化呢？</p>
<p>这里顺便说一下吧，其实也很容易，就下面两步</p>
<ol>
<li>将queue的持久化标识durable设置为true，则代表是一个持久的队列</li>
<li>发送消息的时候将deliveryMode&#x3D;2</li>
</ol>
<p>这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据</p>
<p><strong>消费者丢失消息</strong>：<strong>消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可</strong>！</p>
<p>消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息；</p>
<p>如果这时处理消息失败，就会丢失该消息；</p>
<p>解决方案：处理消息成功后，手动回复确认消息。</p>
<blockquote>
<p>todo 手动回复确认消息</p>
</blockquote>
<h3 id="RabbitMQ-常见工作模式和应用场景"><a href="#RabbitMQ-常见工作模式和应用场景" class="headerlink" title="@$RabbitMQ 常见工作模式和应用场景"></a>@$RabbitMQ 常见工作模式和应用场景</h3><blockquote>
<p>交换机todo</p>
</blockquote>
<h4 id="一、简单模式"><a href="#一、简单模式" class="headerlink" title="一、简单模式"></a>一、简单模式</h4><p><strong>原理</strong>：一个生产者，一个消费者。生产者将消息发送到队列，消费者监听消息队列，如果队列中有消息，就进行消费，消费后消息从队列中删除</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmkno7bwIquViazkPCvfjdzZMHibmVhict02blIuMdmOhbSfibXfQUqFuzeULkRn1DOsUicRKBDZyicxx5zrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>场景</strong>：聊天；有一个oa系统，用户通过接收手机验证码进行注册，页面上点击获取验证码后，将验证码放到消息队列，然后短信服务从队列中获取到验证码，并发送给用户。</p>
<h4 id="二、工作模式"><a href="#二、工作模式" class="headerlink" title="二、工作模式"></a>二、工作模式</h4><p><strong>原理</strong>：一个生产者，多个消费者，一条消息只能被一个消费者消费。生产者将消息发送到消息队列，多个消费者同时监听一个队列，谁先抢到消息谁负责消费。这样就形成了资源竞争，谁的资源空闲大，争抢到的可能性就大。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmkno7bwIquViazkPCvfjdzZMHEjraC7ibYc9zic9ia1R9lznzSibYvv2Xu2kWTNfZjEicvibDia6L6ic4geGfRw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>场景</strong>：红包；有一个电商平台，有两个订单服务，用户下单的时候，任意一个订单服务消费用户的下单请求生成订单即可。不用两个订单服务同时消费用户的下单请求。</p>
<h4 id="三、发布订阅模式"><a href="#三、发布订阅模式" class="headerlink" title="三、发布订阅模式"></a>三、发布订阅模式</h4><p><strong>原理</strong>：一个生产者，多个消费者，每个消费者都可以收到相同的消息。生产者将消息发送到交换机，交换机类型是fanout，不同的队列注册到交换机上，不同的消费者监听不同的队列，所有消费者都会收到消息。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmkno7bwIquViazkPCvfjdzZMHkr5ichPA9pFNj1puBxjfSXM3hH78DnmVpkjNNzFTBEMn3Rxu7W4HjMQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>场景</strong>：邮件群发，群聊天，广播(广告)；有一个商城，我们新添加一个商品后，可能同时需要去更新缓存和数据库。</p>
<h4 id="四、路由模式"><a href="#四、路由模式" class="headerlink" title="四、路由模式"></a>四、路由模式</h4><p><strong>原理</strong>：生产者将消息发送给交换机，消息携带具体的routingkey。交换机类型是direct，交换机匹配与之绑定的队列的routingkey，分发到不同的队列上。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmkno7bwIquViazkPCvfjdzZMHN5CQ9b11ibXa2lIcichateQY2zpbPVicmpEh9Nsaicv0pp1Uibv9hFibSXzw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>场景</strong>：还是一样，有一个商城，新添加了一个商品，实时性不是很高，只需要添加到数据库即可，不用刷新缓存。</p>
<h4 id="五、主题模式"><a href="#五、主题模式" class="headerlink" title="五、主题模式"></a>五、主题模式</h4><p><strong>原理</strong>：路由模式的一种，交换机类型是topic，路由功能添加了模糊匹配。星号（*）代表1个单词，#号（#）代表一个或多个单词。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/O8AYEZicmmkno7bwIquViazkPCvfjdzZMHvjYY36cr5osZiap7iaibianqwur8YYvr00lJfGe7eegq1pGT1ZVyy9xyfA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>场景</strong>：还是一样，有一个商城，新添加了一个商品，实时性不是很高，只需要添加到数据库即可，数据库包含了主数据库mysql1和从数据库mysql2的内容，不用刷新缓存。</p>
<h4 id="六、RPC"><a href="#六、RPC" class="headerlink" title="六、RPC"></a>六、RPC</h4><p>1、首先客户端发送一个reply_to和corrention_id的请求，发布到RPC队列中；</p>
<p>2、服务器端处理这个请求，并把处理结果发布到一个回调Queue,此Queue的名称应当与reply_to的名称一致</p>
<p>3、客户端从回调Queue中得到先前corrention_id设定的值的处理结果。如果碰到和先前不一样的corrention_id的值，将会忽略而不是抛出异常。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/O8AYEZicmmkno7bwIquViazkPCvfjdzZMHKGy5ssF8eG6UtXiauAOWTsSBibrPDgBg80qvMW8TicRWsawBqKR8Eia61w/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="如何保证高可用的？RabbitMQ-的集群"><a href="#如何保证高可用的？RabbitMQ-的集群" class="headerlink" title="@$如何保证高可用的？RabbitMQ 的集群"></a>@$如何保证高可用的？RabbitMQ 的集群</h3><p>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p>
<p><strong>单机模式</strong>，就是 Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式</p>
<p><strong>普通集群模式</strong>，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p>
<blockquote>
<p>类似 nginx vip(queue) 只是大家可以直接找到queue被连接也能提供服务,而不是消费端直连vip</p>
</blockquote>
<p><strong>镜像集群模式</strong>：这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io">ggq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gouguoqiang.github.io/2022/09/01/13MQ/">https://gouguoqiang.github.io/2022/09/01/13MQ/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gouguoqiang.github.io" target="_blank">ggq</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%93%E5%AD%98/">缓存</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/01/0suibi/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">suibi</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/01/17linux/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/01/18Nginx/" title="Nginx"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-01</div><div class="title">Nginx</div></div></a></div><div><a href="/2022/09/01/5redis/" title="redis"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-01</div><div class="title">redis</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ggq</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">1.</span> <span class="toc-text">0. 学习目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">1. 消息中间件概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">1.1. 什么是消息中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%8F%88%E5%8F%AB%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E3%80%82"><span class="toc-number">2.1.0.0.1.</span> <span class="toc-text">1.并发编程又叫多线程编程。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E2%80%9C%E5%B9%B6%E8%A1%8C%E2%80%9D%E6%8C%87%E4%B8%A4%E4%B8%AA%E6%88%96%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8A%E4%BA%8B%E4%BB%B6%E6%88%96%E6%B4%BB%E5%8A%A8%E5%9C%A8%E5%90%8C%E4%B8%80%E6%97%B6%E5%88%BB%E5%8F%91%E7%94%9F%E3%80%82%E5%9C%A8%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E5%B9%B6%E8%A1%8C%E6%80%A7%E4%BD%BF%E5%A4%9A%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%90%8C%E4%B8%80%E6%97%B6%E5%88%BB%E5%8F%AF%E5%9C%A8%E4%B8%8D%E5%90%8CCPU%E4%B8%8A%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C%E3%80%82%EF%BC%88hadoop%E9%9B%86%E7%BE%A4%E5%B0%B1%E6%98%AF%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%89"><span class="toc-number">2.1.0.0.2.</span> <span class="toc-text">2.“并行”指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。（hadoop集群就是并行计算的）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">2.1.0.0.2.1.</span> <span class="toc-text">并发和并行</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%EF%BC%9A"><span class="toc-number">2.1.0.0.3.</span> <span class="toc-text">3.串行、并行：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%EF%BC%9A"><span class="toc-number">2.1.0.0.4.</span> <span class="toc-text">4.同步、异步：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.0.0.5.</span> <span class="toc-text">5.多线程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-AMQP-%E5%92%8C-JMS"><span class="toc-number">2.2.</span> <span class="toc-text">1.2. AMQP 和 JMS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-AMQP"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.2.1. AMQP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-JMS"><span class="toc-number">2.2.2.</span> <span class="toc-text">1.2.2. JMS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-AMQP-%E4%B8%8E-JMS-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.3.</span> <span class="toc-text">1.2.3. AMQP 与 JMS 区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E5%93%81"><span class="toc-number">2.3.</span> <span class="toc-text">1.3. 消息队列产品</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-RabbitMQ"><span class="toc-number">2.4.</span> <span class="toc-text">1.4. RabbitMQ</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AERabbitMQ"><span class="toc-number">3.</span> <span class="toc-text">2. 安装及配置RabbitMQ</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-RabbitMQ%E5%85%A5%E9%97%A8"><span class="toc-number">4.</span> <span class="toc-text">3. RabbitMQ入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%90%AD%E5%BB%BA%E7%A4%BA%E4%BE%8B%E5%B7%A5%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">3.1. 搭建示例工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">3.1.1. 创建工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="toc-number">4.1.2.</span> <span class="toc-text">3.1.2. 添加依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%BC%96%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">4.2.</span> <span class="toc-text">3.2. 编写生产者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%BC%96%E5%86%99%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">4.3.</span> <span class="toc-text">3.3. 编写消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%B0%8F%E7%BB%93"><span class="toc-number">4.4.</span> <span class="toc-text">3.4. 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-AMQP"><span class="toc-number">5.</span> <span class="toc-text">4. AMQP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">4.1. 相关概念介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-RabbitMQ%E8%BF%90%E8%BD%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">4.2. RabbitMQ运转流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">5.3.</span> <span class="toc-text">4.3. 生产者流转过程说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%B6%88%E8%B4%B9%E8%80%85%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">5.4.</span> <span class="toc-text">4.4. 消费者流转过程说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E9%AB%98%E7%BA%A7%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.</span> <span class="toc-text">RabbitMQ高级内容介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">1、RabbitMQ高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%8A%95%E9%80%92"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.1、消息的可靠投递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%AB%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92"><span class="toc-number">6.1.2.</span> <span class="toc-text">生产端可靠性投递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.3.</span> <span class="toc-text">事务消息机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#confirm%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.4.</span> <span class="toc-text">confirm消息确认机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">6.1.5.</span> <span class="toc-text">消息持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%85%A5%E5%BA%93"><span class="toc-number">6.1.6.</span> <span class="toc-text">消息入库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">6.1.7.</span> <span class="toc-text">消费端消息不丢失</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.</span> <span class="toc-text">简单实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%98%E7%BD%91get-start"><span class="toc-number">7.1.</span> <span class="toc-text">官网get start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%8F%91%E9%80%81%E6%94%AF%E4%BB%98%E7%8A%B6%E6%80%81"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 发送支付状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E5%8F%91%E9%80%81MQ%E6%B6%88%E6%81%AF"><span class="toc-number">7.2.0.1.</span> <span class="toc-text">6.2.2 发送MQ消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E7%9B%91%E5%90%ACMQ%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E8%AE%A2%E5%8D%95"><span class="toc-number">7.2.1.</span> <span class="toc-text">6.3 监听MQ消息处理订单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E9%9B%86%E6%88%90RabbitMQ"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">6.3.1 集成RabbitMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E7%9B%91%E5%90%AC%E6%B6%88%E6%81%AF%E4%BF%AE%E6%94%B9%E8%AE%A2%E5%8D%95"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">6.3.2 监听消息修改订单</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9A%E6%97%B6%E5%A4%84%E7%90%86%E8%AE%A2%E5%8D%95%E7%8A%B6%E6%80%81-%E5%AD%A6%E5%91%98%E5%AE%8C%E6%88%90"><span class="toc-number">7.3.</span> <span class="toc-text">7 定时处理订单状态(学员完成)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%B8%9A%E5%8A%A1%E5%88%86%E6%9E%90"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.1 业务分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-amp-RabbitMQ%E9%9D%A2%E8%AF%95"><span class="toc-number">8.</span> <span class="toc-text">消息中间件&amp;RabbitMQ面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRabbitMQ%EF%BC%9F"><span class="toc-number">8.0.1.</span> <span class="toc-text">什么是RabbitMQ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8MQ%EF%BC%9FMQ%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">8.0.2.</span> <span class="toc-text">为什么使用MQ？MQ的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E5%85%AC%E5%8F%B8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F"><span class="toc-number">8.0.3.</span> <span class="toc-text">@$你们公司生产环境用的是什么消息中间件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ActiveMQ%E3%80%81RabbitMQ%E3%80%81RocketMQ%E3%80%81Kafka%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">8.0.4.</span> <span class="toc-text">ActiveMQ、RabbitMQ、RocketMQ、Kafka有什么优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MQ-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.0.5.</span> <span class="toc-text">@$MQ 有哪些常见问题？如何解决这些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">8.0.6.</span> <span class="toc-text">@$消息积压怎么处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81RabbitMQ%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">8.0.7.</span> <span class="toc-text">@$如何保证RabbitMQ消息的可靠传输？消息丢失怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.0.8.</span> <span class="toc-text">@$RabbitMQ 常见工作模式和应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.0.8.1.</span> <span class="toc-text">一、简单模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.0.8.2.</span> <span class="toc-text">二、工作模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.0.8.3.</span> <span class="toc-text">三、发布订阅模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.0.8.4.</span> <span class="toc-text">四、路由模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.0.8.5.</span> <span class="toc-text">五、主题模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E3%80%81RPC"><span class="toc-number">8.0.8.6.</span> <span class="toc-text">六、RPC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%EF%BC%9FRabbitMQ-%E7%9A%84%E9%9B%86%E7%BE%A4"><span class="toc-number">8.0.9.</span> <span class="toc-text">@$如何保证高可用的？RabbitMQ 的集群</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/01/%E7%AE%97%E6%B3%95/7%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/AcWing/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/02/01/%E7%AE%97%E6%B3%95/7%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/AcWing/" title="无题">无题</a><time datetime="2023-02-01T15:55:11.432Z" title="发表于 2023-02-01 23:55:11">2023-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/31/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/ruiji/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/01/31/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/ruiji/" title="无题">无题</a><time datetime="2023-01-31T14:50:49.607Z" title="发表于 2023-01-31 22:50:49">2023-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/21/%E7%AE%97%E6%B3%95/00pythonapi/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/12/21/%E7%AE%97%E6%B3%95/00pythonapi/" title="无题">无题</a><time datetime="2022-12-21T14:08:13.553Z" title="发表于 2022-12-21 22:08:13">2022-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/12/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E/0%E7%AE%80%E4%BB%8B/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/12/12/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E/0%E7%AE%80%E4%BB%8B/" title="无题">无题</a><time datetime="2022-12-12T15:06:58.895Z" title="发表于 2022-12-12 23:06:58">2022-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/19/22CloudNative/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/11/19/22CloudNative/" title="无题">无题</a><time datetime="2022-11-19T15:17:22.198Z" title="发表于 2022-11-19 23:17:22">2022-11-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By ggq</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>